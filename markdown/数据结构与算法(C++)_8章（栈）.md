## 概述

​		回顾线性表的知识，一个抽象类型的线性表具有这些函数：empty()、size()、get(idx)、insert(idx,x)、erase(idx)、indexOf(x)以及output()。核心操作就是insert和erase函数，以数组描述的线性表的erase函数为例，如下方代码所示。

```c++
template<class T>
void _charter5_arrayList<T>::erase(int theIndex)
{
	checkIndex(theIndex);
	std::copy(element + theIndex + 1, element + listSize, element + theIndex);
	element[--listSize].~T(); 
}
```

​		可以看出erase的操作就是把index后面的元素整体向前复制进行覆盖，index可以取任何值，insert和get操作同理。所以限制index的取值在一端，就可以得到**<u>栈的数据结构，即"后进先出"的结构</u>**。栈有自己的3种操作，即获取栈顶元素top、出栈pop和入栈push。那么定义哪一端为栈顶呢？因为top内部调用的其实就是get，pop是erase，push是insert，那么肯定希望使用最好情况的插入、删除和获取操作。显然数组右端进行这3个操作时间复杂度最低，无需整体向后移动或者向前覆盖。故定义栈顶为数组右侧，栈底为数组左侧，实现只能栈顶进行操作只需要idx限制为listSize即可，或者size()。

​		由于线性表和栈之间的关系，所以定义栈的数据结构可以通过派生自线性表具体类实现，也可以不派生直接自定义抽象类Stack，这两种方式都可以，但是派生线性表的具体类效率比较低，下边给出数组描述和链表描述分别在具体类派生和自定义抽象类Stack派生的实现。

## 8.1  数组描述的栈

​		既然是栈，就必须定义一个栈的抽象数据结构Stack，根据概述中的描述，栈主要具备3个函数，top、pop和push，以及栈空empty和栈的元素数量size，其抽象类的声明如下所示。

```c++
template<class T>
class abstractStack
{
public:
	virtual ~abstractStack() {};
	virtual bool empty() const = 0;
	virtual int size() const = 0;
	virtual T& top() = 0;
	virtual void pop() = 0;
	virtual void push(const T& theElement) = 0;
};
```

### 8.1.1 数组线性表派生栈		

​		派生栈具体类的声明如下所示，派生自线性表具体类，output和<<重载函数是额外实现的，且output定义为私有，便于测试

```c++
#include "charter8_arrayList.h"
#include "charter8_abstractStack.h"
#include "charter8_stackEmpty.h"
template<class T>
class derivedArrayStack : private _charter8_arrayList<T>, public abstractStack<T>
{
public:
	derivedArrayStack(int initialCapacity = 10) : _charter8_arrayList<T>(initialCapacity) {} // 构造函数直接继承
	bool empty() const { return _charter8_arrayList<T> ::empty(); } // empty直接继承
	int size() const { return _charter8_arrayList<T>::size(); } // size直接继承
	// 抽象栈类的具体实现
	T& top(); 
	void pop();
	void push(const T&);
	friend ostream& operator<<<>(ostream&, const derivedArrayStack<T>&);
private:
	void output(std::ostream& out) const ; // 重写output方法
};
```

​		派生栈具体类的实现部分如下所示，除output和<<重新定义以外，其他函数都来源于继承或者使用继承的方法间接实现。

​		top、pop和push函数：

```c++
template<class T>
T& derivedArrayStack<T> ::top()
{
	// 下方程序是正确的,但是有个地方需要改善,get的索引出错时抛出的异常是illegalParameterValue
	// 那么对于外部的使用人员来说,他并不知道这个继承的逻辑,所以应该把这种类型异常转为栈空类型的异常
	//if (_charter8_arrayList<T>::empty())
	//	throw stackEmpty();
	//return  _charter8_arrayList<T>::get(_charter8_arrayList<T>::size() - 1); // 获取右端的元素 即listSize-1
	try { return _charter8_arrayList<T>::get(_charter8_arrayList<T>::size() - 1); }
	catch (illegalParameterValue) { throw stackEmpty(); } // 借助try_catch结构进行转换
}

template<class T>
void derivedArrayStack<T> ::pop()
{
	if (_charter8_arrayList<T>::empty())
		throw stackEmpty();
	  _charter8_arrayList<T>::erase(_charter8_arrayList<T>::size() - 1); // 删除的是listSize-1的元素
}

template<class T>
void derivedArrayStack<T> ::push(const T& theElement)
{
	  _charter8_arrayList<T>::insert(_charter8_arrayList<T>::size(), theElement); // 插入的位置在listSize
}
```

​		output和<<重载函数：

```c++
template<class T>
void derivedArrayStack<T> ::output(std::ostream &out) const
{
	// 原来的实现方法
	/*std::copy(element, element + listSize, std::ostream_iterator<T>(std::cout, "   "));*/
	if (_charter8_arrayList<T>::size() == 0)
		throw stackEmpty();
	for (int i = 0; i < _charter8_arrayList<T>::size(); i++)
	{
		cout << _charter8_arrayList<T>::element[i] << "  ";
		if ((i + 1) % 10 == 0)
			out << endl;
	}
}

template<class T>
ostream& operator<<<>(ostream& out, const derivedArrayStack<T>& theStack)
{
	theStack.output(out);
	return out;
}
```

​		本派生栈类的测试代码如下。

```c++
void _charter8_derivedArrayStack()
{
	derivedArrayStack<int> s;
	if (s.empty())
		cout << "The stack is empty" << endl;
	for (int i = 1; i <= 25; i++)
		s.push(i);
	cout << "The stack size is " << s.size() << endl;
	cout << "Stack should be 1234, bottom to top" << endl;
	cout << s << endl;

	while (!s.empty())
	{
		cout << "Stack top is " << s.top() << endl;
		s.pop();
		cout << "Popped top element" << endl;
	}
	try { s.pop(); }
	catch (stackEmpty message)
	{
		cout << "Last pop failed " << endl;
		message.outputMessage();
	}
}		
```

### 8.1.2 数组抽象栈派生

​		无需复杂的继承逻辑，相比线性表具体类的派生要简单直接。

​		其声明如下。

```c++
template<class T>
class arrayStack : public abstractStack<T>
{
public:
    arrayStack(int initialCapacity = 10);
    ~arrayStack() { delete[] stack; }
    bool empty() const { return stackTop == -1; }
    int size() const{return stackTop + 1;}
    T& top();
    void pop();
    void push(const T& theElement);
    friend ostream& operator <<<>(ostream&, const arrayStack<T>&);
private:
    int stackTop;         // 栈顶元素对外索引是0,但是在内部是stack[stackTop],栈底是stack[0]
    int arrayLength;      // 栈容量
    T* stack;           // 存储栈元素
};
```

​		实现如下。

```c++
template<class T>
arrayStack<T>::arrayStack(int initialCapacity)
{
    if (initialCapacity < 1)
    {
        ostringstream s;
        s << "Initial capacity = " << initialCapacity << " Must be > 0";
        throw illegalParameterValue(s.str());
    }
    arrayLength = initialCapacity;
    stack = new T[arrayLength];
    stackTop = -1; // 默认栈空此时为-1
}

template<class T>
T& arrayStack<T>::top()
{
    if (stackTop == -1)
        throw stackEmpty();
    return stack[stackTop]; 
}

template<class T>
void arrayStack<T>::pop()
{
    if (stackTop == -1) 
        throw stackEmpty();
    stack[stackTop--].~T();  // 直接析构掉stack的最后1个元素即可无需借助erase
}

template<class T>
void arrayStack<T>::push(const T& theElement)
{
    if (stackTop == arrayLength - 1) // 没有容量,扩充2倍
    {
        T* temp = new T[2 * arrayLength];
        std::copy(stack, stack + arrayLength, temp);
        delete[] stack;
        stack = temp;
        arrayLength *= 2;
    }
    stack[++stackTop] = theElement; // 先++,也就是在后1位存储该元素
}

template<class T>
ostream& operator <<<>(ostream&out, const arrayStack<T>& theStack)
{
    if (theStack.empty())
        out << "Stack is empty!" ;
    for (int i = 0; i < theStack.size(); i++)
    {
        out << theStack.stack[i] << "  ";
        if ((i + 1) % 10 == 0)
            out << endl;
    }    
    return out;
}
```

## 8.2 链表描述的栈

​		链表描述的栈也可以通过第六章的chain进行派生，但是限于效率较低不在给出，直接从抽象类具体化实现。

​		其声明如下，带有1个私有属性topNode用来替换数组描述的stack来存储数据。

​		要注意的是每次topNode都是用原来的topNode构建的，最早的topNode=NULL。

```c++
#include "charter8_abstractStack.h"
#include "charter8_stackEmpty.h"
#include "charter8_stackNode.h"
template<class T>
class linkedStack : public abstractStack<T>
{
public:
    linkedStack(int initialCapacity = 10) { topNode = NULL; stackSize = 0; log = false; }
    //最初的topNode是NULL,最后的topNode是栈顶
    //next相当于是自顶向下第2个元素地址,一路到栈底再到NULL
    ~linkedStack();
    bool empty() const{return stackSize == 0;}
    int size() const{return stackSize;}
    T& top();
    void pop();
    void push(const T&);
    void isLog(bool log) { this->log = log; }
    friend ostream& operator <<<>(ostream&, const linkedStack<T>&);
private:
    stackNode<T>* topNode;  // 数组描述的使用T* stack存储数据,链表描述则是使用topNode存储
    // topNode.data代替的就是数组描述时T*stack的存储功能,且多1个next指针功能
    int stackSize; 
    bool log ;
};
```

​		实现如下。

```c++
template<class T>
linkedStack<T>::~linkedStack()
{
    while (topNode != NULL)
    {
        stackNode<T>* nextNode = topNode->next;
        if (log == true)
            cout << "xigou~~  "<<"top = "<<topNode<<"  next = "<<nextNode<< endl;
        delete topNode; // 删除的是值而不是这个属性
        topNode = nextNode; // 重复等于它自身的下一个,topNode的下一个总是NULL
    }
}

template<class T>
T& linkedStack<T>::top()
{
    if (stackSize == 0)
        throw stackEmpty();
    return topNode->data; //真实的数据存储地方
}

template<class T>
void linkedStack<T>::push(const T& theElement )
{
    if (log == true)
        if (stackSize == 0 )
            cout << "0：" << "top = " << topNode <<"  previous = unknown"<<endl; // <<topNode->next 会出错
    // topNode总是指向新增的节点,并让next指向原来的的topNode,最初始的topNode=NULL
    topNode = new stackNode<T>(theElement, topNode); //相当于newTop->data=theElement,newTop->next=oldTop
    // 最终的topNode一路next下去就是NULL,通过对topNode的遍历即可得到存储的数据
    stackSize++;
    if (log == true)
        cout << "Node("<<stackSize<<") = " << topNode << "  previous = " << topNode->next << "  value = " << theElement << endl;
        // 从输出信息知道栈底的next就是NULL,栈顶元素是topNode,next为下1个,一路到栈底再到NULL
}

template<class T>
void linkedStack<T>::pop()
{
    if (stackSize == 0)
        throw stackEmpty();
    stackNode<T>* nextNode = topNode->next; // 那么nextNode为原来自顶向下的第2个元素
    delete topNode;
    topNode = nextNode; // 第2个元素成为新的栈顶
    stackSize--;
}

template<class T>
ostream& operator <<<>(ostream& out, const linkedStack<T>& theStack)
{
    if (theStack.empty())
        out << "Stack is empty!";
    stackNode<T> *Node = theStack.topNode;
    int idx = 0;
    while (Node != NULL )
    {
        out << Node->data << "  ";
        if ((idx + 1) % 10 == 0)
            out << endl;
        Node = Node->next;
        idx++;
    }
    return out;
}
```

## 8.3 应用

### 8.3.1 括号匹配问题

​		括号匹配就是一个左括号和一个右括号匹配，可以观察知道从左到右扫描表达式的时候，右括号总是和最近的左括号匹配。那么可以每次扫描到左括号时入栈，扫描到右括号时就和栈顶的括号匹配，如果栈顶有元素说明匹配成功，否则说明剩余的右括号没有左括号可以与之匹配。或者右括号都匹配完了，左括号还有剩余，也是没匹配完全。

​		举例：

```c++
e x p (  (  (  (  a + b  )  / c ) -  d ) - 1 ) /  ( f + g )
         3 4 5 6           10    13     16   19   21      25
```

​		关于括号匹配的C++程序如下，使用的是数组描述的栈。

```c++
void parenthesis_matching(const std::string & str)
{
	arrayStack <int > stack;
	int length = (int)str.size();
	for (int i = 0; i < length; i++)
	{
		if (str.at(i) == '(')
		{
			stack.push(i); //push的是索引位置
			cout << "now stack is " << stack << endl;
		}
			
		else
			if (str.at(i) == ')')
                try
                {
                        cout << "left parenthesis ("<<stack.top() << 
                            ") and right parenthesis ("<<i <<") is match" << endl;
                        stack.pop(); // 匹配到1个就删除,否则栈空抛出
                }
                catch (stackEmpty)
                {
                    cout << " No match right parenthesis" << " at (" << i << ")" << endl;
                }	
	}
	while (!stack.empty())
	{
		cout << " No match left parenthesis" << " at (" << stack.top() << ")" << endl;
		stack.pop();
	}
}
```

​		上述例子的测试程序结果：

```c++
now stack is 3
now stack is 3  4
now stack is 3  4  5
now stack is 3  4  5  6
left parenthesis (6) and right parenthesis (10) is match
left parenthesis (5) and right parenthesis (13) is match
left parenthesis (4) and right parenthesis (16) is match
left parenthesis (3) and right parenthesis (19) is match
now stack is 21
left parenthesis (21) and right parenthesis (25) is match
```

### 8.3.2 汉诺塔问题

​		问题描述：一共有3个塔，第1个塔有n个碟子，从塔的底部到顶部碟子越来越小，即碟子小的在上，大的在下。现在要把第1个塔的碟子还是按照自下(大碟子)而上(小碟子)的摆放模式放在第2个塔上，第3个塔是借助。规则：大碟子永远不能压在小碟子上边，而且每次只能移动1个碟子。

​		现在举例，n=4，记小碟子编号为1，大碟子编号4，开始的塔A、B、C情况为塔A=1,2,3,4，B和C没有碟子。那么共计需要15个步骤才能完成交换，如下图所示。

![](C:\Users\chenb\Desktop\2022.1备份\markdown文件\汉诺塔问题.jpg)

​		上述图片相当于完成的逻辑是

​		A.pop、C.push ; A.pop、B.push ; 2次  =>1、3；1、2；

​		C.pop、B.push；A.pop、C.push；2次 =>3、2；1、3；

​		B.pop、A.push；B.pop、C.push；2次 =>2、1；2、3；

​		A.pop、C.push；A.pop、B.push；2次 =>1、3；1、2；

​		C.pop、B.push；C.pop、A.push；2次 =>3、2；3、1；

​		B.pop、A.push；C.pop、B.push；2次 =>2、1；3、2；

​		A.pop、C.push；A.pop、B.push；2次 =>1、3；1、2

​		C.pop、B.push；                                   1次 =>3、2；

​		根据上述图片的分析，发现碟子的数量n与移动的次数move(n)最终满足如下表达式。

```c++
		 0  n = 0
move(n)=
    	 2move(n-1)+1 n >0
递推有 
move(n) = 2^n - 1 次
```

​		根据上述分析，可以看出一定的规律。图片左半部分是把n-1个元素从塔1借助塔2移动到塔3，右半部分是借助塔1把n-1个元素移动到塔2上。下方程序借助了递归，其输出语句可以显示从哪个塔pop的元素被push到哪个塔上，之后就可以利用这种规律来进行入栈和出栈的操作。towerx、towery、towerz是塔的索引，可以看成arrayStack数组的1个元素，按下方这样的顺序对不同的塔进行pop和push操作就可以完成调换。

```c++
void towerOfHanoi_byRecursion(int n , int towerx, int towery, int towerz)
{
	// 此程序并不是移动元素的程序，只是一个测试程序步的程序
	// 把n个碟子从x转移到y
	if (n > 0)
	{
		// 先把前n-1个碟子转移到z,最大的碟子就可以放在y
		towerOfHanoi_byRecursion(n-1,towerx, towerz, towery); 
		cout << "mov top disk from tower " << towerx << " to top of tower " << towery << endl;
		// 之后就可以把z上的n-1个碟子移动到y
		towerOfHanoi_byRecursion(n - 1, towerz, towery, towerx);
	}
}
```

​		下方程序就是依据上方程序进行的改变，需要定义一个全局栈数组，每个元素存储1个塔，事先需要先被初始化。因为塔的名字取的是1、2、3，所以为了能用到这个索引，定义的栈数组容量为4，但是只用到后3个。初始化完毕以后，就开始调用函数，初值给的是1、2、3。

```c++
arrayStack<int> charter8_tower[4];
void towerOfHanoi_byStack(int n )
{
	for (int d = n; d > 0; d--)
		charter8_tower[1].push(d);//初始状态,塔x把大碟子到小碟子(用整数代替)压入栈,塔y,z为空
	moveTopDisk(n, 1, 2, 3);
}
```

​	多的3条语句是将塔x的顶元素pop，再被push进塔y。

```c++

void moveTopDisk(int n , int x , int y, int z)
{
	if (n > 0)
	{
		moveTopDisk(n - 1, x, z, y);// 移动塔x的元素到z
		int d = charter8_tower[x].top(); // 每次从1个塔pop的元素被push到另外1个塔
		charter8_tower[x].pop();
		charter8_tower[y].push(d);
		cout << "mov top disk "<<d<<" from tower " << x << " to top of tower " << y << endl;
		moveTopDisk(n - 1, z, y, x); // 移动塔z的元素到y
	}
}
```

其它的应用问题比较困难，暂时跳过，本章结束~
