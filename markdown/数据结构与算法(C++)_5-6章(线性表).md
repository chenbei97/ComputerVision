

## 导言

### 1) 何谓数据结构和数据对象？

​	首先引入两个概念，数据对象和数据结构。

​	常见的数据结构有**<u>线性表</u>**、矩阵、栈、队列、字典、优先级队列、竞赛树、搜索树和图。5-6章主要研究线性表，线性表可以用数组和链式分别描述。主要涉及到的概念如下：

- 抽象数据类型和相应的C++**<u>抽象类</u>**
- 线性表的概念
- 变长数组和数组容量倍增的实现
- 数组的描述
- 数组结构**<u>迭代器</u>**



​		其中粗体下划线标注的抽象类和迭代器是新增的概念，需要重点关注。

​		数据对象则是数据结构的一组实例，例如：

​		bool = {false,true} // bool值

​		digit = {-3,-2,-10,1,2,3,4} // 一组数字

​		char = {A,B,C,..,Z,a,b,c,...,z} // 一组字符

​		int = {0,±1,±2,±3..} // 一组整型数

​		string = {aa,bb,abc,..} // 一组字符串

​		数据对象的实例以及构成实例的元素通常具有某种相关性，它们可以通过某种函数互相转换。即使不同实例它们之间也可以进行转换，例如字符串abc可以看成字符的a、b、c构成

### 2) 什么是线性表？

​		线性表可以叫做有序表，它的每一个实例都可以使用有穷元素的集合来描述，即实例的形式为：

```c++
exa = {e0,e1,e2,...,en-1} // 其中n是实例的长度,ei是实例的元素
```

​		其中实例exa是一个线性表，线性表的元素的结构和线性表的结构没有关系，当n=0时线性表为空。线性表中，元素之间只有先后关系，没有其他关系。

### 3) 线性表可以执行的操作？

​	创建1个线性表

​	撤销1个线性表

​	判断线性表是否为空

​	确定线性表的长度

​	按照给定的索引查找1个元素

​	按照给定的元素查找对应索引

​	按照给定的索引删除1个元素

​	按照给定的索引插入1个元素

​	从左到右输出线性表元素

### 4) 抽象数据类型

​	根据线性表可以执行的操作可以抽象出一个数据类型，无论什么语言还是什么实例都要满足这样的属性。

```c++
抽象数据类型 linearList
{
	实例 
        有限个元素的集合
    操作
    	实例构造(): 创建线性表
        empty(): 表空返回true,否则false
        size(): 返回表的长度
        get(index): 获取索引index的元素
        indexOf(x): 返回第一次出现x的索引,若没找到返回-1
        erase(index):删除索引index的元素,索引大于index的元素按索引减1
        insert(index,x):把x插入到索引index.索引大于index的元素索引都加1
    	output(): 从左到右输出元素
    	实例析构~(): 销毁线性表
}
```

### 5) 抽象类

​		在C++中有两种类，一种是抽象类一种是具体类，只有具体类才可以实例化。

​		抽象类的函数都是纯虚函数，即没有代码实现的纯虚函数，只有函数的定义。将上述的抽象数据类型转为抽象类即可得到下方的代码。

```c++
#include <ostream>
template<class T>
class _charter5_linearList
{
public:
    virtual ~_charter5_linearList() {}; // 析构函数
    virtual bool empty() const = 0;  // const=0的含义是纯虚函数初始化必须赋值，而且必须初始化为0
    virtual int size() const = 0;
    virtual T& get(int theIndex) const = 0;
    virtual int indexOf(const T& theElement) const = 0;
    virtual void erase(int theIndex) = 0;
    virtual void insert(int theIndex, const T& theElement) = 0;
    virtual void output(std::ostream& out) const = 0; //把线性表插入输出流
};
```

​	注意：抽象类的虚函数必须全部实现，才能变成具体类，否则依然是抽象类。且虚函数的初始化必须是0，使用const 0进行初始化。

## 5. 线性表之数组描述

### 5.1 线性表具体类

​	数组描述是把一个线性表的实例用数组表示，元素即数组元素。

​	数组创建的时候必须要事先知道数组的类型(使用模板类解决)和长度(使用动态数组解决)

​	**<u>声明和实现不在一个代码头文件中，包含头文件不能直接调用函数！！！</u>**

#### 5.1.1 声明头文件

​	根据上述线性表的抽象类，可以得到具体类的声明头文件如下。

```c++
#include "charter5_linearList.h"
// 线性表的具体类声明部分直接实现,复杂的函数分文件实现
template<class T>
class _charter5_arrayList : public _charter5_linearList<T>
{
public:
    // 时间复杂度为O(1),自定义时时间复杂度为O(initialCapacity)
    _charter5_arrayList(int initialCapacity = 10); // 默认构造

    // 时间复杂度为O(n)
    _charter5_arrayList(const _charter5_arrayList<T>&); // 复制构造,把 _charter5_arrayList<T>整体看成1个数据类型

    ~_charter5_arrayList() { delete[] element; }//析构函数

    // 抽象类的虚函数实现
    // 时间复杂度为O(1)
    bool empty() const { return listSize == 0; }// 表示这个成员函数传入的this指针为const,不能更改类的其他成员,如果const在前表示返回值是const

     // 时间复杂度为O(1)
    int size() const { return listSize; }// 元素个数

    // 时间复杂度为Θ(1)
    T& get(int theIndex) const;

    // 时间复杂度为O(max{listSize,1})=>O(listSize)
    int indexOf(const T& theElement) const; // 不能改变类成员也不能改变实例的元素,前者限制类外实例后者限制类内

    // 没有此元素索引Θ(1),有的话为Θ(listSize-theIndex),每一个元素的移动需要O(1),合计O(listSize-theIndex)
    void erase(int theIndex);

    // 是否抛出异常Θ(1),如果插入前数组空间满就会数组长度加倍,为Θ(arrayLength)=Θ(listSize)
    // 移动数组元素Θ(listSize-theIndex),总的时间复杂度O(listSize)
    void insert(int theIndex, const T& theElement);

    // 时间复杂度为O(listSize)
    void output(std::ostream& out) const;

    // 其他方法
    // 时间复杂度为O(1)
    int capacity() const { return arrayLength; }

protected:
    // 确定一个元素在0~listSize-1中的索引,注意不是arrayLength
    // 时间复杂度为Θ(1)
    void checkIndex(int theIndex) const; // 不可更改类成员的成员函数

    // 时间复杂度为Θ(n)
    void changeLength1D(T*& pa, int oldLength, int newLength); // 数组容量已满时加倍

    int arrayLength; // 线性表的容量≥listSize
    int listSize; // 线性表的元素个数
    T* element;
    // 存储线性表元素的一维数组,因为是动态创建的所以析构必须带上delete[]
};

```

#### 5.1.2 实现源代码	

​	实现的代码文件如下。

```c++
#include "charter5_arrayList.h"
#include "charter1_illegalParameterValue.h"
#include<sstream>
//template<class T>
//_charter5_arrayList<T>* _charter5_paL; // 声明1个全局指针可用于外部cpp文件调用
template<class T>
_charter5_arrayList<T>::_charter5_arrayList(int initialCapacity)
{
	// 默认构造实现
	if (initialCapacity < 1)
	{
		std::ostringstream s; //创建1个用于传递字符串的流
		s << "Initial Capacity = " << initialCapacity << "  Must be > 0";
		throw illegalParameterValue(s.str());
	}
	arrayLength = initialCapacity;
	element = new T[arrayLength]; // 动态开辟数组 析构函数必须对应delete [] element
	listSize = 0; //暂时0成员
	//_charter5_paL = this; // 全局指针指向this
}

template<class T>
_charter5_arrayList<T> ::_charter5_arrayList(const _charter5_arrayList<T>& theList)
{
	// 复制构造实现：可以参考charter5_01_线性表的抽象类和具体类.cpp对的变长一维数组实现
	arrayLength = theList.arrayLength;
	listSize = theList.listSize;
	element = new T[arrayLength];
	// element是个指针,指针+操作是可以的,把源的所有元素(不是容量)拷贝到当前指针指向的地址,这个地址的连续容量是arrayLength
	// 其实就相当于完全复制了
	std::copy(theList.element, theList.element + listSize, element); // copy函数要求传入开头结尾和目标
	//_charter5_paL = this; // 全局指针指向this
}

template<class T>
T& _charter5_arrayList<T>::get(int theIndex) const
{
	checkIndex(theIndex); //先检查有没有这个索引
	return element[theIndex];
}

template<class T>
int _charter5_arrayList<T>::indexOf(const T& theElement) const
{
	int theIndex = (int)(std::find(element, element + listSize, theElement) - element);
	if (theIndex == listSize) // listSize是取不到的边界[0,listSize-1] or[0,listSize)
		return -1;
	else return theIndex;
}

template<class T>
void _charter5_arrayList<T>::erase(int theIndex)
{
	checkIndex(theIndex);
	// theIndex是要删除的位置,theIndex + 1是后1个元素位置
	// element是一个指针,指向了后1个元素,并指向结尾元素的后1个
	// 把[index+1,listSize)之间的元素拷贝theIndex的位置起始,也就是后面的元素整体向前移动1个单位
	std::copy(element + theIndex + 1, element + listSize, element + theIndex);
	// --listSize是个数减少了,--在前表达式先改变
	element[--listSize].~T(); // 调用析构函数,原来只是拷贝,但是listSize-1的这个元素还在需要清除
}

template<class T>
void _charter5_arrayList<T>::changeLength1D(T*& pa, int oldLength, int newLength)
{
	if (newLength < 0)
		throw illegalParameterValue("new length must be >=0");
	T* temp = new T[newLength];
	// 如果新的长度变长最多复制原来的那么多元素,如果变短就复制当前这么多元素
	int number = std::min(oldLength, newLength);//要复制的元素个数
	std::copy(pa, pa + number, temp); // a是个T类型的指针的引用类型 可以+操作
	delete[] pa; // 删除原来的容器元素
	pa = temp; // 指向新的容器
}

template<class T>
void _charter5_arrayList<T>::insert(int theIndex, const T& theElement)
{
	if (theIndex <0 || theIndex > listSize)
	{
		std::ostringstream s;
		s << "index = " << theIndex << "   size = " << listSize;
		throw illegalParameterValue(s.str());
	}
	if (listSize == arrayLength)
	{
		// 数组已满,则拓展数组为2倍长度
		// 之所以使用2《数据结构、算法与应用C++语言描述》P101页的定理5-1决定
		// 如果按照1个乘法因子来增加数组长度，那么实施一系列线性表的操作所需要的时间与不用改变数组长度对比，至多增加1个常数因子
		// 如果表每次插入都是增加1个长度尾插1个,n次插入增加数组长度的时间是Θ(n^2),而直接增加长度n,尾插n次为Θ(n)
		changeLength1D(element, arrayLength, 2 * arrayLength); // element是1个指针
		arrayLength *= 2;
	}
	// [theIndex,listSize-1]之间的元素向右移动,初始位置是后1个元素位置listSize + 1
	// copy_backward和copy的不同在于前者是从最右端的元素开始移动,后者是从左端的元素移动
	// 节省一定时间
	std::copy_backward(element + theIndex, element + listSize, element + listSize + 1);
	element[theIndex] = theElement; //插入位置赋值要插入的元素
	listSize++; //元素个数增加了
}

template<class T>
void _charter5_arrayList<T>::output(std::ostream& out) const
{
	// 把所有元素复制到输出流中,利用输出流迭代器
	std::copy(element, element + listSize, std::ostream_iterator<T>(std::cout, "   "));
}

template<class T> // 重载运算符返回的也必须是流对象
std::ostream& operator << (std::ostream& out, const _charter5_arrayList<T>& x)
{
	// 输入参数为流对象和线性表实例的引
	x.output(out); // 利用output函数重载,就可以直接打印线性表了
	return out;
}
template<class T>
void _charter5_arrayList<T>::checkIndex(int theIndex) const
{
	if (theIndex < 0 || theIndex >= listSize)
	{
		std::ostringstream s;
		s << "index = " << theIndex << "   size - " << listSize;
		throw illegalParameterValue(s.str());
	}
}
```

#### 5.1.3 测试程序

​	测试程序如下。

```c++
void _charter5_concrete_class_instantiation()
{
	_charter5_arrayList<double> arr(20);
	int idx = 0;
	double x = 1.0;
	printf("arr.capacity() = %d\n", arr.capacity());
	printf(" arr.empty()) = %d\n", arr.empty());
	arr.insert(idx, x);
	printf(" arr.empty()) = %d\n", arr.empty());
	arr.insert(1, 2);
	printf(" arr.get(1)) = %f\n", arr.get(1));
	for (int i = 2; i < arr.capacity(); i++)
		arr.insert(i, (double)(i)+1);
	printf(" arr.size() = %d\n", arr.size());
	arr.insert(arr.size(), x); // 数组已经满再尾插容量就倍增
	printf("arr.capacity() = %d\n", arr.capacity());
	std::ostringstream s;
	arr.output(s); // 自动输出
}
```

### 5.2 线性表迭代器

#### 5.2.1 迭代器的概念

​	迭代器是一个指针，指向开头或者结尾，可以通过算术运算得到一个数组的任意位置，然后解引用即可访问元素。

​	C++的STL定义了5种迭代器，所有迭代器都具备操作符==、!=、解引用操作符*：

​	1.输入迭代器：额外提供指向元素的只读操作、前++和后++操作符

​	2.输出迭代器：额外提供指向元素的写操作和++操作符

​	3.向前迭代器：额外提供++操作符

​	4.双向迭代器：额外提供++和--操作符

​	5.随机访问迭代器：最一般的迭代器，可以随意的实现跳跃移动，也可以使用指针算数运算实现跳跃移动，如下方的数组迭代器y。

```c++
void _simple_iterator()
{
	const int n = 5;
	int x[n] = { 0,1,2,3,4 };
	int count = 0;
	printf("使用迭代器: \n");
	for (int* y = x; y != x + n; y++)
	{
		printf("x[%d] = %d    ",count,*y );
		count++;
	}
	printf("\n不使用迭代器: \n");
	// <=> 等价于 下方代码
	for (int i = 0; i != n; i++)
		std::cout << "x["<<i<<"] = " <<x[i]<< "   ";
	std::cout <<std::endl;
}
```

#### 5.2.2 双向迭代器

​	注意要引入头文件 <iterator>，迭代器类内部实现了++、--的前后操作，解引用操作，解引用需要重载是因为解引用的是实例的指针，也就是position，而position是个私有指针,可以通过thePosition赋值改变。

```c++
#pragma once
#include <iterator>
template<class T>
class _charter5_bidirectIterator
{
public:
	// 使用typedef实现双向迭代器,将下述关键字起别名
	// bidirectional_iterator_tag,T,ptrdiff_t, T*, T&都起相应的别名
	// 其中bidirectional_iterator_tag和ptrdiff_t必须include <iterator>且std命名空间下
	typedef std::bidirectional_iterator_tag iterator_category;
	typedef  T value_type;
	typedef std::ptrdiff_t  difference_type;
	typedef T* pointer;
	typedef T& reference;

	// 默认构造函数,传入参数是一个指针,指针默认指向开头
	_charter5_bidirectIterator(T* thePosition = 0) { position = thePosition; }

	// 重载解引用*,->操作符
	T& operator*() const { return *position; }
	T* operator->() const { return &*position; }

	// 双向迭代器的++操作符重载
	_charter5_bidirectIterator& operator++()
	{
		++position; return *this; // 前加 就是先加，然后才用这个变量
		// 注意如何实现：
	}
	_charter5_bidirectIterator operator++(int) // 后加 先用这个变量，然后在对这个变量做自增
	{
		_charter5_bidirectIterator old = *this;
		++position;
		return old;
	}

	// 双向迭代器的--操作符重载
	_charter5_bidirectIterator& operator--()   // 前减
	{
		--position; return *this;
	}
	_charter5_bidirectIterator operator--(int) // 后减
	{
		_charter5_bidirectIterator old = *this;
		--position;
		return old;
	}

	// 测试是否相等
	bool operator!=(const _charter5_bidirectIterator right) const
	{
		return position != right.position;
	}
	bool operator==(const _charter5_bidirectIterator right) const
	{
		return position == right.position;
	}
protected:
	T* position;
};
```

### 5.3 使用数组描述的线性表类

#### 5.3.1 声明与实现

​	声明和实现写在一个代码头文件中。

```c++
#pragma once
#include "charter5_linearList.h"
#include "charter1_illegalParameterValue.h"
#include <iterator> // 使用bidirectional_iterator_tag和ptrdiff_t
#include<sstream> // 使用ostringstream

// 线性表带迭代器的具体类声明部分和实现写在同一文件中
// 就可以被其它文件调用
template<class T>
class _charter5_arrayListWithIterator : public _charter5_linearList<T>
{
public:
    _charter5_arrayListWithIterator(int initialCapacity = 10);
    _charter5_arrayListWithIterator(const _charter5_arrayListWithIterator<T>&);
    ~_charter5_arrayListWithIterator() { delete[] element; }

    bool empty() const { return listSize == 0; }
    int size() const { return listSize; }
    T& get(int theIndex) const;
    int indexOf(const T& theElement) const; 
    void erase(int theIndex);
    void insert(int theIndex, const T& theElement);
    void output(std::ostream& out) const;
    int capacity() const { return arrayLength; }

	// 迭代器类整体作为线性表类的公有成员,迭代器类的2个方法也是公有成员
	class _charter5_iterator;// 类本身也是1个成员
	_charter5_iterator begin() { return _charter5_iterator(element); } // element是个指向线性表开头的指针,对应begin
	_charter5_iterator end() { return _charter5_iterator(element + listSize); }// element+listSize是最后1个元素的后1个位置
	class _charter5_iterator
	{
	public:
		// 使用typedef实现双向迭代器,将下述关键字起别名
		// bidirectional_iterator_tag,T,ptrdiff_t, T*, T&都起相应的别名
		typedef std::bidirectional_iterator_tag iterator_category;
		typedef  T value_type;
		typedef std::ptrdiff_t  difference_type;
		typedef T* pointer;
		typedef T& reference;

		// 默认构造函数,传入参数是一个指针
		_charter5_iterator(T* thePosition = 0) { position = thePosition; }

		// 重载解引用*,->操作符
		T& operator*() const { return *position; }
		T* operator->() const { return &*position; }

		// 双向迭代器的++操作符重载
		_charter5_iterator& operator++()   
		{
			++position; return *this; // 前加 就是先加,然后才用这个变量<=>++operator
			// 注意如何实现：position已经先+再返回this,此时表达式值已经变化
		}
		_charter5_iterator operator++(int) // 后加 先用这个变量,然后在对这个变量做自增<=>operator++
		{
			// i++ 后加 相当于+1,需要传入int参数
			// 先保留+之前的结果,也就是position没+,表达式值没变
			_charter5_iterator old = *this;
			++position;
			return old;
		}

		// 双向迭代器的--操作符重载
		_charter5_iterator& operator--()   // 前减
		{
			--position; return *this;
		}
		_charter5_iterator operator--(int) // 后减
		{
			_charter5_iterator old = *this;
			--position;
			return old;
		}

		// 测试是否相等
		bool operator!=(const _charter5_iterator right) const
		{
			// 左侧应当是this,右侧应当是传入的外界指针
			// 例如iterator != x.end() 是2个迭代器的!=运算
			return position != right.position; // 迭代器是否相等需要转换为迭代器指向的地址是否相等
		}
		bool operator==(const _charter5_iterator right) const
		{
			return position == right.position;
		}
	protected:
		T* position;
	};  

protected:
    void checkIndex(int theIndex) const;
    void changeLength1D(T*& pa, int oldLength, int newLength); 
    int arrayLength; 
    int listSize; 
    T* element;
};
template<class T>
_charter5_arrayListWithIterator<T>::_charter5_arrayListWithIterator(int initialCapacity)
{
	if (initialCapacity < 1)
	{
		std::ostringstream s; 
		s << "Initial Capacity = " << initialCapacity << "  Must be > 0";
		throw illegalParameterValue(s.str());
	}
	arrayLength = initialCapacity;
	element = new T[arrayLength]; 
	listSize = 0; 
}

template<class T>
_charter5_arrayListWithIterator<T> ::_charter5_arrayListWithIterator(const _charter5_arrayListWithIterator<T>& theList)
{
	arrayLength = theList.arrayLength;
	listSize = theList.listSize;
	element = new T[arrayLength];
	std::copy(theList.element, theList.element + listSize, element); 
}

template<class T>
T& _charter5_arrayListWithIterator<T>::get(int theIndex) const
{
	checkIndex(theIndex); 
	return element[theIndex];
}

template<class T>
int _charter5_arrayListWithIterator<T>::indexOf(const T& theElement) const
{
	int theIndex = (int)(std::find(element, element + listSize, theElement) - element);
	if (theIndex == listSize) 
		return -1;
	else return theIndex;
}

template<class T>
void _charter5_arrayListWithIterator<T>::erase(int theIndex)
{
	checkIndex(theIndex);
	std::copy(element + theIndex + 1, element + listSize, element + theIndex);
	element[--listSize].~T(); 
}

template<class T>
void _charter5_arrayListWithIterator<T>::changeLength1D(T*& pa, int oldLength, int newLength)
{
	if (newLength < 0)
		throw illegalParameterValue("new length must be >=0");
	T* temp = new T[newLength];
	int number = std::min(oldLength, newLength);
	std::copy(pa, pa + number, temp);
	delete[] pa; 
	pa = temp; 
}

template<class T>
void _charter5_arrayListWithIterator<T>::insert(int theIndex, const T& theElement)
{
	if (theIndex <0 || theIndex > listSize)
	{
		std::ostringstream s;
		s << "index = " << theIndex << "   size = " << listSize;
		throw illegalParameterValue(s.str());
	}
	if (listSize == arrayLength)
	{
		changeLength1D(element, arrayLength, 2 * arrayLength); 
		arrayLength *= 2;
	}
	std::copy_backward(element + theIndex, element + listSize, element + listSize + 1);
	element[theIndex] = theElement; 
	listSize++; 
}

template<class T>
void _charter5_arrayListWithIterator<T>::output(std::ostream& out) const
{
	std::copy(element, element + listSize, std::ostream_iterator<T>(std::cout, "   "));
}

template<class T> 
std::ostream& operator << (std::ostream& out, const _charter5_arrayListWithIterator<T>& x)
{
	x.output(out); 
	return out;
}

template<class T>
void _charter5_arrayListWithIterator<T>::checkIndex(int theIndex) const
{
	if (theIndex < 0 || theIndex >= listSize)
	{
		std::ostringstream s;
		s << "index = " << theIndex << "   size - " << listSize;
		throw illegalParameterValue(s.str());
	}
}
```

#### 5.3.2 测试程序

​	测试程序如下。

```c++
void _charter5_arrayList_with_bidirectionalIterator()
{
    _charter5_arrayListWithIterator<int> y(2); // 容量2
    y.insert(0, 2);
    y.insert(1, 6);//此时容量为2
    y.insert(0, 1);//一旦容量满了再插就会倍增
    printf("the capacity = %d\n", y.capacity()); // the capacity = 4
    y.insert(2, 4);
    y.insert(3, 5); // 再次倍增 the capacity = 8
    y.insert(2, 3);
    printf("the capacity = %d\n", y.capacity()); // the capacity = 8
    cout << "Inserted 6 integers, list y should be 1 2 3 4 5 6" << endl;
    ostringstream s;
    y.output(s);
    cout << "Size of y = " << y.size() << endl;

    // 测试迭代器的使用
    cout << "测试operator++和++operator" << endl;
    cout << "测试operator++" << endl;
    for (_charter5_arrayListWithIterator<int>::_charter5_iterator i = y.begin();
        i != y.end(); i++) // 无论前++还是后++i都已经自增不影响结果
        cout << *i << "  "; 
    cout << endl;
    cout << "测试++operator" << endl;
    for (_charter5_arrayListWithIterator<int>::_charter5_iterator i = y.begin();
        i != y.end(); ++i)// 无论前++还是后++i都已经自增不影响结果
        cout << *i << "  ";
    cout << endl;

    cout << "测试operator--和--operator" << endl;
    // 使用--需要从后往前,但是y.end()是最后元素位置的后1个,不能越界所以表达式应该是已经变化,使用前-
    for (_charter5_arrayListWithIterator<int>::_charter5_iterator i = y.end();
        i != y.begin(); cout << *(--i) << "  "); // 但是把语句放在了判断上就产生了区别
    cout << endl;
    for (_charter5_arrayListWithIterator<int>::_charter5_iterator i = y.end();
        i != y.begin();)//语句不放在判断上就简单了,i--和--i没有区别
    {
        // 先i--还是i--都可以
        --i; cout << *i << "  "; *i += 1;
    }
    cout << endl;
    y.output(s);

    //测试一些STL的算法
    reverse(y.begin(), y.end());
    cout << "The reversed list is " << y << endl; // 直接打印也可以
    int sum = accumulate(y.begin(), y.end(), 1); // 最后1个参数是起始值
    cout << "The sum of the elements is " << sum << endl;
}
```

### 5.4 使用vector描述的线性表类

#### 5.4.1 声明与实现

​	声明和实现写在一个代码头文件中。

```c++
#pragma once
/*
本头文件定义的类_charter5_vectorList和charter5_arrayList.h的类_charter5_arrayList有相同点也有不同点
_charter5_arrayList的数组长度需要动态增加,_charter5_vectorList类似按照原容量的50%-100%增加
_charter5_vectorList没有一个构造函数和_charter5_arrayList的构造函数等价
两者都有empty、size、output和重载<<方法,是等价的
_charter5_vectorList的erase和insert方法略有不同,需要给定内存地址,或者说迭代器位置,数组给定索引即可
最后两者抛出的异常类型是不同的,checkIndex中体现

arrayList借助数组实现,需要私有变量arrayLength,在默认构造函数中传递
还需要私有变量listSize,初始化为0,通过insert函数中进行++
element是一个T类型的动态数组的指针
从而empy函数是通过listSize是否为0来判定,size也是通过listSize
get函数核心就是return element[theIndex];这是数组索引的方式,数组指针也可以使用[]索引
indexOf函数查找theElement元素是借助element在数组两端的指针,使用find函数查找
insert函数需要借助changeLength1D实现,自行更新索引
erase需要借助copy实现,然后清除元素更新索引
checkIndex函数抛出类型为illegalParameterValue

vectorList借助vector实现,无需私有变量,element是一个vector<T>的指针
empy,size直接使用vector的内置方法empy和size,这是因为数组没有这两个方法
get函数核心语句return (*element)[theIndex];因为vector支持[]索引,区别需要解引用,容器指针不支持直接[]索引
indexOf函数查找theElement元素也是借助element,区别在于element是容器类型的指针,那么就自带迭代器方法,使用箭头运算符即可使用
insert函数借助vector自带的方法inser(iterator,val) or inser(iterator,n,val)=>插入n个val  无需自己编写动态拓展宽度的函数
erase函数和insert函数同理,调用vector自带方法 erase
checkIndex函数抛出类型为illegalIndex

output和<<重载的实现2个类完全一样

*/#include "charter5_linearList.h"
#include "charter1_illegalIndex.h"
#include "charter1_illegalParameterValue.h"
#include <vector>
#include <ostream>
#include <iostream>
#include <sstream>
// statement
template<class T>
class _charter5_vectorList : public _charter5_linearList<T>
{
public:
	_charter5_vectorList(int initialCapacity = 10);
	_charter5_vectorList(const _charter5_vectorList<T>& theList);
	~_charter5_vectorList() { delete element; }
	bool empty() const { return element->empty(); }// 借助vector的方法empty
	int size() const { return (int)element->size(); }// 借助vector的方法size
	int indexOf(const T& theElement) const; // theElement是vector类型,元素是T类型
	T& get(int theIndex) const;
	void erase(int theIndex);
	void insert(int theIndex, const T& theElement);// 传入的是T类型的元素
	void output(std::ostream& out) const;
	int capacity() const { return (int)element->capacity(); };// 借助vector的方法capacity

	typedef typename std::vector<T> ::iterator iterator; // 把std::vector<T> ::iterator改名为iterator
	iterator begin() { return element->begin(); }// 返回的就是vector的迭代器类型
	iterator end() { return element->end(); } // 类的公有函数begin和end间接使用的是vector容器的方法begin和end

private:
	void checkIndex(int theIndex) const;
	std::vector<T>* element; // 是vector类型的指针,不是数组,析构使用delete而非delete []
};

// constructed
template<class T>
_charter5_vectorList<T> ::_charter5_vectorList(int initialCapacity)
{
	if (initialCapacity < 1)
	{
		std::ostringstream s;
		s << "initial capcaity = " << initialCapacity << "  must be > 0";
		throw illegalParameterValue(s.str());
	}
	element = new std::vector<T>; // 动态容器的指针,是vector类型的指针
}

template<class T>
_charter5_vectorList<T> ::_charter5_vectorList(const _charter5_vectorList<T>& theList)
{
	element = new std::vector<T>(*theList.element); // 复制构造是把vectorList的实例的私有属性element(1个容器)的指针解引用传递
	// 本质上就是一个容器传入了容器,vector有这样的构造函数
	//vector<int> arrint1(10);
	//vector<int>arrint2(arrint1);
	//cout << arrint2.capacity() << endl;
	// 这里相当于把*theList.element整个给了element,解引用是因为theList.element是指针
}

template<class T>
void _charter5_vectorList<T>::checkIndex(int theIndex) const
{
	if (theIndex < 0 || theIndex >= size())
	{
		ostringstream s;
		s << "index = " << theIndex << " size = " << size();
		throw illegalIndex(s.str());
	}
}

template<class T>
T& _charter5_vectorList<T>::get(int theIndex) const
{
	checkIndex(theIndex);
	return (*element)[theIndex];
}

template<class T>
int _charter5_vectorList<T>::indexOf(const T& theElement) const
{
	// 查找这个容器元素theElement在容器的位置
	// element是一个vector容器的指针,也具备内置方法begin和end,但是要使用箭头->运算符
	int theIndex = (int)(find(element->begin(), element->end(),
		theElement)
		- element->begin());//数组中需要减去element,这里也是,find返回的是第1个元素

	// check if theElement was found
	if (theIndex == size())
		// not found
		return -1;
	else return theIndex;
}

template<class T>
void _charter5_vectorList<T>::erase(int theIndex)
{
	checkIndex(theIndex);
	element->erase(begin() + theIndex);// 调用vector自带的方法erase
}

template<class T>
void _charter5_vectorList<T>::insert(int theIndex, const T& theElement)
{
	if (theIndex < 0 || theIndex > size())
	{// invalid index
		ostringstream s;
		s << "index = " << theIndex << " size = " << size();
		throw illegalIndex(s.str());
	}
	element->insert(element->begin() + theIndex, theElement);//调用vector自带的方法insert 指定插入的位置和元素
}

template<class T>
void _charter5_vectorList<T>::output(ostream& out) const
{
	copy(element->begin(), element->end(), ostream_iterator<T>(cout, "  "));
}

// overload <<
template <class T>
ostream& operator<<(ostream& out, const _charter5_vectorList<T>& x)
{
	x.output(out); return out;
}

```

#### 5.4.2 测试程序

​	测试程序如下。

```c++
void _charter5_vector_test();
void _charter5_linearList_by_vector()
{
	// 对容器的性质进行测试,便于对charter5_vectorList.h中vector的使用进行解释
	_charter5_vector_test();
	
	// 对实现的vectorList进行测试
	_charter5_linearList<double>* x = new _charter5_vectorList<double>(20); // 父类指针可以指向子类指针
	// 但是x没有子类的方法,即不存在x->capacity();
	_charter5_vectorList<int> y(2), z; // 直接创建实例,子类存在capacity()方法
	cout << "y.capacity() = " << y.capacity() << endl;
	cout << "Initial size of x, y, and z = "
		<< x->size() << ", " // size是共有的方法
		<< y.size() << ", "
		<< z.size() << endl;

	// 对insert函数测试
	y.insert(0, 2);
	y.insert(1, 6);
	y.insert(0, 1);
	y.insert(2, 4);
	y.insert(3, 5);
	y.insert(2, 3);
	cout << "Inserted 6 integers, list y should be 1 2 3 4 5 6" << endl;
	cout << "Size of y = " << y.size() << endl;
	cout << "Capacity of y = " << y.capacity() << endl;
	if (y.empty()) cout << "y is empty" << endl;
	else cout << "y is not empty" << endl;
	y.output(cout);
	cout << endl << "Testing overloaded <<" << endl;//直接打印也是可以的
	cout << y << endl;

	// 测试 indexOf
	int index = y.indexOf(4);
	if (index < 0) cout << "4 not found" << endl;
	else cout << "The index of 4 is " << index << endl;
	index = y.indexOf(7);
	if (index < 0) cout << "7 not found" << endl;
	else cout << "The index of 7 is " << index << endl;

	// 测试get
	cout << "Element with index 0 is " << y.get(0) << endl;
	cout << "Element with index 3 is " << y.get(3) << endl;

	// 测试erase
	y.erase(1);
	cout << "Element 1 erased" << endl;
	cout << "The list is " << y << endl;
	y.erase(2);
	cout << "Element 2 erased" << endl;
	cout << "The list is " << y << endl;
	cout << "Size of y = " << y.size() << endl;
	cout << "Capacity of y = " << y.capacity() << endl;
	if (y.empty()) cout << "y is empty" << endl;
	else cout << "y is not empty" << endl;

	// 测试异常处理
	try { y.insert(-3, 0); }
	catch (illegalIndex e)
	{
		cout << "Illegal index exception" << endl;
		cout << "Insert index must be between 0 and list size" << endl;
		e.outputMessage();
	}

	//测试复制构造
	_charter5_vectorList<int> w(y);
	y.erase(0);
	y.erase(0);
	cout << "w should be old y, new y has first 2 elements removed" << endl;
	cout << "w is " << w << endl;
	cout << "y is " << y << endl;

	//  测试迭代器
	y.insert(0, 4);
	y.insert(0, 5);
	y.insert(0, 6);
	y.insert(0, 7);
	for (_charter5_vectorList<int>::iterator i = y.begin(); //iterator使用了别名实际上就是vector自带的
		i != y.end(); i++)
		cout << *i << "  ";
	cout << endl;

	// 测试3个stl的方法
	reverse(y.begin(), y.end());
	cout << "The reversed list is " << y << endl;
	int sum = accumulate(y.begin(), y.end(), 0);
	cout << "The sum of the elements is " << sum << endl;
	sort(y.begin(), y.end());
	cout << "The sorted list is " << y << endl;
	sort(y.begin(), y.end(), greater<int>());
	cout << "The list is descending order is " << y << endl;

}
void _charter5_vector_test()
{
	vector<int> arrint1(10);
	vector<int>arrint2(arrint1); // 存在这种构造函数
	arrint2.insert(arrint2.begin(), 10, 2); //插入10个2
	cout << arrint2.capacity() << endl; // 容量自动倍增=20
	arrint2.insert(arrint2.end(), 5);
	cout << arrint2.capacity() << endl; // 尾插又加10
	// arrint2.insert(3, 8);直接插入位置3是不允许的,第1个参数是迭代器类型
	for (vector<int>::const_iterator it = arrint2.begin(); it != arrint2.end(); it++)
		cout << *it << "   ";
	cout << endl;
	printf("arrint2[5] = %d\n", arrint2[5]); // arrint2[5] = 2
}
```

### 5.5 数组实现的多重表

#### 5.5.1 多个小数组映射为大数组

​		数组描述线性表的优点：很多操作可以使用C++自带的方法实现，且方法insert/indexOf/erase的最坏时间复杂度和表的大小是线性关系，也就是*O*(n)，这是不错的时间性能。

​		缺点在于空间性能较差，空间利用率较低。例如，3个线性表要求任一时刻共同存储的元素个数不超过4097个，可能某个时刻只有1张表4097全部利用，其它2个表都没用上，但是3个线性表的实例实实在在的占据了4097*3的内存大小。

​		一个解决办法是把所有数组实例映射到一个足够大的数组，即一个大数组存放了多个小数组，并使用2个索引数组front和last来确定位置。约定，front[i]存放的第i个小数组的起始位置的前一个位置，last[i]存放的是第i个小数组的结束位置。表非空时front[i]<last[i]，否则front[i]=last[i]。

​		现在规定一个超大数组有m个表，且表编号从1到m开始，数组长度为length，那么索引范围为[0,length-1]，**<u>且每个小数组都装满了元素</u>**(这是下方首尾相连的前提)。

​		表1是从表1的**<u>第1个元素(也是大数组的第1个元素)的前一个位置开始,即front[1]=-1</u>**，last[1]是某个位置与front[2]重叠；

​		表2是从表2的第1个元素的前1个(也就是last[1])作为front[2]的，所以是首尾相连的,last[2]是某个位置与front[3]重叠；

​		表m是从表m的第1个元素的前一个(也就是last[m-1])作为front[m]的，而**<u>last[m]就是大数组的最后1个元素位置为length-1</u>**；

​		上述**<u>可以抽象为last[i]=front[i+1]=i-1,i=1,2,..m-1(那么对于front不能取到1，last不能取到m)</u>**，为了能够处理到边界front[1]和last[m]还需要定义边界表。

​		现在定义边界表0和表m+1，这是为了表1到表m有相同的方法处理。如果不定义表0，表1的开头的处理方法和表2的开头处理方法就会不同；同理不定义表m+1，表m的结尾处理方法与表m-1的结尾处理方法不能统一。

​		其中对表0有front[0]=last[0]=-1，front[1]=last[0]=-1依然成立；对表m+1有last[m+1]=front[m]=length-1，那么last[m]=front[m+1]依然成立；那么就可以将**<u>last[i]=front[i+1]=i-1的m取值范围拓展到i=0,1,2,..m</u>**，每个小数组的边界索引都满足此表达式。

#### 5.5.2 插入操作的实现

​		现在假如上述的大数组并没有插满元素，即某些小数组是不满的，此时想要对表i的第index个位置插入一个元素如何实现呢？

​		首先要考虑这个表i是否容量已满，因为插入操作会将表i的index位置及其右侧所有元素都向右移动1个单位，那么需要考虑表i的最后1个元素last[i]是否还有空间移动，即last[i]与front[i+1]的关系，如果相等是无法整体移动的，即表i的最后1个元素和表i+1的第1个元素之间没有空位。那么此时可以考虑的方法是将表i+1到表m的一些表整体向右移动，表i就增大了1个容量，这是为了提高空间利用率而如此操作；

​		插入操作也可以把表i的第1个元素到index-1的元素整体向左移动，这个要求last[i-1]<front[i]，即表i-1的最后1个元素和表i的第1个元素之间要有空位，如果不满足这个关系类似的可以把表1到表i-1的一些表整体向左移动，也使得表i增大1个容量。

​		上述的说明可以描述成如下伪码：

```c++
void insert(int i, int index, Object element)
{
    // 在表i的索引index处插入y
    size = last[i] - front[i] ; // 表i的元素个数,例如last[i]=9,front[i]=4,从front[i]+1开始是5,6,7,8,9共5个元素
    if (index < 0 || index > size) // index是在大数组的范围内,限制不能<0;同时index在小数组范围内
        throw an exception ;
    
    // 判断右面是否有空间
    如果表i的最后1个元素的位置last[i]<front[i+1]表i+1的第1个元素位置
    if last[i]<front[i+1] // 说明本数组有位置
        移动表i从index(包含)到last[i](包含)的元素右方1个单位,即index+1和last[i]+1,此时last[i]+1<=front[i+1]
        // 移动的结果也不会影响到表i+1的第1个元素，表i尾元素和表i+1首元素它们之间可能仍有空位，故是小于等于的关系
    如果表i没有空间，就去表i+1寻找，直到找到一个最小的j≥i，使得表j满足关系last[j]<front[j+1]
    while (! last[j]<front[j+1]) // j=i+1,..m
    {
        j++;
        if (j>m)
            break;
    }
    此时需要将表i的index(包含)到表j的last[j]整体向右移动1个单位
    
    // 判断左边是否有空间:把i和<i的情况结合起来,上述是i和>i分别写的
    while (! front[j+1] > last[j]) // j=i,i-1,..,1
    {
        j--;
        if (j<0)
            break;
    }
    移动表j+1的front[j+1](包含)到表i的index(包含)之间的元素整体向左移动1个单位，即front[j+1]-1和index-1,此时front[j+1]>=last[j]
     // 移动的结果也不会让表j+1的首元素在表j的尾元素之前，之间也可能还留有空位，所以是小于等于的关系
    
    // 最后判断是否成功
    if 右边和左边都没空间
        throw exception ; 
}
```

## 6.线性表之链式描述

​	基于数组的描述当中，元素的内存地址是连续的，而联试描述并非连续，是随机分布的。

​	每个元素都有一个明确的指针或链(指针和链一个意思)，这个指针指向了下一个元素的地址。

​	本章将引入新的数据结构概念，即链式描述、链表、循环表、双向链表和头节点。

​	STL的容器类list使用带有头节点的双向循环链表来描述实例，方法与vector的方法具有相同的签名和操作。与使用vector来使抽象类变为具体类相同，list也可以用来设计这样的具体类。

​	本章的链表主要应用有箱子排序(桶排序bucket sort)、基数排序(radix sort)、并查集问题(union-find)；双向链表的应用是凸包问题(convex hull)。上述的两个排序方法bucket sort和radix sort可以对n个元素进行排序，合适的关键字取值使得时间复杂度为*O*(n)，相比于第2章的各类时间复杂度为*O*(n^2)的排序方法快。并查集问题说明了如何将整数作为指针建立链表的方法。

### 6.1 单向链表

​	对于一个线性表(e0,e1,..ei,..,en-1)，每个元素ei都是一个节点，每个节点(元素)都有一个链域(指针)，链域的值(指针解引用)指向了下一个节点(元素)。首个元素e0的节点是FirstNode(指向e1)，尾元素en-1的节点指向了NULL

​	何谓单向链表？链表从左到右每一个节点都链接下一个节点，最后一个节点的链域值为NULL，每个节点只有1个链条。

​	重点的函数是erase和insert的实现。

​	erase操作就是断开index所在的节点与前后节点之间的联系，即index-1的节点链域值是index+1，此时index的节点与链条没有任何关系，即使该节点链域值依然是index+1。

​	insert的操作就是让index-1的节点链域值指向这个元素的节点index，这个元素节点的链域值再指向index+1，即实现插入操作

#### 6.1.2 结构chainNode

​	为了使用链表描述线性表，需要定义一个结构chainNode，内部成员有2个。一个是element存储了当前节点的元素值(数据域)；一个是next指向下一个节点的指针(链域)；需要说明的next的指针类型就是chainNode*，自然指针也是2个成员，但不是指向本身，而是下一个chainNode。

​	也就是每个节点的数据类型都是chainNode，内部只有element和next两个成员，特别的最后一个节点next=NULL。

​	结构体还有3个方法，用于改变节点的数据域或者链域。

```c++
template<class T>
struct _charter6_chainNode
{
	// 成员,数据域和链域
	T element;
	_charter6_chainNode<T>* next;

	// 方法
	_charter6_chainNode() {}
	// 只改变节点的数据域(元素值)
	_charter6_chainNode(const T& element) 
	{
		this->element = element
	} // 节点的元素值改变时改变成员element的值
	// 只改变节点的链域(指向的下一个元素地址)也是可以的
	_charter6_chainNode(_charter6_chainNode<T>* next)
	{
		this->next = next;
	}
	// 同时改变节点数据与和链域
	_charter6_chainNode(const T& element, _charter6_chainNode<T>* next)
	{
		this->element = element;
		this->next = next;
	}

};
```

#### 6.1.3 chainNode的测试代码

```c++
void _charter6_chainNode_testCode()
{
	// (默认构造是没有参数)
	_charter6_chainNode<int> node1 ,node2 ,node3 , node4;
	vector<_charter6_chainNode<int>> chain = {&node1,&node2,&node3,&node4};
	cout << "每个节点的next地址和element大小初始化为：" << endl;
	for (int i = 0; i < chain.size(); i++)
	{
		chain[i].element = i + 1;
		chain[i].next = &chain[i]; // 把每个节点next指针先指向自身初始化
		cout << "node[" << i+1 << "].element  =  " << chain[i].element << endl;
		cout << "node["<<i+1<<"].next  =>  " << chain[i].next << endl;
	}
	cout << "更改后每个节点的next地址和element大小变为：" << endl;
	for (size_t i = 0; i < chain.size(); i++)
	{
		if (i < chain.size() - 1)
			chain[i].next = chain[(unsigned __int64)i + 1].next; // 把指向更改
		else
			chain[i].next = NULL;
		cout << "node[" << i+1 << "].element  =  " << chain[i].element << endl;
		cout << "node[" << i+1 << "].next  =>  " << chain[i].next << endl;
	}
	// 但是node1-node4本身没有改变
	cout << "node1.element = " << node1.element << "   node1.next => " << node1.next<< endl;
	cout << "node2.element = " << node2.element << "   node2.next => " << node2.next << endl;
	cout << "node3.element = " << node3.element << "   node3.next => " << node3.next << endl;
	cout << "node4.element = " << node4.element << "   node4.next => " << node4.next << endl;
	node1.element = 1; node2.element = 2; node3.element = 3; node4.element = 4;
	node1.next = &node2; node2.next = &node3; node3.next = &node4; node4.next = NULL;
	cout << "&node1 => " << &node1 << "   &node2 =>" << &node2 
		<< "   &node3 =>" << &node3 << "   &node4 =>" << &node4 << endl;
	cout << "node1.next = > " << node1.next << endl;//node1=>node2
	cout << "node1.next->next =>  " << node1.next->next << endl;//node2=>node3
	cout << "node1.next->next->next =>  " << node1.next->next->next << endl;//node3=>node4
	cout << "node1.next->next->next->next =>  " << node1.next->next->next->next << endl;// node4=>NULL
	
	// 从以上结果来看更能体会next指针的作用
	// next指向下一个节点时再次调用next就会到下下个节点的地址
	
	// 测试其余3种构造方法(默认构造是没有参数)
	_charter6_chainNode<int> node5(node1.element) ;
	cout << "使用node5(node1.element)进行构造,此时node5.element = "
		<< node5.element << "  with node5.next  => " << node5.next << endl;
	_charter6_chainNode<int> node6(6);
	cout << "使用node6(6)进行构造,此时node6.element = "
		<< node6.element << "  with node6.next  => " << node6.next << endl;
	_charter6_chainNode<int> node7(7,&node6);
	cout << "使用node7(7,&node6)进行构造,此时node7.element = "
		<< node7.element << "  with node7.next  => " << node7.next 
		<<"  &node6 => "<<&node6<< endl;
	_charter6_chainNode<int> node8(&node7);
	cout << "使用node8(&node7)进行构造,此时node8.element = "
		<< node8.element << "  with node8.next  => " << node8.next
		<< "  &node7 => " << &node7 << endl;

	// 测试new方法
	// 可以看出new必须使用节点类型的指针接收
	_charter6_chainNode<int> *pnode9 = new _charter6_chainNode<int>(9, &node8);
	cout << "使用new _charter6_chainNode<int>(9, &node8)进行构造,\n此时pnode9->element = "
		<< pnode9->element << "  with pnode9->next  => " << pnode9->next
		<< "  &node8 => " << &node8 << endl;
	// 其实这个类型和任意节点实例的next指针是一个类型
	node5.next = pnode9;
	cout << "访问node5.next的next和element就是在访问pnode9的next和element" << endl;
	cout << "node5.next->element = " << node5.next->element << "   node5.next->next = " << node5.next->next << endl;
	cout << "node5.next的地址就是pnode9的地址,但node5自身的element不会改变,根据上边程序已经初始化为1" << endl;
	cout << "node5.element = "<< node5.element<<"   node5.next = "<<node5.next << "   pnode9 = " << pnode9 << endl;
}
```

#### 6.1.4 单向链表的声明与实现

##### 6.1.4.1 声明

​		内部的迭代器类整个要作为成员，因为使用_ charter6_chainList :: _charter6_iterator it = .begin();it !=.end();it++时要实例化迭代器it，所以类要整个定义和实现都在内部；

​		其次自定义的迭代器类是一种数据类型，它不能实现++和--算术操作，也不能进行!=和==的逻辑运算，由于想要获得解引用后的数值，还有迭代器的实例解引用符号 * 以及迭代器指针的箭头访问符->运算都需要自己定义，所以还需运算符重载。特别的++分前+和后+，后+需要引入重载参数(int)。

```c++
#include "charter5_linearList.h"
#include "charter6_chainNode.h"
#include "myExceptions.h"
#include <sstream>
#include <ostream>
#include <iterator>
template <class T>
class _charter6_chainListWithIterator : public _charter5_linearList<T>
{
public:
	_charter6_chainListWithIterator(int initialCapacity = 10);
	_charter6_chainListWithIterator(const _charter6_chainListWithIterator<T>& theList);
	~_charter6_chainListWithIterator();
	bool empty() const { return listSize == 0; }
	int size() const { return listSize; }
	T& get(int theIndex) const;
	int indexOf(const T& theElement) const;
	void erase(int theIndex);
	void insert(int theIndex, const T& theElement);
	void output(std::ostream& out) const;

	// 类作为成员是因为链表类使用迭代器时需要迭代器的实例
	class _charter6_iterator;
	// 链表类的2个方法返回的是迭代器类的实例,分别指向了链表类实例的开头和结尾
	_charter6_iterator begin() { return _charter6_iterator(firstNode); }
	_charter6_iterator end() { return _charter6_iterator(NULL); }
    class _charter6_iterator
    {
    public:
        typedef std::forward_iterator_tag iterator_category;
        typedef T value_type;
        typedef std::ptrdiff_t difference_type;
        typedef T* pointer;
        typedef T& reference;
		_charter6_iterator(_charter6_chainNode<T>* theNode = NULL)
        {
			// 迭代器只有1种实例化方法,begin/end就是调用此构造指向链表类的两端
            node = theNode; 
        }

        // 因为迭代器有2个成员,解引用需要重载
		//  *it = *node = node->element
        T& operator*() const { return node->element; }// node就是it , 返回*it
		// node就是it ,如果有pnode = &node,pnode->element<=>&node->element,->需要重载
        T* operator->() const { return &node->element; } //等价于为 &it->element

		_charter6_iterator& operator++()   
        {
            node = node->next; return *this; //表达式已经改变,node就是it相当于返回++it
        }
		_charter6_iterator operator++(int) // 表达式值没改变,返回的还是旧值
        {
			_charter6_iterator old = *this;
            node = node->next;
            return old; // ,node就是it相当于返回it++
        }

		// 节点之间是否相等比较的是它们的地址是否相等需要重载
        bool operator!=(const _charter6_iterator right) const
        {
            return node != right.node; // 用于it != chain.begin() node就是it
        }
        bool operator==(const _charter6_iterator right) const
        {
            return node == right.node; // node就是it
        }
    protected:
		_charter6_chainNode<T>* node; // 迭代器实例化自带的节点指针
    };  

protected:
	int listSize;
	_charter6_chainNode<T>* firstNode; 
	void checkIndex(int theIndex) const;
};
```

##### 6.1.4.2 实现	

​		只说明核心操作erase和insert的实现，其它参见代码文件<charter6_chainList.h>

​		两个函数都有2个关键需要理解。

​		对于insert函数：

​		第一个是插入到头节点之前和插入到theIndex节点是不同的操作。1.如果是插入到头节点之前,只需构建一个包含原来的头节点信息的新节点即可，即_charter6_chainNode<T>(theElement, firstNode)，节点一经构建就包含了第2个节点的信息，只需要使用firstNode重新指向新创建的节点即可；2.如果是插入到theIndex的位置，为了找到这个位置，需要一个头节点的指针进行遍历，遍历到theIndex-1的位置，因为它包含了指向theIndex节点的信息p->next，让其指向新创建的节点即可(这个节点是以theIndex节点的信息(恰好也是p->next)构建的)，关键代码就是p->next= new _charter6_chainNode<T>(theElement, p->next)，只是便于理解使用了中间变量theIndexNode。

​		对于erase函数：

​		1.清除头节点很简单，只需要用一个deleteNode记录头节点的信息,再把firstNode指向它的下一个节点也就是firstNode->next即可；2.如果是删除theIndex的节点，也需要定义头结点指针进行遍历到theIndex-1的节点(p)，然后断开theIndex-1和theIndex(p->next)的联系，直接接到theIndex+1即可(p->next->next)，deleteNode要实现记录好theIndex节点的位置(p->next)，最后delete即可。

```c++
template<class T>
void _charter6_chainList<T>::erase(int theIndex)
{
	checkIndex(theIndex);
	_charter6_chainNode<T>* deleteNode; // 创建1个局部指针
	if (theIndex == 0)
	{
		// 删除头节点只需要让firstNode指向下1个节点,这个节点的地址是firstNode->next
		deleteNode = firstNode;// 原来的头节点地址在最后会被delete
		firstNode = firstNode->next;//头节点指针信息更新为原来头节点指向的下1个即firstNode->next
	}
	else
	{  
		_charter6_chainNode<T>* p = firstNode;
		for (int i = 0; i < theIndex - 1; i++)
			p = p->next;
		// 此时p到达index-1的位置
		deleteNode = p->next; // 删除的index节点的地址信息在index-1,所以使用p->next
		p->next = p->next->next; // 把当前index-1的指针指向到index+1,即p->next->next(记录在index的指针)
	}
	listSize--;
	delete deleteNode; // 删除地址是真正的删除
}

template<class T>
void _charter6_chainList<T>::insert(int theIndex, const T& theElement)
{
	if (theIndex < 0 || theIndex > listSize)
	{// invalid index
		ostringstream s;
		s << "index = " << theIndex << " size = " << listSize;
		throw illegalIndex(s.str());
	}

	if (theIndex == 0)// 如果在头节点之前插入节点,让新创建的节点指向原来的头节点即可
	{
		// 1.使用1个指针指向用原来头节点信息创建的新节点
		// newfirstNode必须用指针接收,和firstNode就是一类指针
		_charter6_chainNode<T> *newfirstNode = new _charter6_chainNode<T>(theElement, firstNode);
		// 2.把现在的头节点指向原来的头节点,数据域和链域信息都保留
		this->firstNode = newfirstNode;//更新头节点
		// 3.以前的头节点不影响指向的下一个节点,无需更新,插入执行完毕
	}
	else // index是要插入的节点,需要找到index-1的节点,只能借助一个指向头节点的指针遍历查找
	{  
		_charter6_chainNode<T>* p = firstNode;//一个指向自身头节点的指针
		for (int i = 0; i < theIndex - 1; i++)//移动index-1次就到达前1个节点的地址
			p = p->next; // 等价于p->next->next->next->...->next(index-1个next) 

		// 这里只执行了index-1次,此时p指向的是第index-1个节点,它的再下一个才是index节点
		// 1.创建1个新节点保留index节点的信息(在p->next中),要以(theElement, p->next)方式创建
		_charter6_chainNode<T> * theIndexNode = new _charter6_chainNode<T>(theElement, p->next); // 创建节点就要使用new
		// 2.要把index-1的指针信息(p->next)指向当前新创建的节点
		p->next = theIndexNode;
		// 3.theIndexNode创建时就有了原来index节点的信息了,无需更改后续
	}
	listSize++; // 成员+1
}
```

#### 6.1.5 单向链表的拓展

​		拓展的函数只有push_back和clear函数，额外的定义了一个指向尾节点的指针lastNode，由于insert和erase函数可能会影响lastNode的指向，所以这两个函数进行重写更新。

​		拓展需要一个抽象类，只不过这个抽象类继承了线性表的抽象类linearList，是一个拓展，其声明如下。

```c++
#include "charter5_linearList.h"
template<class T>
class _charter6_linearListExtend : public _charter5_linearList<T>
{
public:
	virtual ~_charter6_linearListExtend() {}
	virtual void clear() = 0; 
	virtual void push_back(const T& theElement) = 0;
};
```

​		然后就是拓展抽象类的具体类实现，借助上述继承已经实现的单向链表和这个定义的拓展抽象类即可。

##### 6.1.5.1 声明

​		继承分为几部分来说。

​		1.继承父类构造函数：定义自己的构造时可以直接继承父类的构造函数，只需要加个冒号，进行参数传递即可

​		2.继承父类方法：如果父类的方法和子类方法不同名，或者说子类没有父类同名函数的重写，则可以直接继承，必须显示的使用this->进行访问，否则报错该成员不存在，如程序的checkIndex函数、_charter6_iterator类成员、普通变量listSize和firstNode以及重载<<的函数；如果子类存在同名函数，this->调用的不再是父类的方法，而是自身，如果不想重写，则需要父类的作用域函数调用，传递参数即可

​		3.继承父类的变量：如果子类没有定义新的listSize,firstNode就可以使用this->调用父类的2个成员

​		以上的所有前提建立在public继承。关于继承方式有很重要的说明，继承方式的关系如下图所示。

![父类成员的继承问题](C:\Users\chenb\Desktop\2021.12.30备份\代码汇总\markdown文件\父类成员的继承问题.jpg)

```c++
#include "charter6_chainNode.h"
#include "charter6_linearListExtend.h" // 继承拓展
#include "charter6_chainListWithIterator.h" // 借助已经实现的chain修改2个函数和增加成员即可
template<class T>
class _charter6_chainListWithIteratorExtend : public _charter6_chainListWithIterator<T>, _charter6_linearListExtend<T>
{
public:
    // 构造函数不同于普通方法,需要继承_charter6_chainListWithIterator
    // 注意如何继承的形参,前后需要一致
    _charter6_chainListWithIteratorExtend(int initialCapacity = 10)  : 
        _charter6_chainListWithIterator<T>(initialCapacity) {} 
    _charter6_chainListWithIteratorExtend(const _charter6_chainListWithIteratorExtend<T>& theList) : 
        _charter6_chainListWithIterator<T>(theList) {}
    
    // 子类继承父类的同名函数会被覆盖,empty,size,get,indexOf,output都会被覆盖,this->无法调用父类
    // 构造函数、没有覆盖的方法checkIndex、<<重载，没有覆盖的类_charter6_iterator，普通成员firstNode、listSize都直接继承可被this调用
    // 如果想重写函数,erase,insert直接重写即可
    // 如果不想重写函数直接使用父类的方法,需要 class :: method的格式调用父类方法
    bool empty() const { return this->listSize == 0; }// 使用继承,自己写this->empy()是错误的,但是可以使用return this->listSize == 0和_charter6_chainListWithIterator<T>::empty();
    int size() const { return this->listSize; } // 自己写的话要记得返回this->listSize而不是listSize否则报错不识别 ,也可以return _charter6_chainListWithIterator<T>::listSize; 
    T& get(int theIndex) const
    {
        return _charter6_chainListWithIterator<T>::get(theIndex); // 使用继承调用方法
    }
    int indexOf(const T& theElement) const
    {
        return _charter6_chainListWithIterator<T>::indexOf(theElement);
    }
    void output(ostream& out) const
    {
        _charter6_chainListWithIterator<T>::output(out);
    }
    void clear()
    {
        // 和析构函数的代码一样
        while (this->firstNode != NULL)
        {
            _charter6_chainNode<T>* nextNode = this->firstNode->next;
            delete this->firstNode;
            this->firstNode = nextNode;
        }
        this->listSize = 0;
    }   // 需要实现
    void erase(int theIndex); // 重新实现
    void insert(int theIndex, const T& theElement); // 重新实现
    void push_back(const T& theElement);
    void zero()
    {
        this->firstNode = NULL; this->listSize = 0;
    }
protected:
    _charter6_chainNode<T>* lastNode;  // 尾节点指针
};
```

##### 6.1.5.2 实现

​		只说明关于erase和insert的重写以及push_back和clear函数的实现。

​		对于erase。如果删除的不是尾节点，原来的尾节点在创建时(insert或push_back)就实现了lastNode指向它，现在依然是尾节点，所以无需任何操作；如果删除的是尾节点，p是前1个节点变成尾节点，那么让lastNode指向p即可。

```c++
template<class T>
void _charter6_chainListWithIteratorExtend<T>::erase(int theIndex)
{
    this->checkIndex(theIndex); // 调用的是继承的方法
    _charter6_chainNode<T>* deleteNode;
    if (theIndex == 0)
    {
        deleteNode = this->firstNode;
        this->firstNode = this->firstNode->next;
    }
    else
    {  
        _charter6_chainNode<T>* p = this->firstNode;
        for (int i = 0; i < theIndex - 1; i++)
            p = p->next;

        deleteNode = p->next;
        p->next = p->next->next; 
        if (deleteNode == lastNode) // 增加的代码修改:如果index删除的是尾节点需要更新否则不需要
            lastNode = p; // 说明现在的p(index-1)是尾节点了,更新即可
    }
    this->listSize--;
    delete deleteNode;
}

```

​		对于insert。如果一开始是空的，创建好头节点后，尾节点就是头节点已经固定指向该节点；如果不是空的但是插入的位置是开头位置，那么头节点变成第2个节点，但还是尾节点所以无需任何操作；如果不是空的且插入的位置是头节点到尾节点之间的任意位置，也不会影响原来的尾节点；theIndex最多取到listSize-1，如果插入在尾节点的后1个位置说明theIndex取值为listSize,那么p->next一共执行了listSize-1次，也就是指向了以前的尾节点，然后p绑定的信息就是listSize位置的节点(p->next)，那就让p->next等于lastNode即可。

```c++
// insert函数重新实现
template<class T>
void _charter6_chainListWithIteratorExtend<T>::insert(int theIndex, const T& theElement)
{
    if (theIndex < 0 || theIndex > this->listSize)
    {
        ostringstream s;
        s << "index = " << theIndex << " size = " << this->listSize;
        throw illegalIndex(s.str());
    }

    if (theIndex == 0)
    {
        this->firstNode = new _charter6_chainNode<T>(theElement, this->firstNode);
        // 和erase不同,清除的不是尾节点就不影响,insert一定会影响尾节点
        if (this->listSize == 0)
            lastNode = this->firstNode; // 如果一开始没有节点,插入的节点既是头节点也是尾节点
        // 如果一开始有头节点,且插入的节点在头节点之前,没有影响
        // 因为插入第2个元素必定已经插入了第1个元素,那时候lastNode就已经指向了头节点(也就是现在的第2个节点)
    }
    else
    { // 如果一开始有头节点,但是插入的节点是在头节点之后,就会有影响
        // 因为尾节点不是以前的头节点了,而是新创建的节点
        _charter6_chainNode<T>* p = this->firstNode;
        for (int i = 0; i < theIndex - 1; i++)
            p = p->next;
        p->next = new _charter6_chainNode<T>(theElement, p->next);//新创建的index节点的信息在上1个index-1(p)存储，如果是尾插theIndex=listSize，p执行了listSize-1次,p绑定的信息就是listSize位置的节点
        if (this->listSize == theIndex)//如果节点不是尾插,尾节点本身没有改变没有影响 lastNode依然指向了原本的尾节点
            lastNode = p->next; // 如果是尾插,说明p是新的尾节点的上一个(theIndex=listSize-1位置),p->next就是尾节点地址(theIndex=listSize位置)
    }
    this->listSize++;
}
```

### 6.2 单向循环链表

​		单向循环链表定义了一个头节点headNode，这个头节点是真实的头节点，初始化是自己，不同于firstNode他总是指向头插的新节点，但是总的节点数并没有多。

​		对于单向链表firstNode初始化指向NULL，第1次头插会以firstNode本身构建新节点，也就是更新firstNode让它等于构建的新节点，程序是指针赋值操作，它们是1个东西

​		第2次头插还是用firstNode构建,只是此时它不指向NULL了而是之前创建的新节点,再次更新firstNode等于现在新构建的节点,依然是一个东西，所以整个链表并没多出1个节点。
​		如果不是头插，p指针总是运行到插入位置的上一个，并用p->next信息构建新节点，同时更新当前的p指向这个新节点，firstNode不会有任何影响

​		循环链表的headerNone和firstNode不是一个含义，headerNone是一个独立的东西(初始化指向自己),整个链表确实多了1个节点
​		如果是头插不会执行for遍历。第1次头插让headNode指向创建的头插节点(这个节点是用headNode->next构建的,此时它还是指向自身)；第2次头插headNode指向新创建的头插节点(这个节点是用headNode->next构建的,此时它已经指向前1个创建的节点) heardNode->n1->n0->headNode，以此类推最后1个头插的也是指向headNode
​		如果不是头插,插入的位置是index则for循环会执行index次，但是依然到达的是index的上一个节点位置，为什么呢？因为headNode是真的1个节点,p指向headNode的,所以执行index次还没到达index节点
​		之后就简单了,用p->next构建index节点(已保留原有信息)，再让p指向这个新构建的节点(让index-1的节点指向index)；特别的如果取到了listSize,p就是listSize-1的节点(尾节点),p->next在一开始头插的时候已经指回了headNode,所以使用p->next构建的新节点作为尾节点依然指回headNode，还是循环链表

#### 6.2.1 声明

​		headerNode是1个节点，整个链表的节点个数是listSize+1

```c++
template<class T>
class _charter6_chainListCircular
{
public:
    _charter6_chainListCircular();
    int size() const { return listSize; }
    int indexOf(const T& theElement) const;
    void insert(int theIndex, const T& theElement);
    void output(ostream& out) const;

protected:
    void checkIndex(int theIndex) const;
    _charter6_chainNode<T>* headerNode;  // 头节点,就是firstNode
    int listSize;            
};
```

#### 6.2.2 实现

​		因为insert和indexof受到headNode的影响，这里重写

​		插入函数实现：

```c++
template<class T>
void _charter6_chainListCircular<T>::insert(int theIndex, const T& theElement)
{
    if (theIndex < 0 || theIndex > listSize)
    {
        ostringstream s;
        s << "index = " << theIndex << " size = " << listSize;
        throw illegalIndex(s.str());
    }
    _charter6_chainNode<T>* p = headerNode; // 头节点的指针是真实的头节点,和首节点不相等
    for (int i = 0; i < theIndex; i++)
        p = p->next; 
    p->next = new _charter6_chainNode<T>(theElement, p->next); 
    listSize++;
}
```

​		索引函数实现：唯一的区别就是不需要再判断currentNode是否为NULL空地址,都不是空的，只是最后一个指向空节点。下边这个函数while的循环从index=0开始一直到listSize还是进入判断的,listSize的时候currentNode已经是headNode了，它们是相等的所以循环退出。

```c++
template<class T>
int _charter6_chainListCircular<T>::indexOf(const T& theElement) const
{
    headerNode->element = theElement; // 把查找的元素赋值给头节点的元素

    _charter6_chainNode<T>* currentNode = headerNode->next; // 注意指针指向的不是头节点而是首节点
    int index = 0;  
    while (currentNode->element != theElement)//无需再比较currentNode!=NULL 只比较元素,从首节点开始判断的
    {
        currentNode = currentNode->next; // index如果到达了listSize-1判断不等,下一个是listSize
        index++; // 此时currentNode = headerNone还是可以继续判断的,且headerNone已经赋值就是theElement,发现相等后退出循环
    }

    if (currentNode == headerNode) // 只需要判断是否又回到头节点即可 while退出循环时必定是headerNone
        return -1;
    else
        return index;
}
```

### 6.3 双向链表

​		结合了单向链表的拓展尾节点lastNode和首节点firstNode

​		双向链表有2个指针，next和previous，所以需要重定义chainNode结构体。尾节点的next指向NULL，首节点的previous也指向NULL。注意，首节点firstNode和尾节点lastNode不是实体节点，它们和只和位置有关，即链表首位就是首节点，末位就是尾节点，没有创造新的节点。

### 6.4 双向循环链表

​		类似于单向链表加上1个头节点headNode成为单向循环链表，双向链表也可以加上头节点。那么在一个非空的双向循环链表firstNode.previous是一个指向最右端节点的指针，lastNode.next是一个指向最左端节点的指针，此时可以省略变量lastNode和firstNode只用1个变量(即头节点)来跟踪链表

### 6.5总结

1. 单向链表x，当且仅当x.firstNode=NULL时为空表(构造函数的初始化指向NULL)；如果x非空，则firstNode指向链表第一个节点(敲黑板！没有新增节点)，且总是指向。之后上一个节点总是指向下一个节点，尾节点指向NULL。
2. 单向循环链表x，与单向链表唯一的区别就是最后1个节点反过来指向第1个节点，这步是通过头节点headNode实现的。当表为空时，x.firstNode=NULL，但是x.headNode指向自己。有了头节点，空表不必再作为特殊情况进行处理，程序变得简单。
3. 双向链表x，双向链表的节点从左至右按序排列。节点的指针域next把节点从左到右链接到一起，尾节点next指向NULL；节点的指针域previous把节点从右到左链接到仪器，首节点previous指向NULL。
4. 双向循环链表x，唯一区别是尾节点的next不指向NULL，而是指向首节点；同理首节点的previous也不指向NULL，而是指向尾节点。

### 6.6 应用

### 6.6.1 箱子排序

​		箱子排序利用链表对特定的结构体数据类型进行排序，首先需要定义一个排序场景，以下方的studentRecord结构体为例说明。

##### 6.6.1.2 studentRecord结构体

​		先定义一个简单的结构体，这个结构体有2个成员，名字和分数。为了方便，名字只有1个字母，测试代码中使用了10个学生，名字从A、B、C一直到J；分数只有6档，即0-5分，不同的分进入不同的箱子。

​		测试场景如下：

​		[A] [2]-> [B] [4]->[C] [5]->[D] [4]->[E] [3]->[F] [0]->[G] [4]->[H] [3]->[I] [4]->[J] [3]

​		6个箱子应当是：

​		bin0：[F] [0]

​		bin1：

​		bin2：[A] [2]

​		bin3：[E] [3]、[H] [3]、[J] [3]

​		bin4：[B] [4]、D] [4]、[G] [4]、[I] [4]

​		bin5：[C] [5]

​		声明程序有3种方式。

​		第一种，使用 !=运算符重载，将studentRecord的!= 运算转为比较它们的score运算。同时为了方便打印输出这种结构体，还重载了输出流 <<运算符，这个后边2种都是一样的。

```c++
struct _charter6_studentRecord1
{
    int score;
    std::string* name;

    int operator !=(_charter6_studentRecord1 x) const
    {
        return (score != x.score); // 重载!=运算
    }
};
std::ostream& operator<<(std::ostream& out, const _charter6_studentRecord1& x)
{
    out << "score = "<<x.score << "  name = " << *x.name << std::endl; return out;
}
```

​		第二种，使用int()重载，强制转换是返回分数，而分数是整型，任何逻辑运算都可以使用，例如==,+,/,>=,!=等等，比第一种定义方式更具有普遍性。

```c++
struct _charter6_studentRecord2
{
    int score;
    std::string* name;
    operator int() const { return score; }// 重载类型转换
};
std::ostream& operator<<(std::ostream& out, const _charter6_studentRecord2& x)
{
    out << "score = " << x.score << "  name = " << *x.name << std::endl; return out;
}
```

​		第三种，结合2种方式。强制转换可以执行各种操作，但是不能执行!=和<<，因为这2种已经被重定义加强。!=要求名字和分数符合一个不等就行，<<也是被加强重载输出。

```c++
struct _charter6_studentRecord
{
    int score;
    std::string* name;

    int operator !=(_charter6_studentRecord x) const
    {
        return (score != x.score || name != x.name); // 名字或者分数不等都是不等
    }
    operator int() const { return score; } // int()只能在操作符!=和<<以外操作中使用
};
std::ostream& operator<<(std::ostream& out, const _charter6_studentRecord& x)
{
    out << "score = " << x.score << "  name = " << *x.name << std::endl; return out;
}
```

##### 6.6.1.3 binSort排序作为独立函数实现

​		需要多个箱子，箱子的个数取决于range的大小，range是分数档位数(不包含0)，箱子数组的容量总是range+1，因为还有0挡位。多个箱子需要这样的箱子数组，也就是链条数组，需要new来分配内存最后delete[]即可。

```c++
void _charter6_studentRecord_binsort(_charter6_chainListWithIterator<_charter6_studentRecord1>& theChain, int range)
{
	// 传入的是1个学生分数类型的链表,range是分数的档位数或者说链表大小
	typedef _charter6_chainListWithIterator<_charter6_studentRecord1> chain; // 名字太长取个别名
	typedef  _charter6_studentRecord1 stu; // 别名只在局部域内有效
	chain* bin; // 每个箱子都是1个链表,一个指向箱子数组地址的指针
	
	// 唯一可能运行失败的语句,因为内存可能分配不足
	bin = new chain[range+1]; // new 1个箱子数组,容量是range+1,与score相同,设想场景为0,1,2,3,4,5
	
	int size = theChain.size(); // 不写在for循环中,因为theChain.size()动态的变短
	// 为何执行size次,因为有size个元素,每次都取出1个
	for (int i = 1; i <=size ; i++) // 从链表的第1个学生开始,时间复杂度Θ(n)
	{
		stu x = theChain.get(0); // 拿到第0个学生的信息 Θ(1)
		theChain.erase(0); // 把传入的链表第0个学生擦去 Θ(1)
		// =>反复执行总是得到链表的第0个学生,且链表越来越短 
		bin[x.score].insert(0, x);//把拿到的学生信息根据分数插入到箱子数组的不同链表中 Θ(1)

		// 此时完成好了不同分数学生的分级
		// 接下来只需要循环取出来给到新链表即可
	}

	// 从箱子收集学生信息
	for (int j = range; j >= 0; j--) // j=5,4,3,2,1,0,依次从不同箱子取出元素,时间复杂度Θ(n+range)
	{
		while (!bin[j].empty()) // 箱子取1个就要擦掉1个,所以判断条件就是不为空就执行while
		{
			stu x = bin[j].get(0);// 拿到j箱子的首个学生 Θ(1)
			bin[j].erase(0);// j箱子擦掉 Θ(1)
			theChain.insert(0, x); // theChain是个链表引用,还是可以继续头插的,尾插还要指定索引所以头插 Θ(1)
		}// 因为j从高分遍历,但是是头插,所以高分排在后面,这样就是升序了
	}
	delete[] bin; // 箱子是数组 new 和delete必须配套
}
```

##### 6.6.1.4 binSort排序作为成员函数实现

​		如果把上述的函数定义为链表的独立成员函数，可以省略很多操作。因为每个箱子是个链条，并没有成员，每插入1个学生都要new操作，erase也是要进行delete操作。如果作为成员函数使用theChain.binSort(10)即可，而不用使用binSort(theChain,10)，即先擦去再插入，可以直接对theChain调整顺序即可。

​		那么首先需要定义一个包含箱子排序方法的链表类，其声明如下。

```c++
template<class T>
class _charter6_chainBinSort : public _charter5_linearList<T>
{
public:
    _charter6_chainBinSort(int initialCapacity = 10);
    _charter6_chainBinSort(const _charter6_chainBinSort<T>&);
    ~_charter6_chainBinSort();

    bool empty() const { return listSize == 0; }
    int size() const { return listSize; }
    T& get(int theIndex) const;
    int indexOf(const T& theElement) const;
    void erase(int theIndex);
    void insert(int theIndex, const T& theElement);
    void output(ostream& out) const;
    void binSort(int range);
    void binSort(int range, int(*value)(T& x));
protected:
    void checkIndex(int theIndex) const;
    _charter6_chainNode<T>* firstNode;
    int listSize;        
};
```

​		实现只说明2个箱子排序，其它完全一样。

```c++

```

