## 概述

​		与普通的队列不同，优先级队列元素出队列的顺序由优先级确定，可以按照优先级的递增也可以递减来出队列，但是不按照元素进入队列的顺序。

​		实现优先级队列通过堆实现，**<u>堆是一颗完全二叉树</u>**，用数组描述的堆效率最高；

​		链表结构描述的左高树也可以表示优先级队列；

​		此外还有配对堆、双端优先级队列，均可以在本书网站找到。C++的STL类priority-queue便是用堆实现的优先级队列。

​		堆的概念可以引出堆排序，其时间复杂度为O(nlogn)，第2章的计数排序、选择排序、冒泡排序、插入排序时间复杂度都是O(n^2)，第6章的基数排序、箱子排序是O(n)，不过这两类排序要求元素的取值限制在合适的范围，通用性不高。

​		堆排序是迄今为止，第一种通用性排序算法，可以证明，任何依赖**<u>成对元素</u>**比较的通用排序算法都具备O(nlogn)时间复杂度。

​		优先级队列是0个或多个元素的集合，每个元素都有一个优先权值，主要的操作有查找1个元素，插入1个元素和删除1个元素，对应top、push和pop函数。

​		最小优先级队列，查找和删除的元素都是优先级最小的元素，最大优先级队列查找和删除的元素是优先级最大的元素。元素允许有相同的优先级，这样的元素查找和删除可以按照任意顺序进行处理。

​		优先级队列的应用例子：

​		如果一台机器每次提供某种服务的收费是相同的，不同用户花费的时间不同，便可以将用户的时间按照最小优先级队列进行排队，即花费时间最少的优先提供服务以取得收益最大化；或者机器每次提供服务的时间相同，但是收费不同，那么花费最多的客户优先，这就是最大优先级队列。

​		STL中的类priority_queue使用了基于向量的堆来实现大根堆，它允许用户自定义优先级的比较函数，因此这个类也可以实现小根堆。

## 12.1 抽象数据类型

### 12.1.1 最大优先级队列

​		语言描述如下。

```c++
抽象数据类型 maxPriorityQueue
{
    实例
        有限个元素集合，每个元素都有优先级
    操作
        empty()：队列为空返回true
        size()：返回队列元素个数
        top()：返回优先级最大元素
        pop()：删除优先级最大元素
        push(x)：插入元素x
}
```

​		C++代码实现如下。

```c++
template<class T>
class abstractMaxPriorityQueue
{
public:
    virtual ~abstractMaxPriorityQueue() {}
    virtual bool empty() const = 0;
    virtual int size() const = 0;
    virtual const T& top() = 0;
    virtual void pop() = 0;
    virtual void push(const T& theElement) = 0;
};
```

### 12.1.2 最小优先级队列

​		语言描述如下。

```c++
抽象数据类型 maxPriorityQueue
{
    实例
        有限个元素集合，每个元素都有优先级
    操作
        empty()：队列为空返回true
        size()：返回队列元素个数
        top()：返回优先级最小元素
        pop()：删除优先级最小元素
        push(x)：插入元素x
}
```

​		C++代码实现如下。

```c++
template<class T>
class abstractMinPriorityQueue
{
public:
    virtual ~minPriorityQueue() {}
    virtual bool empty() const = 0;
    virtual int size() const = 0;
    virtual const T& top() = 0;
    virtual void pop() = 0;
    virtual void push(const T& theElement) = 0;
};
```

## 12.2 无序数组实现的最大优先级队列

​			最大最小思路是差不多的，这里只给出最大优先级队列的无序数组实现。

​			无序数组的实现，插入操作时间复杂度O(1)，即queue[queueSize]=element，但是删除操作为O(n)。首先要找到权重最大的那个元素，然后返回这个元素在该数组的索引，然后使用copy操作复制index前后的两段数据。

​			有序数组的实现，删除变得容易，因为删除queue[queueSize]即可，插入操作为O(n)，需要找到合适的索引位置，然后插入。

	### 12.2.1 声明

​			C++声明如下，有几个自定义的函数，outputByWeight和getCapacity()。weightNode< T >类型的数据来存储。

​			注意继承的时候要在抽象类型这里，使用weightNode< T >去继承，这样maxPriorityQueue的对象才能够插入weightNode类型的元素，以及返回这样类型的元素。

```c++
template<class T>
class maxPriorityQueue :public abstractMaxPriorityQueue<weightNode<T>>
{
public:
	maxPriorityQueue(int theCapacity);
	~maxPriorityQueue();
	bool empty() const { return queueSize == 0; }
	int size() const { return queueSize; }
	int getCapacity() const { return capacity; }
	const weightNode<T>& top();
	void pop();
	void push(const weightNode<T>& theElement);
	void outputByWeight(ostream&) const;
	friend ostream& operator<<<>(ostream& out, const maxPriorityQueue<T>&);
protected:
	int queueSize;
	int capacity;
	int getMaxWeightIndex();
	weightNode<T> * data;
};
```

### 12.2.2 实现

​		构造和析构函数。

```c++
template<class T>
maxPriorityQueue<T>::maxPriorityQueue(int theCapacity)
{
	capacity = theCapacity;
	data = new weightNode<T>[capacity];
	queueSize = 0;
}

template<class T>
maxPriorityQueue<T>::~maxPriorityQueue()
{
	if (data != NULL)
	{
		delete[] data;
		data = NULL;
		delete data;
	}
}
```

​		查找、删除和插入函数。

```c++
template<class T>
void maxPriorityQueue<T> ::push(const weightNode<T>& theElement)
{
	if (queueSize == capacity)
	{
		weightNode<T>* temp = new weightNode<T>[capacity * 2];
		copy(data, data + queueSize, temp);
		delete[] data;
		capacity *= 2;
		data = temp;
	}
	data[queueSize] = theElement;
	queueSize++;
}

template<class T>
void  maxPriorityQueue<T> ::pop()
{
	if (queueSize == 0)
		throw queueEmpty();
	weightNode<T>* temp = new weightNode<T> [capacity]; // 这里容量不要变
	int index = getMaxWeightIndex();
	copy(data, data + index, temp);
	copy(data + index + 1, data + queueSize, temp + index);
	delete[] data;
	data = temp;
	queueSize--;
}

template<class T>
const weightNode<T>& maxPriorityQueue<T> ::top()
{
	if (queueSize == 0)
		throw queueEmpty();
	return data[getMaxWeightIndex()];
}
```

​		私有函数，为了找到最大优先级元素在数组的位置。

```c++
template<class T>
int maxPriorityQueue<T> ::getMaxWeightIndex()
{
	double maxWeight = data[0].weight;
	int index = 0;
	for (int i = 1; i < queueSize; i++)
	{
		if (data[i].weight > maxWeight)
		{
			maxWeight = data[i].weight; // 如果权重一样,返回的是先入队列的那个元素
			index = i;
		}
	}
	//cout << "the index is " << index << endl;
	return index; // 返回最大权重元素所在位置
}
```

​		输出优先级队列的函数。

```c++
template<class T>
void maxPriorityQueue<T> ::outputByWeight(ostream& out) const
{
	if (queueSize == 0)
	{
		out << "the queue is empty!" ;
		return;
	}
	int count = 0;
	int* rank = new int[queueSize]; // rank用于得到名次
	for (int i = 0; i < queueSize; i++)
		rank[i] = 0; // 名次先全部初始化为0
	for (int i = 1; i < queueSize; i++)
		for (int j = 0; j < i; j++)
		{
			count++;
			if (data[j].weight <= data[i].weight) rank[i]++;
			else rank[j]++;
		} // 名次排序得到依据权重的排名
	cout << "size is " << queueSize << endl;
	weightNode<T>* temp = new weightNode<T>[queueSize]; // temp用于存放排序后的data
	for (int i = 0; i < queueSize; i++)
	{
		temp[rank[i]] = data[i]; // rank[i]是a[i]被移动的新位置
	}
	// 名次是升序的
	for (int i = queueSize-1; i >= 0; i--)
		out << temp[i]; // 从大到小输出
	delete[] temp;
}

template<class T>
ostream& operator<<<>(ostream& out, const maxPriorityQueue<T>& x)
{
	x.outputByWeight(out);
	return out;
}
```

## 12.3  堆实现的最大优先级队列

​		相比于数组，无论是有序还是无序，堆实现更加高效，所以引入堆的概念。

### 12.3.1 堆的定义

​		定义1：一颗大根树/小根树

​		大根树的每个节点的值都大于(小于)或等于其子节点(如果有子节点的话)的值。也就是说，大根树和小根树都是二叉树，只是元素是有序的。注意有序是说，父节点到子节点的路径有序，兄弟节点之间不一定有序。

​		定义2：一个大根堆/小根堆

​		在大根树和小根树的定义下，加入一个还是完全二叉树的强条件，这就要求元素必须是按照层去铺满树，不能跳跃。

​		由于是完全二叉树，所以可以将二叉树的元素映射到一维数组，使用节点在数组中的位置来表示在堆中的位置。如根的位置是1，左孩子为2，右孩子为3等等。

​		堆的高度满足完全二叉树的高度定义，即[log2(n+1)]，所以能够在O(height)时间内完成插入和删除操作，则这些操作的复杂性为O(logn)。

### 12.3.2 堆的插入、删除与初始化

​		以大根堆为例进行说明。

#### 12.3.2.1 插入

​		假如有一棵完全二叉树如(a)图所示，那么插入新元素为1、5和21的时候，其插入位置为(b)、(c)、(d)所示。

![大根堆插入操作的起泡过程.jpg](大根堆插入操作的起泡过程.jpg)

​		如果插入的元素是1，因为是完全二叉树，只需要在2的左子树创建新节点即可，按照数组编号arr[++heapSize]，因为heapSize=5，所以应当是arr[6]=1。

​		如果插入的元素是5，arr[6]=5，但是不满足大根堆的要求，所以沿着子节点到父节点直到根节点的路径，两两进行比较交换，也就是起泡过程，直到某个父节点的元素值大于新元素为止。首先arr[6]和arr[3]比较，arr[6]>arr[3]让arr[6]=arr[3]=2(这里不用让arr[3]再等于5，让它接着和arr[1]=20比)，然后再比较5和arr[1]，因为arr[1]=20>5，所以无需交换，这是再让arr[3]=5。因为大根堆沿着子-父路径已经是有序的过程，所以只需要1次起泡过程即可。

​		如果插入的元素是21，21>arr[3]=2，让arr[6]=2下移，然后21继续和arr[1]=20比，让arr[3]=20下移，此时循环结束arr[1]=21再进行赋值。

​		从以上分析可以看出，关键有2个。插入的时候，如果有必要，要拓展容量；其次，就是找到节点的父节点，然后比较，父节点编号总是子节点的编号一半，要使用整除2，从arr[++heapSize]/2开始往上每一个和新元素比较大小，满足条件才进行交换赋值，否则只是让父节点下移覆盖。

​		因为1次插入，是1个叶子到根的起泡过程，每层耗时O(1)，总耗时O(height)=O(logn)。

#### 12.3.2.2 删除

​		删除1个元素很简单，只需要heap[1].~T()即可，接下来的工作是将剩下的元素重新组织得到大根堆。注意，并不是简单的所有元素前移1个单位，映射关系会有变化，因为兄弟节点之间并不是有序的，只是父子节点有序，即不是完全的有序数组。

​		现在假如要删除(d)中的元素21。第1步heap[1].~T()；第2步用1个变量记录heap[heapSize--]，然后heap[heapSize--].~T()；第3步，选择新的根节点，只能从根节点的左右子树寻找，大的移动到根节点，即元素20移动到根节点；第4步，判断此时删除的元素能否插入到根节点子树腾出来的节点，因为删除的元素是2，可以移动到根节点的右子树，也就是编号3的位置，所以结束；如果不能插入，那么就进行第5步；第5步，比较根节点子树腾出来的节点的左右子树，找到符合条件的节点插入到这个腾出来的节点，这样就是腾出来的节点的左右子树存在空位，再判断删除的节点能否插入这个空位，相当于重复3、4步；返回执行，直到最后，必定有个位置可以插入，最坏的情况下是，所有元素都向前移动了1个编号，删除的节点插在了heap[heapSize-1]的位置。

​		因为删除的元素2，在第4步就成功了，所以最后得到的二叉树还是原来的(a)图。

​		现在假如要继续删除(a)中的元素20，目前还有5个元素。第1步删除heap[1]=20；第2步删除heap[5]=10，它被记录在临时变量；第3步，比较根节点的左右子树即15和2，则heap[1]=15；第4步，现在heap[2]空缺，比较10能否插入该空位，10有个比它大的14，所以这个空缺不能被10补入，执行第5步；找到空缺的编号也就是heap[2]的子树，即14，所以14填了原本15的位置，那么10就填入原本14的位置。

#### 12.3.2.3 初始化

​		除了通过反复push，还可以直接通过指定的优先级数组来初始化一个大根堆。直接让heap指向传递来的数组theHeap，更改heapSize为数组的元素个数(注意下标0不计入)，同时arrayLength也要更新为heapSize+1，否则会出现问题。

​		如何根据数组来映射到大根堆呢？

​		为了保证大根堆的定义，应当从最后一个具有叶子节点的根节点开始，对其子树进行检查。如果子树有大于根节点的元素，则进行交换，如果没有就不进行操作，这个过程和删除操作差不多，删除的元素应当插入哪个位置，需要先从根节点直到删除元素的根节点进行检查，然后找到合适的位置进行插入。

​		区别在于，初始化操作检查完1个根节点后，虽然它下边的子树满足了大根堆，但不意味着这些子树在其它根节点看来也是大根堆。所以进行循环，倒序循环，检查完低级的根节点再检查高级的根节点下方的子树是否是大根堆，直到全局根节点。

### 12.3.3 优先级队列maxHeap

#### 12.3.3.1 声明

​		声明如下，主要是4个函数，push、pop、initialize和top函数。

```c++
template<class T>
class maxHeap : public abstractMaxPriorityQueue<T>
{
public:
    maxHeap(int initialCapacity = 10);
    ~maxHeap();
    bool empty() const { return heapSize == 0; }
    int size() const{return heapSize;}
    int capacity() const { return arrayLength-1; } // 用户初始化的容量
    const T& top();
    void pop();
    void push(const T&);
    void initialize(T*, int);
    void deactivateArray();
    void output(ostream& out) const;
private:
    int heapSize;       // 堆节点的个数
    int arrayLength;    // 数组真实容量=初始化容量+1,因为heap[0]弃用
    T* heap;            // 存放元素的堆
};
```

#### 12.3.3.2 实现

​		push函数如下。

```c++
template<class T>
void maxHeap<T>::push(const T& theElement)
{
    if (heapSize == arrayLength - 1) // 实际用到的容量是arrayLength - 1
    { 
        
        T* temp = new T[2 * arrayLength-1];
        copy(heap, heap + arrayLength, temp); //heap[0,arrayLength)=>temp
        /*delete[] heap;*/
        heap = temp;
        arrayLength = 2 * arrayLength - 1;
        //changeLength1D(heap, arrayLength, 2 * arrayLength); // 用这个终端会输出一些错误信息不明白什么原因
        //arrayLength *= 2;
    }

    int currentNode = ++heapSize; // 插入的节点在数组的位置就是arr[++heapSize]
    while (currentNode != 1 && heap[currentNode / 2] < theElement) // 起泡过程
    {
        // 找到编号最大的1个父节点元素大于新元素即可
        // 如果父节点小于新元素heap[currentNode / 2] < theElement
        // 且父节点没到编号1根节点,就继续折半,使用&&是因为父节点不能无休止上寻
        // 且根节点元素也小于新元素,如果用或逻辑就无法退出循环了
        heap[currentNode] = heap[currentNode / 2]; // 让子节点等于父节点进行覆盖
        currentNode /= 2;                          // 父节点
    }

    heap[currentNode] = theElement; // 循环条件满足退出后才进行赋值
}
```

​		pop函数如下。

```c++
template<class T>
void maxHeap<T>::pop()
{
    if (heapSize == 0)   // heap empty
        throw queueEmpty();
    heap[1].~T(); // 第1步,最大优先级直接析构掉即可
    // 接下来的工作是将剩下的元素重新组织得到大根堆
    // 并不是简单的所有元素前移1个单位,映射关系会有变化
    // 因为兄弟节点之间并不是有序的,只是父子节点有序
    // 第2步:删除尾部元素,但是需要用变量临时记录一下
    T lastElement = heap[heapSize--];//但注意heap[heapSize]并没有删除
    heap[heapSize + 1] = NULL; // 删除其实删除不掉
    // 从根节点的左右子树开始比较
    int currentNode = 1,
        child = 2;     // 根节点的左孩子
    while (child <= heapSize) // 最后1个孩子节点是新的heapSize,也就是原来的heapSize-1
    {
        // 第3步从父(根)节点的子树选择更大的,也即是孩子可能平移到兄弟节点
        if (child < heapSize && heap[child] < heap[child + 1]) 
            // heap[2]<heap[3]=>heap[heapSize-1]<heap[heapSize]
            child++; // 例如,如果heap[2]<heap[3],说明右子树移动到父(根)节点

        // 第4步,判断删除的元素能否插入到这个空缺child的位置
        if (lastElement >= heap[child])
            break;   // yes

         // 第5步,说明此时child的子树有1个可以插入到child的位置
        // 删除的元素可能能够插入到新的child子树空缺位置
        heap[currentNode] = heap[child]; // 覆盖当前child之前,先取出这个元素到它的父节点
        currentNode = child;             // 原本的父节点更新到下一级父节点
        child *= 2; // child更新到下一级子节点,不是++,兄弟节点不是
    }
    // 最坏情况是child=heapSize,没有兄弟节点了所以if不会执行
    // 此时heap[child]是删除的元素前1个,它一定≥lastElement
    // 如果相等,直接执行heap[currentNode] = lastElement,此时currentNode=heapSize/2
    // 剩下的元素和删除的元素相同大小,但是也不需要做任何操作了
    // 如果依然lastElement < heap[child],child被填充之前先取出去覆盖父节点
    // currentNode是lastElement的兄弟节点填充的
    // 此时currentNode已经更新为heapSize,child*2=2*heapSize,退出while
    heap[currentNode] = lastElement; // 空缺的父节点插入新元素
} 
```

​		top函数如下。

```c++
template<class T>
const T& maxHeap<T>::top()
{
    if (heapSize == 0)
        throw queueEmpty();
    return heap[1]; // 最大优先级的元素总是在第1个
}
```

​		initialize函数如下。

```c++
template<class T>
void maxHeap<T>::initialize(T *theHeap, int theSize)
{
    // push是已知想要的堆的形状,然后打印映射的数组
    // 现在期望给出指定的某种优先级来构造大根堆
    // 用堆theHeap[1:theSize]的元素来构造
    delete[] heap; 
    heap = theHeap;
    heapSize = theSize; // 10
    arrayLength = heapSize + 1; //11
    // 从最后1个具有孩子节点的根开始检查
    // 这个节点在数组的位置是heapSize/2
    // 之后继续检查heapSize/2以前的根节点,直到全局根节点1的位置
    for (int root = heapSize / 2; root >= 1; root--) // 每个根节点以下的所有元素都进行检查
    {
        // 记录这个根节点的元素,检查它的子树是否为大根堆
        T rootElement = heap[root];  // 先记录,如果子树是大根堆就不用再操作
        int child = 2 * root; // 这个父节点的孩子
        // 如果不是大根堆,就要调整这个节点作为根的大根堆的这些元素
        while (child <= heapSize)
        {
            // 类似删除的过程,删除1个调整位置
            // 这里不用删除,只需要调整位置
            if (child < heapSize && heap[child] < heap[child + 1])
                child++;

            if (rootElement >= heap[child])
                break;  // yes

             // no
            heap[child / 2] = heap[child]; // currentNode就是child / 2
            child *= 2;                    
        }
        heap[child / 2] = rootElement;// currentNode就是child / 2
        //for (int i = 1; i <= heapSize; i++)
        //    cout << heap[i] << "  ";
        //cout << "\n";
    }
}
```

​		额外的deactivateArray函数，其实没什么用。

```c++
template<class T>
void maxHeap<T>::deactivateArray()
{
    heap = NULL; arrayLength = heapSize = 0;
}
```

## 12.4 左高树



本章结束~







