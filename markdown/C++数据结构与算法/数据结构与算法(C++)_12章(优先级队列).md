## 概述

​		与普通的队列不同，优先级队列元素出队列的顺序由优先级确定，可以按照优先级的递增也可以递减来出队列，但是不按照元素进入队列的顺序。

​		实现优先级队列通过堆实现，**<u>堆是一颗完全二叉树</u>**，用数组描述的堆效率最高；

​		链表结构描述的左高树也可以表示优先级队列；

​		此外还有配对堆、双端优先级队列，均可以在本书网站找到。C++的STL类priority-queue便是用堆实现的优先级队列。

​		堆的概念可以引出堆排序，其时间复杂度为O(nlogn)，第2章的计数排序、选择排序、冒泡排序、插入排序时间复杂度都是O(n^2)，第6章的基数排序、箱子排序是O(n)，不过这两类排序要求元素的取值限制在合适的范围，通用性不高。

​		堆排序是迄今为止，第一种通用性排序算法，可以证明，任何依赖**<u>成对元素</u>**比较的通用排序算法都具备O(nlogn)时间复杂度。

​		优先级队列是0个或多个元素的集合，每个元素都有一个优先权值，主要的操作有查找1个元素，插入1个元素和删除1个元素，对应top、push和pop函数。

​		最小优先级队列，查找和删除的元素都是优先级最小的元素，最大优先级队列查找和删除的元素是优先级最大的元素。元素允许有相同的优先级，这样的元素查找和删除可以按照任意顺序进行处理。

​		优先级队列的应用例子：

​		如果一台机器每次提供某种服务的收费是相同的，不同用户花费的时间不同，便可以将用户的时间按照最小优先级队列进行排队，即花费时间最少的优先提供服务以取得收益最大化；或者机器每次提供服务的时间相同，但是收费不同，那么花费最多的客户优先，这就是最大优先级队列。

## 12.1 抽象数据类型

### 12.1.1 最大优先级队列

​		语言描述如下。

```c++
抽象数据类型 maxPriorityQueue
{
    实例
        有限个元素集合，每个元素都有优先级
    操作
        empty()：队列为空返回true
        size()：返回队列元素个数
        top()：返回优先级最大元素
        pop()：删除优先级最大元素
        push(x)：插入元素x
}
```

​		C++代码实现如下。

```c++
template<class T>
class abstractMaxPriorityQueue
{
public:
    virtual ~abstractMaxPriorityQueue() {}
    virtual bool empty() const = 0;
    virtual int size() const = 0;
    virtual const T& top() = 0;
    virtual void pop() = 0;
    virtual void push(const T& theElement) = 0;
};
```

### 12.1.2 最小优先级队列

​		语言描述如下。

```c++
抽象数据类型 maxPriorityQueue
{
    实例
        有限个元素集合，每个元素都有优先级
    操作
        empty()：队列为空返回true
        size()：返回队列元素个数
        top()：返回优先级最小元素
        pop()：删除优先级最小元素
        push(x)：插入元素x
}
```

​		C++代码实现如下。

```c++
template<class T>
class abstractMinPriorityQueue
{
public:
    virtual ~minPriorityQueue() {}
    virtual bool empty() const = 0;
    virtual int size() const = 0;
    virtual const T& top() = 0;
    virtual void pop() = 0;
    virtual void push(const T& theElement) = 0;
};
```

## 12.2 无序数组实现的最大优先级队列

​			最大最小思路是差不多的，这里只给出最大优先级队列的无序数组实现。

​			无序数组的实现，插入操作时间复杂度O(1)，即queue[queueSize]=element，但是删除操作为O(n)。首先要找到权重最大的那个元素，然后返回这个元素在该数组的索引，然后使用copy操作复制index前后的两段数据。

​			有序数组的实现，删除变得容易，因为删除queue[queueSize]即可，插入操作为O(n)，需要找到合适的索引位置，然后插入。

	### 12.2.1 声明

​			C++声明如下，有几个自定义的函数，outputByWeight和getCapacity()。weightNode< T >类型的数据来存储。

​			注意继承的时候要在抽象类型这里，使用weightNode< T >去继承，这样maxPriorityQueue的对象才能够插入weightNode类型的元素，以及返回这样类型的元素。

```c++
template<class T>
class maxPriorityQueue :public abstractMaxPriorityQueue<weightNode<T>>
{
public:
	maxPriorityQueue(int theCapacity);
	~maxPriorityQueue();
	bool empty() const { return queueSize == 0; }
	int size() const { return queueSize; }
	int getCapacity() const { return capacity; }
	const weightNode<T>& top();
	void pop();
	void push(const weightNode<T>& theElement);
	void outputByWeight(ostream&) const;
	friend ostream& operator<<<>(ostream& out, const maxPriorityQueue<T>&);
protected:
	int queueSize;
	int capacity;
	int getMaxWeightIndex();
	weightNode<T> * data;
};
```

### 12.2.2 实现

​		构造和析构函数。

```c++
template<class T>
maxPriorityQueue<T>::maxPriorityQueue(int theCapacity)
{
	capacity = theCapacity;
	data = new weightNode<T>[capacity];
	queueSize = 0;
}

template<class T>
maxPriorityQueue<T>::~maxPriorityQueue()
{
	if (data != NULL)
	{
		delete[] data;
		data = NULL;
		delete data;
	}
}
```

​		查找、删除和插入函数。

```c++
template<class T>
void maxPriorityQueue<T> ::push(const weightNode<T>& theElement)
{
	if (queueSize == capacity)
	{
		weightNode<T>* temp = new weightNode<T>[capacity * 2];
		copy(data, data + queueSize, temp);
		delete[] data;
		capacity *= 2;
		data = temp;
	}
	data[queueSize] = theElement;
	queueSize++;
}

template<class T>
void  maxPriorityQueue<T> ::pop()
{
	if (queueSize == 0)
		throw queueEmpty();
	weightNode<T>* temp = new weightNode<T> [capacity]; // 这里容量不要变
	int index = getMaxWeightIndex();
	copy(data, data + index, temp);
	copy(data + index + 1, data + queueSize, temp + index);
	delete[] data;
	data = temp;
	queueSize--;
}

template<class T>
const weightNode<T>& maxPriorityQueue<T> ::top()
{
	if (queueSize == 0)
		throw queueEmpty();
	return data[getMaxWeightIndex()];
}
```

​		私有函数，为了找到最大优先级元素在数组的位置。

```c++
template<class T>
int maxPriorityQueue<T> ::getMaxWeightIndex()
{
	double maxWeight = data[0].weight;
	int index = 0;
	for (int i = 1; i < queueSize; i++)
	{
		if (data[i].weight > maxWeight)
		{
			maxWeight = data[i].weight; // 如果权重一样,返回的是先入队列的那个元素
			index = i;
		}
	}
	//cout << "the index is " << index << endl;
	return index; // 返回最大权重元素所在位置
}
```

​		输出优先级队列的函数。

```c++
template<class T>
void maxPriorityQueue<T> ::outputByWeight(ostream& out) const
{
	if (queueSize == 0)
	{
		out << "the queue is empty!" ;
		return;
	}
	int count = 0;
	int* rank = new int[queueSize]; // rank用于得到名次
	for (int i = 0; i < queueSize; i++)
		rank[i] = 0; // 名次先全部初始化为0
	for (int i = 1; i < queueSize; i++)
		for (int j = 0; j < i; j++)
		{
			count++;
			if (data[j].weight <= data[i].weight) rank[i]++;
			else rank[j]++;
		} // 名次排序得到依据权重的排名
	cout << "size is " << queueSize << endl;
	weightNode<T>* temp = new weightNode<T>[queueSize]; // temp用于存放排序后的data
	for (int i = 0; i < queueSize; i++)
	{
		temp[rank[i]] = data[i]; // rank[i]是a[i]被移动的新位置
	}
	// 名次是升序的
	for (int i = queueSize-1; i >= 0; i--)
		out << temp[i]; // 从大到小输出
	delete[] temp;
}

template<class T>
ostream& operator<<<>(ostream& out, const maxPriorityQueue<T>& x)
{
	x.outputByWeight(out);
	return out;
}
```

## 12.3  堆实现的最大优先级队列

​		相比于数组，无论是有序还是无序，堆实现更加高效，所以引入堆的概念。

### 12.3.1 堆的定义

​		定义1：一颗大根树/小根树

​		大根树的每个节点的值都大于(小于)或等于其子节点(如果有子节点的话)的值。也就是说，大根树和小根树都是二叉树，只是元素是有序的。

​		定义2：一个大根堆/小根堆

​		在大根树和小根树的定义下，加入一个还是完全二叉树的强条件，这就要求元素必须是按照层去铺满树，不能跳跃。

​		由于是完全二叉树，所以可以将二叉树的元素映射到一维数组，使用节点在数组中的位置来表示在堆中的位置。如根的位置是1，左孩子为2，右孩子为3等等。

​		堆的高度满足完全二叉树的高度定义，即[log2(n+1)]，所以能够在O(height)时间内完成插入和删除操作，则这些操作的复杂性为O(logn）。

### 12.3.2 堆的插入、删除与初始化

​		以大根堆为例进行说明。



### 12.3.3 优先级队列maxHeap

#### 12.3.3.1 声明



#### 12.3.3.2 实现





​		

本章结束~







