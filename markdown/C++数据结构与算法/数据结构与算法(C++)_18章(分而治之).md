## 概述

​		分而治之的思想在于，把一个问题实例分解若干个小型而独立的实例，一般小实例也是原问题的实例，然后分而治之使用递归方法进行求解。例如在二叉树的相关问题中就常常使用递归，因为一个树节点总是具备同样的操作，合适的递归方法就可以解决所有树节点的问题，最后组合成树的解，因为树的根本身也是树节点。

### 假币问题

​		16个硬币中有1个假币，设定假币比真币轻，现在有个天平可以去比较两组硬币的重量，去找出这个假币。

​		一种解法是对16个硬币进行8次偶数循环，两两进行比较，有轻的就找到，否则一直必到所有硬币都比较过为止。最好的情况下，第1次就找到硬币，最坏的情况下第8次才能找到，平均为4.5次。

​		另一种解法把16个硬币看作一组大实例，分成2组A和B，每组有8个硬币，那么比较1次就知道假币会在哪组。假定B组更轻，将其二分为2个组B1和B2，比较1次直到假币的位置假定是B1；然后继续分割，每组2个实例，这已经到了最小分割实例，必定能找到那个假币。这种比较方法只需要比较3次，而且是固定的比较次数，比平均4.5次要好。

### 金块问题

​       8袋金块，找出最重的金块和最轻的金块。

​		这个问题可以使用普通的循环比较方法找到，设定1个变量初始为第1块金块，然后比较n-1次，如果后边有金块比它重就更新这个变量的值。这样最终变量就找到了最大的那个金块，然后在余下的n-1个金块同样的方法比较n-2次可以得到最轻的金块，总计需要比较2n-3次；

​		也可以同时设定2个变量值记录最大和最小，一次循环过程同时比较2个变量值和当前金块，使用2个独立的if，需要2n-2次比较；

​		还可以进一步优化，在比较记录最大值的变量和当前金块后，使用else ，而不是独立的2个if。因为如果当前金块值比目前最大值大的话，则当前的金块一定不会是最轻的；反过来也一样，比目前最轻值还轻的金块也不会是最重的金块，所以2个if执行1个就可以。这个方法最多执行2n-2次；

​		如果是8个金块，以上方法分别需要比较13、12次和最多需要比较12次。

​		现在来看看分而治之的策略需要比较多少次。

​		假设金块先分为4组，每组2个，那么每组需要比较1次，就可以知道每组更重和更轻的那个，一共需要4次比较，这是最小的实例；

​		然后比较前2组两个各自最重的金块和2个各自最轻的金块就可以知道这2组整体最重和最轻的金块，0后2组同理，这是次之的实例，一共需要比较4次；

​		最后还要比较前2个组和后2个组的最大和最小金块，从而得到整体8个金块中最大和最小的金块，这需要比较2次，最终需要比较10次。比较次数和最初元素的个数n存在一些规律，为了方便，假设n是2的幂数，假设比较次数为T(n)，显然T(2)=1。

​		观察可知，1个节点下边的2个子节点需要比较2次，每个子节点又要各自比较2次(已经假设n是2的幂数)，所以每个父节点总是它的子节点的比较次数乘2。同时1个父节点除了全局根节点外必然会有兄弟节点，所以还要算上2次和兄弟节点的比较才能得到更上一级的节点。所以递推公式显而易见有T(n) = 2 * T(n/2) + 2。

​		这个思路有一些像二叉树，事实上二叉树就是应用分而治之递归策略最多的数据结构。金块问题用二叉树示意图如下。

![分而治之金块问题](分而治之金块问题.jpg)

## 应用

​		本章的应用问题有最小最大问题、矩阵乘法、残缺棋盘问题、归并排序和快速排序、选择和二维空间寻早距离最近的2个点。

### 最大最小问题

​		在数组中找到最大和最小的值索引，这个在概述中已经提过，如果以第2章的算法需要比较2n-3或者2n-2次，现在尝试使用分而治之的算法去解决这个问题。可以证明，这个算法是在寻找最大和最小值问题中，比较次数最少的算法。

​		C++代码实现如下。

```c++
template<class T>
bool minMax(T a[], int n, int& minIndex, int& maxIndex) {
	// 在a[0,n-1]内找出最大最小值
	if (n < 1) return false;
	if (n == 1) {
		minIndex = maxIndex = 0; 
		return true;
	}
	int start ; // 循环的起点取决于n的奇偶性

	if (n % 2 == 1) { // 奇数,那就拿出1个作为初始最大最小值,后边偶数个元素可以两两比较
		minIndex = minIndex = 0; // a[0]认为是一开始最大和最小的元素
		start = 1; // (1,2),(3,4)...这样两两比较
	}
	else { // 偶数,拿出1个值会有问题,所以拿出2个,所以先比较2个元素
		if (a[0] > a[1]) { // 先比较2个元素a[0]和a[1]
			minIndex = 1;
			maxIndex = 0;
		}
		else {
			minIndex = 0;
			maxIndex = 1;
		}
		start = 2; // 从a[2]开始比较
	}

	// 剩余元素必定是偶数个
	for (int i = start; i < n; i += 2) {
		if (a[i] > a[i+1] ) { // 如果前1个元素大
			if (a[i] > a[maxIndex]) maxIndex = i; // 则让前1个元素和目前最大的比较
			if (a[i + 1] < a[minIndex]) minIndex = i+1; // 后1个元素和目前最小的比较
		}
		else { // 后1个元素大,则正好反过来
			if (a[i+1] > a[maxIndex]) maxIndex = i+1;
			if (a[i] < a[minIndex]) minIndex = i;
		}
	}
	return true;
}
```

	### 归并排序问题





本章结束~下一章节为动态规划。

