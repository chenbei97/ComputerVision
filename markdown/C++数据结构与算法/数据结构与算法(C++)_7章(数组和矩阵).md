## 7.1数组

### 7.1.1 抽象数据类型

​		这里的数组不是普通的数组，而是数组对，类似于元组，即数组的每个元素是一个元组对。

​		一个数组的每一个实例都是形如(索引，值)的数对集合，任意两个数的索引index都不相同，它具备最基本的2个操作：

​		① 取值---对一个给定的索引可以获取它的值，即get(index)

​		②存值---把一个新数对加在数对集合中，如果已经存在一个索引相同的数对，则进行覆盖

​		由此可以定义抽象数据类型如下：

```c++
抽象数据类型array
{
   实例
       形如(index,value)的数对集合，任意两个数的index都不同
   操作
       get(index)：返回索引为index的数对的值
       set(index,value)：加入一个新数对，如果索引相同的数对已存在则新数对覆盖
}
```

​		例子：每个星期的温度

​		temperatures = {(Sunday,82),(Monday,79),(Tuesday,85),(Wednesday,92),(Thursday,88),(Friday,89),(Saturday,91)}

​		映射

​		temperatures = {(0,82),(1,79),(2,85),(3,92),(4,88),(5,89),(6,91)}

### 7.1.2 索引与行主映射

​		C++中对数组索引使用的是中括号[]，数组的索引通常具备如下形式，每个[]代表1个维度上的索引。

```c++
[i1][i2][i3]..[ik]
int score[u1][u2][u3] // i1<ui,i2<u2,i3<u3
```

​		每个ij能取到的值取决于最初定义的该维度元素的容量-1，例如

```c++
int score[3][2][4] ; 
// i1最大取到3-1=2,i2同理为1,i3为3
```

​		现在希望将多维的索引能够映射到一个一维数组上，有2种方式，行主映射和列主映射。

​		以3行6列的二维数组为例说明行主映射，其索引的所有选项如下。

```c++
int score[u1][u2]= int score[3][6]
[i,j]的所有选项：
[0][0] [0][1] [0][2] [0][3] [0][4] [0][5] // 首先列出第1个索引为0的索引
[1][0] [1][1] [1][2] [1][3] [1][4] [1][5] // 然后列出第1个索引为1的索引
[2][0] [2][1] [2][2] [2][3] [2][4] [2][5] // 最后列出第1个索引为2的索引
					
  0      1      2      3      4      5
  6      7      8      9      10     11   => 行主映射：每一行的索引从左至右编号
  12     13     14     15     16     17
  映射公式为：map(i,j) = i*u2+j = 6i+j(每行的元素*行数+列数 j=0,1,2,3,4,5)行不动,列左右编号
  0      3      6      9      12     15
  1      4      7      10     13     16   => 列主映射：每一列的索引从上至下编号
  2      5      8      11     14     17
  映射公式为：map(i,j) = j*u1+i = 3j+i(每列的元素*列数+行数 i=0,1,2)列不动,行上下编号
```

​		再以三维数组为例说明如何行主映射到1个一维数组，其索引的所有选项如下。

```c++
int score[u1][u2][u3] = int score[3][2][4]
[i,j]的所有选项：
[0][0][0] [0][0][1] [0][0][2] [0][0][3] [0][1][0] [0][1][1] [0][1][2] [0][1][3] 
// 首先列出第1个索引为0第2个索引为0的索引, 再列出第1个索引为0第2个索引为1的索引
[1][0][0] [1][0][1] [1][0][2] [1][0][3] [1][1][0] [1][1][1] [1][1][2] [1][1][3] 
// 然后列出第1个索引为1第2个索引为0的索引,再列出第1个索引为1第2个索引为1的索引
[2][0][0] [2][0][1] [2][0][2] [2][0][3] [2][1][0] [2][1][1] [2][1][2] [2][1][3] 
// 最后列出第1个索引为2第2个索引为0的索引,再列出第1个索引为2第2个索引为1的索引
映射公式为：map(i,j,k) = (i*u2+j)*u3+k = i*u2*u3+j*u3+k = 8i+4j+k
推广：map(i,j,k..,n) = i*(uj*uk*..un)+j*(uk*..*un)+..+(n-1)*(un)+n
```

### 7.1.3 二维数组

​		二维数组本质上是1个一维数组，每个数组元素存储的是个具备n个元素一维数组[n]的首地址，即一维数组本身。

​		例如 int a[3] [5]，a存储的是3个具备5个元素的一维数组的首地址。首地址可以使用数组名或者首元素的地址，即a[0]是个数组名，它就等于&a[0] [0]，a[1]和a[2]同理。

​		但是要注意，指向b和&b的指针是不同的类型。即指向二维普通数组本身的(* )[n]指针和指向二维普通数组地址的 ( *)[m] [n]指针。不过本章的重点不在这里，语法特性上不过多解释。

​		二维数组x可以使用行主映射到一个一维数组y，为了访问这个数组x[i] [j]的元素，需要通过映射公式计算出位置u，然后索引访问y[u]即可。

​		上述所有的讨论都基于一个事实，二维数组是规则的，每行的元素个数都是相同的，有时候可能会遇见不同行有不同个数，这就是不规则的二维数组。例如下方程序给出了1个不规则数组的创建和使用。

```c++
void _charter7_irregular_array2d()
{
	int rows = 5;
	int lengths[5] = { 6,3,4,2,7 }; // 每一行的长度
	// 声明1个二维数组并分配所需要的行数
	// 不过这个二维数组是用指针数组来间接定义的
	int** arr = new int* [rows]; // 指向指针数组的指针为**类型
	//  指针的类型怎么看？去掉名字即可,即int**类型
	// 指针指向的类型?不仅去掉名字还要去掉名字左边的1个*,即int *类型
	// int * 类型可以是地址也可以是地址数组
	// int *[rows] 就是 int *[] 地址数组类型,也就是俗称的指针数组

	for (int i = 0; i < rows; i++)
		arr[i] = new int[lengths[i]]; // arr[i]也是个指针,指向一维数组本身
	
	// 不规则数组的遍历
	for (int i = 0; i < rows; i++) 
	{
		for (int j = 0; j < lengths[i]; j++)
		{
			arr[i][j] = i * rows + j + 1;
		}
	}
	for (int i = 0; i < rows; i++)
	{
		int* t = arr[i];
		for (int j = 0; j < lengths[i]; j++)
			cout << *t++ << "  ";
	}
	cout << endl;
}
```

## 7.2 矩阵

​		之所以引入行主映射，是因为存储矩阵类型的元素使用一个一维数组比较简单，而不用开辟二维数组去存储这些元素。相应的，如果外界想要访问，就需要映射公式。

​		同型的矩阵能够执行+、-运算(可以加1个数也可以加1个矩阵)，+=或者-=也是如此；乘法运算需要同型或者，前一个矩阵的列数等于后一个矩阵的行数也可以；=运算相当于复制构造操作，

​		此外提供返回矩阵的行数与列数的函数。

### 7.2.1 声明

​		类的声明头文件如下。

```c++
template<class T>
class matrix
{
public:
    matrix(int theRows = 0, int theColumns = 0);
    matrix(const matrix<T>&);
    ~matrix() { delete[] element; }
    int rows() const { return theRows; }
    int cols() const { return theColumns; }
    matrix<T>  transpose() const; // 取决于如何看一维数组
    void t();// 改变了内存顺序
    T& operator()(int , int ) const;
    matrix<T>& operator=(const matrix<T>&); // A=B ; 相当于复制构造 this会变
    matrix<T>& operator=(const T&) ; // A = 5 ; 所有元素都是5 this会变
    matrix<T> operator+(const T&) const; // B = A+5 
    matrix<T> operator+(const matrix<T>&) const; // C = A+B
    template<class T>
    friend matrix<T> operator+(const T&, const matrix<T>&); // 5+A 
    matrix<T> operator-() const; // -A , 没有matrix<T> operator+() const因为没必要就是自己
    matrix<T> operator-(const matrix<T>&) const; // A-B
    matrix<T> operator-(const T&) const ; // A-5
    template<class T>
    friend matrix<T> operator-(const T&, const matrix<T>&); // 5-A
    matrix<T> operator*(const matrix<T>&) const;
    matrix<T>& operator+=(const T&); // A+= 5
    matrix<T>& operator++(int); // A++
    matrix<T>& operator-=(const T&);// A-= 5
    matrix<T>& operator--(int); // A--
    matrix<T>& operator*=(const T&);// A*= 5
    matrix<T>& operator /=(const T&);// A/= 5
    friend void output1(const matrix<T1>&); 
    void output2();
    friend ostream& operator<<(ostream&out, const matrix<T>&m) 
    {     
            int k = 0;  // 遍历this->element的索引
            for (int i = 0; i < m.theRows; i++) // 每行 这里m.theRows就体现了可以访问私有成员
            {// 这里依然不能访问this
                for (int j = 0; j < m.theColumns; j++)
                    out << m.element[k++] << "  "; // 每列 这样k++从0开始直到theColumns*theRows-1
                out << endl;
            }
            return out;
    }
private:
    int theRows,    // 行数
        theColumns; // 列数
    T* element;     // 行主映射,用于存储矩阵元素
    bool empty() const { return theColumns * theRows == 0; };
};
```

### 7.2.2 实现

​			实现部分只说明重载的问题，矩阵乘法和转置，其它不详细介绍

#### 7.2.2.1 重载实现

​			重载函数，这里对=、+、-、*、+=、-=、*=、/=、++、--以及<<都进行了重载。

​			对于<<需要特别说明，这里引入了友元函数的概念。

​			对于*的实现在下一小节说明。

​			友元函数的声明必须在类内声明，而实现可以类内实现也可以类外实现(这里的内外只是从代码位置的角度来看的，就像output1函数一样，但是本质上不是类的函数)，声明中给出了类内实现。<<重载要求输出流out在前，而矩阵m在后，但是operator类内成员函数重载时由于this指针的存在，只能m在前，且不能传入2个参数及以上。为了解决这个问题，就定义这个重载函数为类外的成员函数，就可以传入2个参数了，类似于非成员且非友元output3函数。但是新的问题是output3不能访问私有属性，但输出流cout<<m<<endl要访问m的element、theRows、theColumns等私有属性，所以还需要添加声明为friend。

​		友元函数类内实现：

```c++
friend ostream& operator<<(ostream&out, const matrix<T>&m) 
{     
    int k = 0;  // 遍历this->element的索引
    for (int i = 0; i < m.theRows; i++) // 每行 这里m.theRows就体现了可以访问私有成员
    {// 这里依然不能访问this
        for (int j = 0; j < m.theColumns; j++)
            out << m.element[k++] << "  "; // 每列 这样k++从0开始直到theColumns*theRows-1
        out << endl;
    }
    return out;
}
```

​		友元函数类外实现：下面的声明方式①②③任选一种都可以。且经过测试，方案①的声明和方案①、②的实现都是可以正常运行的，不过最好对应使用，否则会有个未找到函数定义的提示(①声明和②实现)，同理方案②、③的声明和方案①、②的实现也可以混用，其实不会报错但是建议上下一致。

```c++
friend ostream& operator<<<>(ostream&, const matrix<T>& ); // 方案①<<多加个<>

template<class T> 
friend ostream& operator<<(ostream&, const matrix<T>&); // 方案②多加个template<class T> 

template<class T> 
friend ostream& operator<<<>(ostream&, const matrix<T>&); // 方案③组合使用 

template<class T> // 论方案①还是②还是③这里实现部分必须加
ostream& operator<<<>(ostream& out, const matrix<T>& m) // 方案①
ostream& operator<<(ostream& out, const matrix<T>& m) // 方案②
// 使用方案①和③时为了避免没有函数定义的提示最好上边使用<<<>下边也使用<<<>,但是不加也确实不会出错
// 使用方案②时 同理 上边使用<<,下边也最好使用<< 但是不这样做也是不会出错的
{
    int k = 0;  // 遍历this->element的索引
    for (int i = 0; i < m.theRows; i++) // 每行 =>这里m.theRows就体现了可以访问私有成员
    {// 但是不能显示访问this
        for (int j = 0; j < m.theColumns; j++)
            out << m.element[k++] << "  "; // 每列 这样k++从0开始直到theColumns*theRows-1
        out << endl;
    }
    return out;
}
```

​		关于友元函数、非友元非成员函数、成员函数的区别在output函数的不同实现中给出了区别。

```c++
class matrix
{
    ...
    template<class T>
	friend void output1(const matrix<T1>&);  // output1 友元函数声明
	
    void output2(); // 类成员函数output2声明
    ...
}
template<class T>
void output3(const matrix<T>& m); // 非友元非成员函数output3声明

template<class T1>  // output1实现,无需作用域
void output1(const matrix<T1>& m)
{
    int idx = 0;
    for (int i = 0; i < m.theRows; i++) // 可以访问私有属性 不通过this
    {
        for (int j = 0; j < m.theColumns; j++)
        {
            cout << m.element[idx++] << "  ";
        }
        cout << endl;
    }
    cout << endl;
}
template<class T>
void matrix<T>::output2() // output2实现，需要说明作用域
{
    int idx = 0;
    for (int i = 0; i < this->theRows; i++) // 可以访问私有属性 通过this
    {
        for (int j = 0; j < this->theColumns; j++)
        {
            cout << this->element[idx++] << "  ";
        }
        cout << endl;
    }
    cout << endl;
}
template<class T>
void output3(const matrix<T>&m) //output3实现,无需作用域
{
    int idx = 0;
    for (int i = 1; i <= m.rows(); i++) // 不可以访问私有属性 只能间接访问
    {
        for (int j = 1; j <= m.cols(); j++)
        {
            cout << m(i,j) << "  "; // theRows,theColumns,element都不能访问
        }
        cout << endl;
    }
    cout << endl;
}
```

#### 7.2.2.2 矩阵乘法

​			矩阵的乘法本来是不难的，如果是2个二维矩阵，进行交换，只需要一个变量记录每行每列的乘积和即可。

```c++
template<class T>
void matrixMultiply_differentSize(T** a, T** b, T** c, const int m, const int n, const int p)
{
	// m×n * n×p = m×p
	// 和同型的原理是一样的,只不过2次循环是从m和p循环的 因为结果是m×p
	for (int i = 0; i < m; i++)
		for (int j = 0; j < p; j++)
		{
			T sum = 0; //用于计算a的每一行与b的每一列的和
			for (int k = 0; k < n; k++) // a的列数和b的行数肯定是相等的,为n
				sum += a[i][k] * b[k][j]; // a[i][k]第i行的第k个数和b[k][j]第j列的第k个数
			c[i][j] = sum;// 共有m行和p列
		}
}
```

​			但是在matrix类中，用于存储数据的是一维数组的指针，所以还不能直接进行a[i] [k] * b[k] [j]这样的计算。

```c++
template<class T>
matrix<T> matrix<T>::operator*(const matrix<T>& m) const
{// matrix multiply.  Return w = (*this) * m. // 矩阵乘法稍微要注意以下前列数=后行数
    if (theColumns != m.theRows)
        throw matrixSizeMismatch();

    matrix<T> w(theRows, m.theColumns);  // result matrix 返回的矩阵是前行数*后列数

    // 假设a=5×4 和b=4×3的结果为c=5×3 
    int arow = 0, bcol = 0, cw = 0; // 3个游标
    for (int i = 1; i <= theRows; i++) // i =1,2,3,4,5
    {
        for (int j = 1; j <= m.theColumns; j++) // j = 1,2,3
        { 
            T sum = element[arow] * m.element[bcol];  // 相当于a[1,1]*b[1,1]
            for (int k = 2; k <= theColumns; k++) // k=2,3,4 不作为任何索引,就是计算几次
                // 由于首元素已经计算,只需要运行theColumns-1次,那么k应该从2开始
            {
                arow++;  // a[1,1]=>a[1,2],每行的下一个元素移动1个位置即可
                bcol += m.theColumns;  // b[1,j]=>b[2,j]=>b[3,j]=>b[4,j] 同列移动需要移动4个单位,且bcol必须是0开始才能到4
                sum += element[arow] * m.element[bcol]; 
                // a[i,1]*b[1,j]+{a[i,2]*b[2,j]+a[i,3]*b[3,j]+a[i,4]*b[4,j]},{}内是k=2,3,4运行3次
            }
            w.element[cw++] = sum;  // c[i][j]从cw=0开始的直到 theRows*m.theColumns结束,存储好存
            // 计算当前行与每个列的和,所以arow总是返回当前行首元素位置
            // 列总是到下1列首元素,列应该是1,2,3列,但是bcol对应的是0,1,2,用j表示,j从1开始的
            arow -= theColumns - 1; // 每个m的列遍历,arow要后退回当前行的首元素处
            bcol = j; // 每列的首元素,即总是b[1,1],b[1,2],b[1,3],bcol在element恰好对应的就是0,1,2索引
            // 而b[1,1]->b[4,1]在前边已经执行过(相当于bcol=0的情况),下一步回到b[1,2]->b[4,2],再回到b[1,3]->b[4,3]
            // 也就是bcol只需要再取1,2即可,恰好是j
            // 0 b[1,1]->b[1,2]->b[1,3]->
            //    b[2,1]->b[2,2]->b[2,3]->
            //    b[3,1]->b[3,2]->b[3,3]->
            //    b[4,1]->b[4,2]->b[4,3]
        }

        // 每次行更新的时候,arow要移动到下一行的首元素
        arow += theColumns; // a[1,1]=>a[2,1],要+4个地址,所以在列遍历中总是后退theColumns - 1个元素
        bcol = 0; // i更新后必须为0,bcol += m.theColumns才能加到指定的列位置
    }
    return w;
}
```

#### 7.2.2.3 矩阵转置

​			矩阵的转置可以有2个方式，一种是取决于我们怎么看待内存，即transpose()，内存数据的排列并没有变化,而是通过一定的索引方式取出来这些数据打印出来就是转置。取出来的核心公式就是{w(i,j) = element[theColumns*(j-1)+i-1];}

```c++
template<class T>
matrix<T> matrix<T>::transpose() const
{// 此方法并不改变内存的排序只是以列主映射的位置返回
    // 转置要初始化过
    if (this->theColumns <= 0 || this->theRows <= 0)
        throw matrixSizeNotInitialized();
    matrix<T> w(theColumns, theRows);
    /*
        举例分析转置在一维数组是怎么实现的
        内存位置的元素 => 0,1,2,3,4,5,6,7,8,9,10,11
        行主映射：
        0, 1, 2, 3    A(i,j)=element[theColumns*(i-1)+j-1] = element[4i+j-5]
        4, 5, [6], 7    例如A(2,3)=element[4+2]=6
        8, 9, 10, 11 
        列主映射：
        0, 3, 6, 9    A(i,j)=element[theRows*(j-1)+i-1] = element[i+3j-4]
        1, 4, 7, 10  例如A(3,3) = element[6+2]=8
        2, 5, [8], 11
        转置后
        0, 4, 8       有点类似于列主映射,但是行数变为列数
        1, 5, 9      A.T(i,j)=element[theColumns*(j-1)+i-1] = element[i+4j-5]
        2, 6, 10   例如A.T(4,3) = element 
        3, 7, [11]
    */
    for (int i = 1; i <= theColumns; i++)
        for (int j = 1; j <= theRows; j++)
            w(i,j) = element[theColumns*(j-1)+i-1];
    return w;
}
```

​			还可以真的改变内存排列来进行转置，但是要注意的是私有属性列theColumns和行theRows要交换，否则外边打印出来还是错的，在t()函数中实现。

```c++
template<class T>
void matrix<T> :: t()
{
    if (this->theColumns <= 0 || this->theRows <= 0)
        throw matrixSizeNotInitialized();
    /*
        接上transpose的分析
        内存 : 0,1,2,3,  4,5,6,7,   8,9,10,11  3×4
        转置后:0,4,8,  1,5,9,  2,6,10,  3,7,11 4×3
        每个行总是相差theColumns个元素
        关键在于行的开头是原来的第1列位置
    */
    T* b = new T  [theColumns*theRows];
    int k = 0;
    for (int i = 0; i <= theRows; i++)// i = 0,1,2,3
    {
        for (int j = i; j < theColumns*theRows; j += theColumns) 
        {
            // j =0,4,8<12 or j =1,5,9<12 or j=2,6,10 <12 or j = 3,7,11<12
            //cout << "element[" << j << "] = " << element[j] << endl;
            b[k++] = element[j];  // 按这样的方式取出来
        }
    }
    k = 0;
    for (; k < theColumns * theColumns; k++)
        element[k] = b[k];
    int t = theColumns;
    theColumns = theRows;
    theRows = t; // 转置后行与列要交换
    b = NULL; // 不要delete b会自动释放,只需要置空避免野指针即可
}
```

## 7.3 特殊矩阵

​		特殊矩阵一般说的是方阵，常见的特殊矩阵有对角矩阵、三对角矩阵、上下三角矩阵以及对称矩阵。

### 7.3.1 对角矩阵

​	    对角矩阵A可以表示为一个二维数组element[row] [col]，A(i,j)=element[i-1][j-1],但是二维数组需要n^2的内存空间；使用一维数组存储,由于稀疏性,0元素不存储,所以只需要n的内存空间，A(i,j)=element[i-1]即可,也就是只存n个数,但是外界还是可以用(i)(j)来访问。

​		类声明如下，提供了set和get函数，2个构造函数和1个运算符重载，更多的功能可以和matrix类一样。

```c++
template<class T>
class diagonalMatrix
{
public:
    diagonalMatrix(int theN = 10);
    diagonalMatrix(T*,const int &);
    ~diagonalMatrix() { delete[] element; }
    T get(int, int) const; // 不是使用重载()的方式,提供2个函数修改和访问元素
    void set(int, int, const T&);//使用T &,外边传5会报错,定义const就可以不传变量了
    friend ostream& operator<<<>(ostream&, const diagonalMatrix<T>&);
private:
    int n;       // 矩阵维度
    T* element;  // 存储
};
```

​		实现如下。

```c++
template<class T>
diagonalMatrix<T>::diagonalMatrix(int theN)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");

    n = theN;
    element = new T[n];
}
template<class T>
diagonalMatrix<T>::diagonalMatrix(T*data,const int & theN)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[n];
    copy(data,data+n,element);
}

template <class T>
T diagonalMatrix<T>::get(int i, int j) const
{
    if (i < 1 || j < 1 || i > n || j > n) // 获取元素
        throw matrixIndexOutOfBounds();
    if (i == j)
        return element[i - 1];   // 是对角元素
    else
        return 0;              // 非对角元素都是0
}

template<class T>
void diagonalMatrix<T>::set(int i, int j, const T& newValue)
{
    if (i < 1 || j < 1 || i > n || j > n)
        throw matrixIndexOutOfBounds();
    if (i == j)
        element[i - 1] = newValue;
    else
        if (newValue != 0)
            throw illegalParameterValue
            ("nondiagonal elements must be zero");
}

template<class T>
ostream& operator<<<>(ostream& out, const diagonalMatrix<T>& m)
{
    for (int i = 0; i < m.n; i++)
    {
        for (int j = 0; j < m.n; j++)
        {
            if (i != j)
                out << 0 << "  ";
            else
                out << m.element[i] << " ";
        }
        out << endl;
    }
    return out;
}
```

### 7.3.2 三对角矩阵

​		三对角矩阵有3条对角线，设元素坐标为(x,y)，维度为n，则它们的坐标关系总是满足：

​	   主对角线：x=y

​		低对角线：x-1 = y

​		高对角线：x = y - 1

​		这3条线的元素个数为3*n-2，之后的问题就是如何把二维坐标(x,y)如何映射到一维数组当中。

​		考虑一个4×4的三对角矩阵，二维坐标形式和行、列主映射以及按照低到高对角线映射的一维数组内存的排列方式如下。

```c++
二维坐标形式：
 [2] [1] [0] [0]
 [3] [1] [3] [0]
 [0] [5] [2] [7]
 [0] [0] [9] [0]
行主映射内存的排列方式：
 2 1 3 1 3 5 2 7 9 0
列主映射内存的排列方式：
 2 3 1 1 5 3 2 9 7 0
低对角线到高对角线的排列方式：
 3 5 9 2 1 2 0 1 3 7
```

​		这3种方式，A(x,y)和element[k]的映射关系都不一，对get、se还有<<重载有影响，构造函数没有影响，只取决于我们怎么看待这批内存数据，这样效率更高不用改变内存实际的存放位置。这里给出3个实现和3个声明，区别只有名字不同。

```c++
// 行主映射
tridiagonalMatrixRow(int theN = 10);
tridiagonalMatrixRow(T*, const int&);
template<class T>
tridiagonalMatrixRow<T>::tridiagonalMatrixCol(int theN)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[3*n-2];
}
template<class T>
tridiagonalMatrixRow<T>::tridiagonalMatrixRow(T*data, const int&n)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[3*n-2];
    copy(data, data + 3*n-1, element);// 是末位元素的后1个位置
}
// 列主映射
tridiagonalMatrixCol(int theN = 10);
tridiagonalMatrixCol(T*, const int&);
template<class T>
tridiagonalMatrixCol<T>::tridiagonalMatrixCol(int theN)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[3*n-2];
}
template<class T>
tridiagonalMatrixCol<T>::tridiagonalMatrixCol(T*data, const int&n)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[3*n-2];
    copy(data, data + 3*n-1, element);// 是末位元素的后1个位置
}
// 对角映射
tridiagonalMatrixDiag(int theN = 10);
tridiagonalMatrixDiag(T*, const int&);
template<class T>
tridiagonalMatrixDiag<T>::tridiagonalMatrixDiag(int theN)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[3*n-2];
}
template<class T>
tridiagonalMatrixDiag<T>::tridiagonalMatrixDiag(T*data, const int&n)
{
    if (theN < 1)
        throw illegalParameterValue("Matrix size must be > 0");
    n = theN;
    element = new T[3*n-2];
    copy(data, data + 3*n-1, element);// 是末位元素的后1个位置
}
```

#### 7.3.2.1 行主映射

​		注意，某个坐标(xi,xi)总是下边和右边有1个元素，也就是如果访问某个坐标(xi,y)，xi和y的差只有0,1或者-1。

​	    如果xi-y=0，说明是对角元素，那么访问A(xi,xi)只需要确定x的位置i，1≤i≤n。因为主对角坐标(i,i)和element的k坐标总是满足k=3i-3的关系,即A(i,i)=element(3i-3)，因为对角元素之间总是差2个元素。

​		根据A(1,1)=element[0],A(2,2)=element[3],A(3,3)=element[6],..，可总结出关系为A(i,i)=element[3i-3]。这个关系的前提是行主映射。

​		如果xi-y=1，说明访问的是A(xi-1,xi-1)的下方元素，即element[3(i-1)-3+2]，+2是隔了1个元素。这里要注意，行索引大于列索引说明是低对角线，可以向上找A(xi-1,xi-1)的下方，也可以找当前行A(xi,yi)的左边元素，即element[3i-3-1]。可以发现3i-3-1其实就是3(i-1)-3+2=3i-4，位置没有变化。

​		如果xi-y=-1，说明访问的是A(xi,xi)的右方元素，即element[3i-3+1]，+1是当前行下一列。或者A(xi+1,xi+1)的上方元素，即element[3(i+1)-3-2]，即element[3i-2]，结果也是一样的。

​		总结：

​		①A(i,i)对应element[3i-3]

​		②A(i,j),i-j=1,在A(i,i)左边或者A(i-1,i-1)的下边,但都对应的是element[3i-4]

​		③A(i,j),i-j=-1在A(i,i)右边或者A(i+1,i+1)的上边,但都对应的是element[3i-2]

​		例如：行主映射的三对角矩阵如下所示。

```c++
 1  2  0  0  0
 3  4  5  0  0
 0  6  7  8  0
 0  0  9 10 11
 0  0  0 12 13
```

​		声明程序。

```c++
template<class T>
class tridiagonalMatrixRow
{
public:
    tridiagonalMatrixRow(int theN = 10);
    tridiagonalMatrixRow(T const * , const int&); // 常量指针,++a可以,*a=3不可以
    ~tridiagonalMatrixRow() { if (element != NULL) element = NULL; delete[] element; }//改成这样就不会出错了
    T get(int, int) const;
    void set(int, int, const T&); 
    friend ostream& operator<<<>(ostream&, const tridiagonalMatrixRow<T>&);
private:
    int n;
    T* element;
};
```

​	实现程序。

```c++
template <class T>
T tridiagonalMatrixRow<T>::get(int i, int j) const
{
    if (i < 1 || j < 1 || i > n || j > n)
        throw matrixIndexOutOfBounds();
    switch (i - j)
    {
    case 0:
        return element[3 * i - 3] ; 
    case 1:
        return element[3 * i - 4]; 
    case -1:
        return element[3 * i - 2]; 
    default:
        return 0;
    }
}
template<class T>
void tridiagonalMatrixRow<T>::set(int i, int j, const T& newValue)
{
    if (i < 1 || j < 1 || i > n || j > n) 
        throw matrixIndexOutOfBounds();
    switch (i - j)
    {
    case 0:
        element[3 * i - 3] = newValue; break;
    case 1:
        element[3 * i - 4] = newValue; break;
    case -1:
        element[3 * i - 2] = newValue; break;
    default:
        if (newValue != 0)
            throw illegalParameterValue
            ("nontridiagonal elements must be zero");
    }
}
template<class T>
ostream& operator<<<>(ostream& out, const tridiagonalMatrixRow<T>& m)
{
    // A(i,i)对应element[3i-3]
    // A(i,j),i-j=1,在A(i,i)左边或者A(i-1,i-1)的下边,但都对应的是element[3i-4]
    // A(i,j),i-j=-1在A(i,i)右边或者A(i+1,i+1)的上边,但都对应的是element[3i-2]
    for (int i = 1; i <= m.n; i++)
    {
        for (int j = 1; j <=m.n; j++)
        {
            switch (i-j)
            {
            case 0:
                cout << m.element[3 * i - 3] << "  "; break;
            case 1:
                cout << m.element[3 * i - 4] << "  "; break;
            case -1:
                cout << m.element[3 * i - 2] << "  "; break;
            default: 
                cout << 0 << "  "; break;
            }
        }
        out << endl;
    }
    return out;
}
```

#### 7.3.2.2 列主映射

​		例子，形如下方矩阵形式，发现有一个特点，列主映射其实就是行主映的转置。

```c++
 1  3  0  0  0
 2  4  6  0  0
 0  5  7  9  0
 0  0  8 10 12
 0  0  0 11 13
```

​		那么列主映射公式为

​		① A(xi,xi)=>element[3i-3]，对角没有变化

​		② xi-y = 1 , A(xi,y)=>element[3i-5]，原本是左边元素element[3i-4]，现在变成上方元素，故再减1

​		③ xi-y = -1，A(xi,y)=>element[3i-1]，原本是右边元素element[3i-2]，现在变成下方元素，故再加1

​		声明程序。

```c++
template<class T>
class tridiagonalMatrixCol
{
public:
    tridiagonalMatrixCol(int theN = 10);
    tridiagonalMatrixCol(T*, const int&);
    ~tridiagonalMatrixCol() { if (element != NULL) element = NULL; delete[] element; }
    T get(int, int) const; 
    void set(int, int, const T&);
    friend ostream& operator<<<>(ostream&, const tridiagonalMatrixCol<T>&);
private:
    int n;       
    T* element; 
};
```

​		实现程序。

```c++
template <class T>
T tridiagonalMatrixCol<T>::get(int i, int j) const
{
    if (i < 1 || j < 1 || i > n || j > n) 
        throw matrixIndexOutOfBounds();
    switch (i - j)
    {
    case 0:
        return element[3 * i - 3];
    case 1:
        return element[3 * i - 5];
    case -1:
        return element[3 * i - 1];
    default:
        return 0;
    }
}
template<class T>
void tridiagonalMatrixCol<T>::set(int i, int j, const T& newValue)
{
    if (i < 1 || j < 1 || i > n || j > n) 
        throw matrixIndexOutOfBounds();
    switch (i - j)
    {
    case 0:
        element[3 * i - 3] = newValue; break;
    case 1:
        element[3 * i - 5] = newValue; break;
    case -1:
        element[3 * i - 1] = newValue; break;
    default:
        if (newValue != 0)
            throw illegalParameterValue
            ("nontridiagonal elements must be zero");
    }
}
template<class T>
ostream& operator<<<>(ostream& out, const tridiagonalMatrixCol<T>& m)
{
    /*
    那么列主映射公式为
	① A(xi,xi)=>element[3i-3]，对角没有变化
	② xi-y = 1 , A(xi,y)=>element[3i-5]，原本是左边元素element[3i-4]，现在变成上方元素，故再减1
	③ xi-y = -1，A(xi,y)=>element[3i-1]，原本是右边元素element[3i-2]，现在变成下方元素，故再加1
    */
    for (int i = 1; i <= m.n; i++)
    {
        for (int j = 1; j <= m.n; j++)
        {
            switch (i - j)
            {
            case 0:
                cout << m.element[3 * i - 3] << "  "; break;
            case 1:
                cout << m.element[3 * i - 5] << "  "; break;
            case -1:
                cout << m.element[3 * i - 1] << "  "; break;
            default:
                cout << 0 << "  "; break;
            }
        }
        out << endl;
    }
    return out;
}
```

#### 7.3.2.3 对角映射

​		对角映射是从低对角线到高对角线开始的，即

```c++
5  10  0  0  0
1  6  11  0  0
0  2  7  12  0
0  0  3   8 13
0  0  0   4  9   
```

​		可以看第一个对角线元素的前边会有n-1个元素，最后1个对角线元素后边也有会n-1个元素，所以对角线元素A(xi,xi)是从第n个元素开始的，但是它的索引是n-1，即当i=1时为n-1，那么为element[i+n-2]。

​		然后对角线的左边元素总是和对角线元素差n，所以要-n，即i+n-1-n=i-1，但是索引位置是从0开始的，还要再减去1，即即element[i-2]；从A(xi-1,xi-1)的下方元素看也是一样的，总是比下方多n-1个，即i-1+n-1-(n-1)=i-1，也是element[i-2]；

​		对角线右边元素也和对角线差n，区别是+n，从右边和A(xi+1,xi+1)的上边元素看都是一样的，即i+n-1+n，索引减1即element[i+2n-2]；上方看是i+1+n-1+n-1=i+2n-1；

​		结论：

​		① i  - j = 0 ,A(xi,xi)=element[i+n-2];

​		② i  - j = 1 ,A(xi,yj)=element[i-2];

​		③ i  - j = -1 ,A(xi,yj)=element[i+2n-2];

​		声明程序。

```c++
template<class T>
class tridiagonalMatrixDiag
{
public:
    tridiagonalMatrixDiag(int theN = 10);
    tridiagonalMatrixDiag(T*, const int&);
    ~tridiagonalMatrixDiag() { if (element != NULL) element = NULL; delete[] element; }
    T get(int, int) const;
    void set(int, int, const T&);
    friend ostream& operator<<<>(ostream&, const tridiagonalMatrixDiag<T>&);
private:
    int n;       
    T* element; 
};
```

​		实现程序。

```c++
template <class T>
T tridiagonalMatrixDiag<T>::get(int i, int j) const
{
    if (i < 1 || j < 1 || i > n || j > n)
        throw matrixIndexOutOfBounds();
    switch (i - j)
    {
    case 0:
        return element[i + n - 2];
    case 1:
        return element[i - 2];
    case -1:
        return element[i + 2*n - 2];
    default:
        return 0;
    }
}
template<class T>
void tridiagonalMatrixDiag<T>::set(int i, int j, const T& newValue)
{
    if (i < 1 || j < 1 || i > n || j > n)
        throw matrixIndexOutOfBounds();
    switch (i - j)
    {
    case 0:
        element[i + n - 2] = newValue; break;
    case 1:
        element[i - 2] = newValue; break;
    case -1:
        element[i + 2*n - 2] = newValue; break;
    default:
        if (newValue != 0)
            throw illegalParameterValue
            ("nontridiagonal elements must be zero");
    }
}
template<class T>
ostream& operator<<<>(ostream& out, const tridiagonalMatrixDiag<T>& m)
{
    /*
		① i  - j = 0 ,A(xi,xi)=element[i+n-2];
		② i  - j = 1 ,A(xi,yj)=element[i-2];
		③ i  - j = -1 ,A(xi,yj)=element[i+2n-2];
    */
    for (int i = 1; i <= m.n; i++)
    {
        for (int j = 1; j <= m.n; j++)
        {
            switch (i - j)
            {
            case 0:
                cout << m.element[i + m.n - 2] << "  "; break;
            case 1:
                cout << m.element[i - 2] << "  "; break;
            case -1:
                cout << m.element[i + 2*m.n - 2] << "  ";; break;
            default:
                cout << 0 << "  "; break;
            }
        }
        out << endl;
    }
    return out;
}
```

### 7.3.3 三角矩阵

​		三角矩阵也分为行主映射和列主映射（对角映射不考虑），并具有一定的规律，限于篇幅，只用下三角矩阵进行分析，上三角类似，只是映射公式稍有区别。

#### 7.3.3.1 行主映射

​		分析下方的矩阵。首先下三角矩阵的第i行元素只有i个，且j＞i的位置都是0，总的元素为n(n+1)/2

```c++
1   0   0   0   0
2   3   0   0   0
4   5   6   0   0
7   8   9   10  11
12  13  14  15  16
```

​		其次，分析第1列A(i,1)和element的关系。

​		i = 1 , A(1,1) = element[0] ; 

​		i = 2 , A(2,1) = element[0+1] ; 

​		i = 3 , A(3,1) = element[0+1+2] ; 

​		i = 4 , A(4,1) = element[0+1+2+3] ; 

​		i = 5 , A(5,1) = element[0+1+2+3+4] ; 

​		观察可知，总是满足A(i,1)=element[i(i-1)/2+0]，如果需要找到每行的下一个元素，在满足j≤i时有：

​		A(i,j) = element[i(i-1)/2+j-1]。

​		实现和声明比较简单，不在给出。

#### 7.3.3.2 列主映射

​		首先观察第一列数据，元素位置总是相差1，必然与i有关，即A(i,1)=element[i-1+0]

```c++
	1   0   0   0   0
	2   6   0   0   0
    3   7  10   0   0
    4   8  11  13   0
    5   9  12  14  15
```
​		第1列的规律在其他列肯定也应用到，关键在于如何找到j和element位置的关系。

​		观察不同列之间同行之间依次相差为5-1,5-2,...1，只不过第1行遇到i>j就不再遍历

​		A(i,1) = element[i-1 + 0]

​		A(i,2) = element[i-1 + 4]

​		A(i,3) = element[i-1 + 4+3]

​		A(i,4) = element[i-1 + 4+3+2]

​		A(i,5) = element[i-1 + 4+3+2+1]

​		困难在于如何把0,4,4+3,4+3+2,4+3+2+1和j=1,2,3,4,5联系起来。

​		考虑到是从n-1像前加到1的，所以可以用全部元素和减去在他后面的元素即可。

​		例如4可以看出4+3+2+1-(3+2+1)，4+3+2+1看成4+3+2+1-(0)，0看成4+3+2+1-(4+3+2+1)。

​		可以看出规律是A(i,j)=n(n-1)/2 - f(j)。

​		f(j)依据j=1,开头是4；j=2，开头是3，即n-j，那么后面的元素和应当是(n-j)(n-j+1)/2。

​		所以结论是：

​		A(i,j)=element[i-1+n(n-1)/2 - (n-j)(n-j+1)/2]。

​		

​		如果是上三角矩阵，行主映射，交换下三角矩阵列主映射的i,j位置即可，即完全对称：

​		A(i,j)=element[j-1+n(n-1)/2 - (n-i)(n-i+1)/2]

​		如果是上三角矩阵，列主映射，交换下三角矩阵行主映射的i,j位置即可，即完全对称：

​		A(i,j) = element[j(j-1)/2+i-1]。

### 7.3.4 对称矩阵

​		对称矩阵可以视为三角矩阵，可以利用三角矩阵的表示方法，用大小为n(n+1)/2的数组存储元素。未存储的元素可以使用存储的元素计算。A(j,i)总是可以找A(i,j)，而A(i,j)依照三角矩阵的映射规则找到element相应的索引处即可。

​		以下三角矩阵的行主映射为例，A(i,j) = element[i(i-1)/2+j-1]，因为对称的关系，当j＞i的时候，j的位置其实就是以前i的位置，i同理，所以把表达式改为element[j(j-1)/2+i-1]即可。

​		代码程序如下所示。

```c++
template<class T>
void symmetric_matrix(T* data, const int& n)
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (j < i)
                cout << data[i * (i - 1) / 2 + j - 1] << "    ";
            else
            {
                cout << data[j * (j - 1) / 2 + i - 1] << "    ";
            }
        }
        cout << endl;
    }

}
```

## 7.4 稀疏矩阵

​		稀疏矩阵是无规则的矩阵，一般采取的标准是对于n×n的矩阵，如果非0元素个数小于n^2/3或者n^2/5，就认为矩阵是稀疏矩阵，否则称为稠密矩阵。

​		假设有一个[10000,1000]的矩阵来描述1000名顾客在10000种商品的购买情况，但是实际上每个顾客可能最多购买20种商品，那么只有1000*20个元素是非0元素，其它全部为0，如果这些0全部存储就会造成极大的内存浪费。

​		稀疏矩阵如何来描述呢？对于特殊的对角矩阵、三对角矩阵、对称矩阵都可以使用特殊的类来描述，这是因为矩阵的元素使用使用一维数组存储的时候，二维坐标(i,j)总能找到和element[k]的对应关系。

​		所以稀疏矩阵也使用一维数组来存储时，就必须定义一个结构体，存储有元素的行、列和值3个信息，而一维数组不再是普通的一维数组T * element，而是线性表，只不过这个线性表实例化时每个元素存储的是系数矩阵类型的结构体。

​		假定存储的value是int类型，那么一个结构体元素存储行列和值至少占据8+4字节，那么value总占据12*listSize个字节 ；此外线性表本身的3个私有属性T * element、listSize和arrayLength也占据12字节，即共占据12+8+12*listSize=20+12 * listSize字节；而普通的二维数组，因为二维数组是int (*)[]的指针，指针占据的空间为4 * rows，数组元素为rows * cols * 4个字节，二维数组本身的引用&还占据4字节，共4 * rows(cols + 1)+4。

​		当矩阵比较小时，如4×8的矩阵，有9个非0元素，那么使用线性表需要20+12 * 9 = 128个字节；使用二维数组需要4 * 4 * 9 + 4 = 148字节。看起来还不是很明显，现在忽略指针引用和固定属性占据的空间，对于有20000个非零元素的矩阵，使用线性表需要12 * 20000 = 240000 个字节，而二维数组需要4 * 10000 * 1000 = 40 000 000字节，所以节省的内存成本是巨大的。

### 7.4.1 矩阵元素结构体类型

​		稀疏矩阵结构体的声明和实现如下。

```c++
template <class T>
struct matrixTerm
{
    // 定义一个稀疏矩阵类需要的结构体，这个结构体用于初始化线性表
    // 线性表用于存储这样的结构体元素，每个元素的行列和值
    int row,
        col;
    T value; 
    operator T() const { return value; } // 利用()强制转换类型,可以得到value
};
```

### 7.4.2 存储结构体的线性表

​	 稀疏矩阵类型的线性表在第五章定义的线性表中增加了4个方法，即set、reSet、clear和push_back方法以及=运算符的重载函数，其余的方法和以前完全一致。

​	下方给出声明部分，实现部分只对reSet、set、push_back和=重载方法进行说明，set方法就是检查索引没问题后直接赋值即可，clear就是让listSize=0，push_back是追加1个节点(可能不符合行主映射)，重载=只是增加了一个实例引用并不开辟新内存。

```c++
#include "charter5_linearList.h"
#include "myExceptions.h"
#include <iterator>
#include <sstream>
template<class T>
class sparseMatrixArrayList : public   _charter5_linearList<T>
{
public:
    sparseMatrixArrayList(int initialCapacity = 10);
    sparseMatrixArrayList(const sparseMatrixArrayList<T>&);
    ~sparseMatrixArrayList() { if (element != NULL) element = NULL; delete[] element; }
    bool empty() const { return listSize == 0; }
    int size() const { return listSize; }
    int capacity() const { return arrayLength; }
    sparseMatrixArrayList<T>& operator = (const sparseMatrixArrayList<T>&);
    T& get(int ) const;
    int indexOf(const T& ) const;
    void erase(int );
    void insert(int , const T&);
    void output(ostream&) const;

    // 对稀疏矩阵类线性表新增加的新方法
    void reSet(int);
    void set(int, const T&);
    void clear() { listSize = 0; }
    void push_back(const T&);

    // 完整的线性表具有迭代器的功能
    class iterator;
    iterator begin() { return iterator(element); } // element指向线性表开头
    iterator end() { return iterator(element + listSize); }// 指向线性表结尾
    class iterator
    {
    public:
        typedef std :: bidirectional_iterator_tag iterator_category;
        typedef T value_type;
        typedef std:: ptrdiff_t difference_type;
        typedef T* pointer;
        typedef T& reference;
        iterator(T* thePosition = 0) { index = 0; position = thePosition; }//位置是指针类型 唯一的构造函数
        // 迭代器有解引用功能需要重载,得到迭代器指向的结构体元素
        T& operator*() const { return *position; }
        T* operator->() const { return &*position; }
        operator int() const { return index; }; // 得到指向的整数索引位置

        iterator& operator++()   //++operator 
        {
            ++position; index++; return *this;//先＋后返回
        }
        iterator operator++(int) // operator++
        {
            iterator old = *this; // 表达式的值还是之前的
            ++position; // 后+
            index++;
            return old;
        }
        iterator& operator--()   // --operator
        {
            --position; index--; return *this;
        }
        iterator operator--(int) // operator--
        {
            iterator old = *this;
            --position;
            index--;
            return old;
        }

        // !=重载
        bool operator!=(const iterator right) const
        {
            return position != right.position; // 迭代器是否相等转为位置是否相等
        }
        bool operator==(const iterator right) const
        {
            return position == right.position;
        }
    protected:
        T* position; // 位置指针 私有属性
        int index;
    };  

protected:
    void checkIndex(int theIndex) const;
    void changeLength1D(T*& pa, int oldLength, int newLength); // 指针的引用
    T* element;            
    int arrayLength;       
    int listSize;
};
```

​		reSet方法：

```c++
template<class T>
void sparseMatrixArrayList<T>::reSet(int theSize)
{
    if (theSize < 0)
    {
        ostringstream s;
        s << "Requested size = " << theSize << " Must be >= 0";
        throw illegalParameterValue(s.str());
    }

    if (theSize > arrayLength) // 需求比容量大,不调用changeLength1D,直接new即可
    {
        delete element;
        element = new T[theSize];
        arrayLength = listSize;
    }
    listSize = theSize;
}
```

​		set方法：

```c++
template<class T>
void sparseMatrixArrayList<T>::set(int theIndex, const T& newValue)
{
    checkIndex(theIndex);
    element[theIndex] = newValue;
}
```

​		push_back方法：

```c++
template<class T>
void sparseMatrixArrayList<T>::push_back(const T& theElement)
{
    if (listSize == arrayLength)
    {
        changeLength1D(element, arrayLength, 2 * arrayLength);
        arrayLength *= 2;
    }
    T value = theElement;
    element[listSize] = theElement;
    listSize++;
}
```

​		运算符重载：不同于复制构造，并没有开辟内存，只是把引用指向改变。

```c++
sparseMatrixArrayList<T>& operator = (const sparseMatrixArrayList<T>&); // 声明
template<class T>
sparseMatrixArrayList<T>& sparseMatrixArrayList<T>::operator=(const sparseMatrixArrayList<T>& theList)
{
    //sparseMatrixArrayList<T> newList(theList); // 不要利用复制构造,会使用新内存
    arrayLength = theList.arrayLength;
    listSize = theList.listSize;
    element = theList.element; // 是引用
    return *this; // 返回自己
}
```

### 7.4.3 稀疏矩阵类

​		声明部分如下，结构体类型和存储该结构体的线性表作为一个基础，将T * element普通数组存储改为使用线性表存储。

```c++
#include <iostream>
#include "charter7_sparseMatrixTerm.h"
#include "charter7_sparseMatrixArrayList.h"
#include "charter6_point2D.h"
#include "myExceptions.h"
template<class T>
class sparseMatrix
{
    friend ostream& operator<<<>
        (ostream&, sparseMatrix<T>&); // 用于输出的友元函数,可以访问私有属性
    friend istream& operator>><> // 和<<类似
        (istream&, sparseMatrix<T>&);//输入流同理
public:
    sparseMatrix() { rows = 0; cols = 0; };
    sparseMatrix(const int&, const int&, const int&, _charter6_point2D<int> * , T*);
    int nonZeroNum() { return terms.size(); };
    int capacity() { return terms.capacity(); };
    sparseMatrix<T>&  operator =(const sparseMatrix<T>& );
    T operator () (const int & , const int &) ; // ()用于访问并返回值
    void transpose(sparseMatrix<T>&); // 稀疏矩阵的转置(不改变内存)
    void t(sparseMatrix<T>&);
    void add(sparseMatrix<T> , sparseMatrix<T>& ); // 定义了稀疏矩阵的+法
    void append(const matrixTerm<T>&); // 追加1个元素
private:
    int rows,   
        cols;   
    sparseMatrixArrayList<matrixTerm<T>> terms; // 使用线性表存储
    // 注：这里使用行主映射来存储
};
```

​			实现部分不在具体给出，详细的代码见<charter7_sparseMatrix.h>头文件中，相应的测试代码见<charter7_17稀疏矩阵.cpp>文件中。

### 7.4.4 链表稀疏矩阵类

​		除了可以使用线性表来存储稀疏矩阵的元素，也可以使用链表来存储。线性表是利用sparseMatrixArrayList<matrixTerm<T>> 定义的terms来存储，存储的数据实际上就是在一维数组element中存储，由于matrixTerm是个结构体，所以它内部必须定义一个强制转换类型的函数，才能被存储到element当中，这一步是非常关键的，如下方代码所示。

```c++
operator T() const { return value; };
```

​		现在使用链表储存，其实就是二维数组，只不过不是普通的二维数组，而是链式二维数组。二维数组使用一个链表作为元素的链表l来描述，也就是头节点链表headChain，这个属性被定义在链表稀疏矩阵类中。

​		稀疏矩阵类的声明如下，相比于原书的代码，去除了对>>的重载(因为书上的目的就是为了通过>>来得到1个测试数据罢了)，直接增加1个构造函数，需要行、列和headChain类型的引用。同时更改了>>函数，把原书>>的类似的代码放在output中，并修改了部分代码，使之可以打印元素的行、列和值信息。自定义的>>函数可以直接打印整个矩阵的元素，而不是描述式信息，更容易观察，为此必须定义一个访问矩阵信息的()操作符重载，这样可以访问指定行列的元素值。

```c++
template<typename T>
class linkedMatrix
{
    friend ostream& operator<<<> (ostream&, linkedMatrix<T>&);
public:
    linkedMatrix() { rows = 0; cols = 0; };
    linkedMatrix(const int&, const int&,linkedMatrixChain<rowLinkedList<T>>&) ;
    ~linkedMatrix() {};
    T operator() (const int & , const int &) ;
    void transpose(linkedMatrix<T>& b);
    void output();
private:
    int rows,      
        cols;      
    linkedMatrixChain<rowLinkedList<T> > headerChain;
    // headerChain[i]为行链表结构体,headerChain[i].rowChain[j]为行链表元素结构体
};
```

#### 7.4.4.1 稀疏链表类

​		稀疏矩阵类的属性headChain就是一个链表，它的依赖是头文件<charter7_linkedMatrixChain.h>，而这个头文件依赖于<_charter5_linearList.h>。原书直接使用的该抽象类的具体类<charter6_chainListWithIteratorExtend.h>，但是有一些缺陷，这个头文件虽然重写了insert、erase函数，也增加了push_back、zero、clear函数，但是类名太长不方便，且是继承自具体类<charter6_chainListWithIterator.h>的拓展。所以直接在<charter7_linkedMatrixChain.h>把这两个第六章的头文件函数直接合并，去除复杂的逻辑，并增加了运算符=的重载。

​		为什么要增加运算符=的重载，因为在linkedMatrix的构造函数中使用了如下代码。虽然this->headerChain = headerChain确实很省事，但是链表并没有=这个重载，所以重新定义

```c++
template<typename T>
linkedMatrix<T> ::linkedMatrix(const int& rows, const int& cols,
    linkedMatrixChain<rowLinkedList<T>>& headerChain)
{
    for (typename  linkedMatrixChain<rowLinkedList<T>>::iterator itRow = headerChain.begin();
        itRow != headerChain.end(); itRow++)
    {
        if ((*itRow).row <= 0 || (*itRow).row > rows)
            throw matrixIndexOutOfBounds("some matrix elements'row are out of bound");
        for (typename linkedMatrixChain<rowLinkedListElement<T>>::iterator itCol = (*itRow).rowChain.begin();
            itCol != (*itRow).rowChain.end(); itCol++)
        {
            if ((*itCol).col <= 0 || (*itCol).col > cols)
                throw matrixIndexOutOfBounds("some matrix elements'col are out of bound");
        }
    }
    this->rows = rows;
    this->cols = cols;
    this->headerChain = headerChain;
}
```

​		运算符=重载的函数在<charter7_linkedMatrixChain.h>已经给出，如下所示，其实和复制构造的代码一模一样。

​		区别在于这里要返回自身，即*this。

```c++
template<class T>
linkedMatrixChain<T>& linkedMatrixChain<T> :: operator = (const linkedMatrixChain<T>& theList)
{
	listSize = theList.listSize;
	if (listSize == 0) { firstNode = NULL; return *this; }
	_charter6_chainNode<T>* sourceNode = theList.firstNode;
	firstNode = new _charter6_chainNode<T>(sourceNode->element);
	sourceNode = sourceNode->next;
	_charter6_chainNode<T>* targetNode = firstNode;
	while (sourceNode != NULL)
	{
		targetNode->next = new _charter6_chainNode<T>(sourceNode->element);
		targetNode = targetNode->next;
		sourceNode = sourceNode->next;
	}
	targetNode->next = NULL;
	return *this;
}
```

​		<charter7_linkedMatrixChain.h>其它的函数和第六章链表的函数实现都是一样的，不再赘述。

#### 7.4.4.2 稀疏链表的结构体元素

​		headChain是头链表，rowChain是行链表。其中headChain的元素是一个带有col和rowChain属性的结构体。而rowChain的元素是一个带有col和value属性的结构体。由于这两个结构体要成为稀疏链表类的元素，所以必须带有<<函数的重载，否则对稀疏链表使用cout<<打印时候，程序是不知道如何打印这样的结构体的，因为稀疏链表的output函数定义的是cout<< firstNode->element。这个firstNode的element被T实例化为结构体类型，也就是打印element就是打印结构体，所以没有这样的<<重载函数就会报错。

​		这2个结构体的定义如下，其中行链表有私有属性row和rowChain，而rowChain的元素就是第一个定义的结构体rowLinkedListElement。

```c++
template<class T>
struct rowLinkedListElement
{
    int col;
    T value;

    bool operator !=(const rowLinkedListElement<T>& y)
    {
        return (value != y.value); // 结构体比较转为value比较
    }
    int getCol() const { return col; } // 必须加const
    T getValue() const { return value; }
};
// 必须要有<<函数否则会编译报错没有与 "charter6_chainListWithIterator.h"<<对应的转换
// 因为链表的<<函数打印的是currentNode->element,而currentNode是chainNode类型
// chainNode有个T element,这里的T 其实就是rowLinkedListElement类型,那么打印element是不知道什么意思的
// 因为element是个结构体不是一个数,所以结构体定义的时候就必须给出<<该结构体的方法
template<class T> 
ostream& operator<<(ostream& out, const rowLinkedListElement<T>& x)
{
    out  <<"col("<< x.getCol() << ") = " << x.getValue() << " "; 
    return out;
}

// 头节点结构体,它的数据域有row和row存储的元素rowLinkedListElement,这样的元素用相应的链表存储
// 同理这也是个结构体,打印这样的结构体时也必须给出相应的重载方法
template<class T>
struct rowLinkedList
{
    int row;
    
    linkedMatrixChain<rowLinkedListElement<T> > rowChain;

    bool operator !=(const rowLinkedList<T>& y)
    {
        return (row != y.row); // 转为是否相同行
    }
    int getRow() const { return row; }
};
template<class T>
ostream& operator<<(ostream& out,const rowLinkedList<T>& x)
{
    // << x.rowChain 调用的就是out  <<","<< x.getCol() << " ) = " << x.getValue() << endl;
    out << "\nrow(" << x.getRow() << ")：";
    out<<x.rowChain; 
    return out;
}
```

#### 7.4.4.3 链表稀疏矩阵的转置和<<

​		关于<<重载函数，这是基于已经重载()函数的情况实现的。

```c++
template<class T>
ostream& operator<<<>(ostream& out, linkedMatrix<T>& x)
{
    for (int i = 1; i <= x.rows; i++)
    {
        for (int j = 1; j <= x.cols; j++)
            out << x(i, j) << "  ";
        out << endl;
    }
    return out;
}
```

​		()函数的重载实现如下。

```c++
template<class T>
T linkedMatrix<T> :: operator () (const int& row, const int& col) 
{
    if (row < 1 || col < 1 || row > rows || col > cols) 
        throw matrixIndexOutOfBounds();
    typename linkedMatrixChain<rowLinkedList<T> >:: iterator it = headerChain.begin();
    typename linkedMatrixChain<rowLinkedList<T> >:: iterator itEnd = headerChain.end();
    while (it != itEnd)
    {
        int r = it->getRow();
        if (row != r) //没有这个行坐标的元素
            it++;
        else
        {
            typename linkedMatrixChain<rowLinkedListElement<T> >::iterator rt = it->rowChain.begin();
            typename linkedMatrixChain<rowLinkedListElement<T> >::iterator rtEnd = it->rowChain.end();
            while (rt != rtEnd)
            {
                int c = rt->getCol();
                if (col != c)
                    rt++;
                else
                {
                    return rt->getValue();
                }
            }
            if (rt == rtEnd) // 有这行没这列
                return 0;
        }
    }
    if (it == itEnd)// 没有找到这行返回0
        return 0;
}

```

​		然后就是转置，转置其实就是做4件事情，就可以实现转置。

​		① 把存储的每个元素的属性值要修改,即这个元素的col要改成row
​		② 转置矩阵b的私有属性cols和rows交换 ,b.rows = cols && b.cols = rows
​		③ 拿到转置后的头链表,恰好是*this的第1行的所有非0元素的地址(原本是每行的首个非0元素地址),不同的列放入不同的箱子bin[col]中，后面取出来即可
​		④ 存储行链表的头链表的属性值也要修改,即row改成col，同时每个行链表元素rowChain指向对应的箱子 bin[c]

​		如果不能理解，请看一个例子，假设有个矩阵为：

```c++
[0,0,1,2,4,0]
[0,5,9,6,10,0]
[0,13,17,9,3,0]]
属性值：rows = 3, cols = 6 , 使用的箱子大小bin[6+1] (只用到1,2,3,4,5,6)
```

​		对这个矩阵执行的操作为(transpose函数的部分代码)：

```c++
// 转置的矩阵放在b里边
b.headerChain.clear(); 
b.rows = cols;
b.cols = rows;
linkedMatrixChain<rowLinkedListElement<T> >* bin; // 1个指向行链表类型的指针,元素是结构体
bin = new linkedMatrixChain<rowLinkedListElement<T> >[cols + 1]; // 行列表有cols个元素
typename linkedMatrixChain<rowLinkedList<T> >::iterator // 定义行链表的链表的迭代器
    ih = headerChain.begin(),
ihEnd = headerChain.end(); // 由于遍历自身矩阵的每个行链表

while (ih != ihEnd) // 遍历行
{
    int r = ih->getRow(); //每个行链表都有属性row
    typename linkedMatrixChain<rowLinkedListElement<T> >::iterator // 定义当前行链表的迭代器
        ir = ih->rowChain.begin(), 
    irEnd = ih->rowChain.end();
    rowLinkedListElement<T> x; // 用于存放当前行链表遍历的元素
    x.col = r; // 转置的第1步是先交换行列的坐标
    while (ir != irEnd) // 遍历当前行链表的每列
    {
        x.value = ir->getValue(); // ir是当前列的元素值
        bin[ir->col].push_back(x); // 循环结束在bin[col]会存储*this每列的所有元素.且元素已经交换过行列
        // bin[ir->col]最开始的那个就是行链表的头节点,这是需要被存储的地址,后面元素已经自动链接
        ir++;  
    }
    ih++; 
}
```

​		每行进行循环，再对当前行的每列循环，当前行 遇到的所有非0元素的属性col都改成当前行，值也保存，这些是定义一个临时的结构体来保存col和value值，再用对应的列箱子(遇到的元素是col列,就用bin[col]来存)来反复push_back这个临时结构体。所以可能有的bin[col]根本没用上，用上的箱子相当于把* this的col列元素全部拿到，而bin[col]恰好就是* this 第1行的所有非0元素的地址，也就是转置后的头链表，比如上边的矩阵。

​	那么bin的结果就是
​    bin[1]和bin[6]没有元素,bin[0]是用不到的,这也是为何bin申请的是cols+1的内存
​    bin[2]：                           (col=2,value=5),(col=3,value=13)
​    bin[3]：(col=1,value=1),(col=2,value=9),(col=3,value=17)
​    bin[4]：(col=1,value=2),(col=2,value=6),(col=3,value=9)
​    bin[5]：(col=1,value=4),(col=2,value=10),(col=3,value=13)

​	bin[2],bin[3],bin[4],bim[5]就是新的转置矩阵有的头链表，之后就是赋值操作拿出来即可，也是借助一个临时的行链表。最后要注意临时行链表要清空，且箱子也要清空。

```c++
rowLinkedList<T> h;
for (int c = 1; c <= cols; c++)
    if (!bin[c].empty()) // 有的列可能都是0元素先判断
    {
        // h赋予不同的值然后b.headerChain 添加即可
        h.row = c;
        h.rowChain = bin[c]; // 从箱子拿出来
        b.headerChain.push_back(h);
        bin[c].zero(); // 取出了1个给h就删掉
    }
h.rowChain.zero();   // h用完了就没用了
delete[] bin;
```

本章结束~！
