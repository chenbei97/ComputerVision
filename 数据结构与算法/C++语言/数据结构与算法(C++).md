## 1.C++回顾

​	前言部分和第一章的大部分内容不再详细说明，只从第一章的末尾测试与调试开始

### 1.1测试的概念

​	何谓测试？测试的目的是为了检测程序的错误而非正确，测试数据的不同对程序的正确性的检验有很大的影响。

​	测试有2种方法，一种是已知期望的结果，然后比对程序运行的结果；一种是程序运行的结果是否满足另一个必须满足的条件。例如以解二次方程x^2-5x+6=0为例，第一种方法是期望的结果为2、3，检验是否成立；第二种方法是通过公式计算出来结果后，带入检验方程是否等于0的强条件。

​	测试至少要求实现语句覆盖，对一个指定长度n的数组排序还要检验特殊情形，如n=0,1或者<0的情况，如果有边界n=100，也要测试n=100的情况。

### 1.2测试数据的设计

​	测试数据如何设计呢？主要有2种方法，黑盒测试法和白盒测试法。

​	前者考察的是程序功能，满足功能即认为正确，但是代码未必是正确的，可能是以某种方式恰好符合了这样的期望结果。最常用的黑盒法是I/O分类和因果图，这里只讨论I/O分类。以二次方程求解为例，任意方程的输出结果无非3种情况：不相等的实数根、相等的实数根以及共轭的复数根。那么测试数据至少就应当包含这3类情况的每一种，例如某组测试数据为二次方程系数的三元数组(a,b,c) = {(1,-5,6),(1,-8,16),(1,2,5)}对应的解分别是实数根2、3，实数根4、4，复数根-1±2i，就可以覆盖以上的所有情况。

​	后者考察的是程序代码，测试数据必须能够全面覆盖所有程序。覆盖包括**<u>语句覆盖和分支覆盖</u>**，语句覆盖是所有代码都可以执行一次；分支覆盖是所有条件判断都可以取到true或者false执行一次。

​	对分支覆盖进行加强还可称为**<u>从句覆盖</u>**，即要求每个条件的从句都要出现true或者false的情况。如下所示c1、c2、c3、c4称为从句，而s1、s2是语句。分支覆盖的要求是整个条件(c1 && c2)||(c3 && c4)应当出现true和false，而从句覆盖是要求4个从句c1、c2、c3、c4都可以至少出现一次true和false。

​	按照某个测试集执行程序会得到不同的语句执行路径，简单的程序**<u>执行路径覆盖</u>**和语句覆盖、分支覆盖和从句覆盖都是等价的，如下方的二次方程求根的程序；而找到数组最大值坐标的执行路径个数，随着n的增加成指数增加，即2^n条执行路径，此时执行路径覆盖是很难实现的，测试集需要拥有任意长度n的数组数量。执行语句覆盖一般也能实现语句和分支覆盖，当分支覆盖和从句覆盖等价时也实现了从句覆盖。

```c++
if ((c1 && c2)||(c3 && c4))
    s1;
else
    s2;
```

### 1.3测试程序举例

​	具体代码文件见配套的<charter2_01测试与调试.cpp>，注意使用复数complex可以接收相应的复数结果

​	下方的程序是计算二次方根的，测试函数为_charter2_test_and_debug，计算函数为quadratic_equation_find_root

```c++
#include "charter2.h"
#include <complex>
typedef std::complex<double>dcomplex; // 对double的情况使用别名
void quadratic_equation_find_root(const double & a , const double &b ,const double &c, dcomplex& x1, dcomplex& x2);
void _charter2_test_and_debug()
{
	double a = 1, b = -5, c = 6;
	dcomplex x1, x2;
	quadratic_equation_find_root(a, b, c, x1, x2);
	a = 1, b = 2, c = 5;
	quadratic_equation_find_root(a, b, c, x1, x2);
}
void quadratic_equation_find_root(const double& a, const double& b, const double& c , dcomplex & x1, dcomplex & x2 )
{
	if (a == 0)
		throw("a should be ≠ 0");
	double delta = b * b - 4 * a * c; // b^2-4ac
	double k = -b / (2 * a);
	if (delta > 0) // 两个不同实数根
	{
		double d = sqrt(delta) / (2*a);
		x1 = k + d;
		x2 = k - d;
	}
	else if (delta == 0)
	{
		// 两个相同实数根
		x1 = x2 = k;
	}
	else
	{
		// 共轭复根
		dcomplex d(0, sqrt(-delta) / (2 * a));
		x1 = k+d;
		x2 = k-d;
	}
	std:: cout << "x1 = " << x1.real()<<" + " <<x1.imag()<<"i"<< 
		"   x2 = " << x2.real()<<" + "<<x2.imag()<<"i" << std::endl;
}
```

​	下方是查找数组最大值所在的位置函数，如果是无顺序的数组a[5]={0,1,2,3,4}这样的数据在分支覆盖中不满足，因为不存在a[loc]>a[i]的情况，而测试语句中使用的可以满足语句覆盖也能满足分支覆盖。

```c++
template<class T>
int find_maxval_loc_in_array(T a[], int n);
// _charter2_test_and_debug中的测试语句
int d[6] = { 0,9,20,44,3,17 };
int loc;
loc = find_maxval_loc_in_array(d, sizeof(d) / sizeof(d[0]));
// _charter2_test_and_debug中的测试语句
// 函数实现
template<class T>
int find_maxval_loc_in_array(T a[], int n)
{
	if (n <= 0)
		throw("n must be > 0");
	int loc = 0; // 最大位置初始化为第1个元素的索引0
	for (int i = 1; i < n; i++)
	{
		if (a[loc] < a[i])
			loc = i; // 更新最大值索引位置
	}
    std::cout << "maxval index = " << loc << std::endl;
	return loc;
}
```

## 2.程序性能分析

### 2.1空间和时间复杂度

#### 2.1.1空间复杂度

​	空间复杂度需要的空间总体分为**<u>固定部分和可变部分</u>**。固定部分主要分为**<u>指令空间和数组空间</u>**的简单变量空间和常量空间；可变部分是指**<u>环境栈空间</u>**，可以是动态分配的空间也可以是递归函数使用的递归栈空间。

​	指令空间取决于

- 编译器的性能
- 编译器的选项
- 目标计算机

​	例如编译器需要的内存可能是不同的，1MB或者4MB；编译器的选项可以使用优化模式，这可能在程序中利用知识简化运算，也可以使用覆盖模式，此时读取的代码模块并不是分配在新内存上而是覆盖，这样程序所需要的空间是最大模块所需要的空间，而不是所有模块需要的空间之和；计算机的配置也有较大影响，装有浮点处理的硬件可以把每个浮点操作转为一条机器指令，否则需要生成代码模拟浮点操作。

​	数据空间一般和计算机的字长有关，一个字可以是2字节、4字节也可以是8字节，一个字节等于8位，现在64位的计算机就是指一个字有8字节。以32位计算机为例，不同数据类型占据不同的空间，如下表所示。

|      类型      | 空间大小(字节数) |             范围              |
| :------------: | :--------------: | :---------------------------: |
|      bool      |        1         |          true,false           |
|      char      |        1         |          [-128,127]           |
| unsigned char  |        1         |            [0,255]            |
|     short      |        2         |        [-32768,32767]         |
| unsigned short |        2         |           [0,65535]           |
|      long      |        4         |        [-2^31,2^31-1]         |
| unsigned long  |        4         |          [0,2^32-1]           |
|      int       |        4         |        [-2^31,2^31-1]         |
|  unsigned int  |        4         |          [0,2^32-1]           |
|     float      |        4         |         ±3.4E±38(7位)         |
|     double     |        8         |        ±1.7E±308(15位)        |
|  long double   |        10        |       ±1.2E±4392(19位)        |
|    pointer     |        2         | near, _cs, _ds, _es, _ss 指针 |
|    pointer     |        4         |         far、huge指针         |
|                |                  |                               |

​	一个结构变量的空间大小是结构成员所需空间大小之和，一个数组也是所有成员空间大小之和。

​	关于空间复杂度的大致区分如下图所示。

![](D:\VisualStudioItems\数据结构与算法\空间复杂度.jpg)

​	如何使用实例特征估计空间复杂度？请看以下几个例子

​	例1：顺序查找，在数组中从左到右查找第一个与x相等的元素，找到返回它第一次出现的位置，否则返回-1

​	n是数组顺序查找的实例特征，形参a、x、n，常量0、1和代码需要空间，这是独立于实例特征的固定空间大小，它们不依赖于n。所以空间复杂度s(n)=0。

```c++
template<class T>
int sequantialSearch(T a[], int n , const T &x)
{
    int i ;
    for (i = 0; i < n && a[i] != x; i++); // 空循环 
    if (i == n) // 如果循环都走完了还没找到就返回-1
        return -1;
    else return i; // 找到时循环会终止 此时返回对应的i
}
```

 例2：第1个程序是递归函数对数组元素进行求和，n=0时为0，n＞0时进行计算；第2个程序是普通循环对数组元素求和。

​	a、n也是形参，但是递归函数的形式参数和返回地址的空间需要存储，对于a是一个指针(4字节)、n是int也是4字节、返回的地址假定也是4字节，那么每次递归调用需要12字节的递归栈空间。由于递归深度为n+1，所以共需s(n)=12(n+1)字节的栈空间。而后者函数只是分配一些固定空间，theSum、i以及常数0的空间与n无关，s(n)=0。

```c++
template<class T>
T rSum(T a[],int n)
{
    if(n>0)
        return rSum(a,n-1)+a[n-1];
    return 0;
}
template<class T>
T sum(T a[], int n)
{
    T theSum = 0;
    for(int i =0 ; i<n;i++)
        theSum += a[i];
    return theSum;
}
```

​	例3：也是递归函数，不过是求阶乘，根据n和1的关系，递归深度是max(n,1)，每次递归返回的地址和n都是4字节，所以s(n)=8*max(n,1)，其它不依赖于n

```c++
int factorical(int n)
{
    if (n<=1) return 1;
    else return n*factorical(n-1);
}
```

#### 2.1.2时间复杂度

​	时间复杂度=编译时间和运行时间。编译时间与实例特征无关，程序编译后可以多次运行；运行时间取决于操作次数与操作类型花费时间的和。例如加减乘除的花费时间是不同的，通过计算程序这些操作的次数，再乘对应的时间即可。

​	但是这样估计运行时间是不精确的，因为四则运算浮点数和整型数花费的时间又是不同的，还与操作对象数据类型有关；当前计算机还可能是多线程的，可以同时处理一个整数操作和一个浮点数操作，并非顺序执行；算术操作流水线和存储等级也使得m次操作的时间未必是m倍的单次操作时间。

​	一般估计程序运行时间的方法是：找到一个或几个关键步骤花费的时间，然后确定程序的总步数，相乘即可得到偏大的运行时间。