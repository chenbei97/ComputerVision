-----------2022.1.15-----------
今天周五，把栈的pop、push和top使用数组和链表的方式搞定~
-----------2022.1.17-----------
玩了两天没学习，解决了汉诺托和括号匹配问题~
-----------2022.1.18-----------
艹，因为先要把之前的代码文件按照章节整理，但是readme.txt忘了保存，以前的学习记录没了，从现在重新开始
对前几天的学习记录还有印象，补了几天
今天把第八章结束，学习栈在车厢重排、开关盒布线上的应用，其中开关盒布线感觉有些问题~~，暂时留给以后解决
明天将开启第九章：队列的数据结构~
-----------2022.1.19-----------
今天给队列的具体类的push函数打了log，大体上了解了代码的实现
队列是插不满的，总是留一个，theFront在测试代码中依次为0、7、15以及31，theFront指向的内存总是没有用到
也就是没有插满之前总是满足2*arrayLength-1，当arrayLength=0时,没有意义，所以指定theFront=0,此时queue是从下标1开始用的
theBack依次为0、1、2、[3、2、3]、4、5、[6、6、7]、8、9、10、11、12、13、[14、14、15]、
16、17、18、19、20、21、22、23、24、25，总是在插满之前theBack重新赋值为arrayLength-2，所以除了[3、2、3]之外总是重复2次arrayLength-2
原因在于queue最开始用的下标是[1，arrayLength-1]，然后复制到newQueue的[0，arrayLength-1-1]
之后还是在arrayLength-1的位置上插入元素，所以对newQueue已经是插满arrayLength个了
此时queue更改指向newQueue，之后的问题就简单了，重复到不够用就拓展2倍容量
不过以上是在队列没有进行过pop的情况规律，theFront是容量不够自动变为2*arrayLength-1
如果在push的过程中有过pop，那么问题就比较复杂，theFront会从0变成1或者2，而不是7，这个问题明天讨论
-----------2022.1.20-----------
今天把数组描述的队列解决的比较完善了，程序没有问题，明天把md文档更新完。
-----------2022.1.21-----------
今天没写代码，一直在写md文档，把数组描述的队列用比较der的人话描述了一遍
又要周末了，这周没带书，太累了，想换换脑子写写python
-----------2022.1.24-----------
由于md文档写的不够清楚，昨天做梦的时候想明白了整个逻辑，重新总结了一下队列的设计过程以及output函数。
因为栈的应用还有个迷宫老鼠，最近看到这个能看懂，所以今天补了一下这部分内容，更新栈的md文档和C++文件
-----------2022.1.25-----------
研究不借助栈和队列怎么重排车厢
-----------2022.1.26-----------
上午回归对比了栈和队列重排车厢的区别，发现关键在于栈插入元素是在top，缓存栈的top()是可能的最小车厢编号，缓存栈之间更小的top是bestTop。
缓存队列的front()是最小的车厢编号，但是因为队列插入元素是在back，所以比较更合适的缓存队列时其实是比较back()谁更大，越大的越接近输入车厢编号nextCar
下午继续解决了没有栈、队列如何实现的逻辑，并对代码加以修改，补全了md文档的分析，告一段落，明天的队列应用问题是电路布线问题。
-----------2022.1.27-----------
今天上午在工作，处理了焊接的bom表，下午把电路布线问题解决了，还是比较完美的，明天周五咯
-----------2022.1.31-----------
1.29在公司学习，基本上把队列的应用问题过完，工厂仿真问题总体比较复杂，讲不清楚，所以暂时就跳过。
因为后边还有更重要的知识没学完，某个具体问题如果看不懂就暂时不深究转牛角尖了，浪费时间
昨天是玩了一下午联盟，回家了，今天是除夕，准备学一点跳表和散列的知识
