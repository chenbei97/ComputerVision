持续更新中

 ---------2021.12.15-------------
更新完《数据结构、算法与应用C++语言描述》前两章  

-----------2021.12.23-------------
前一阵工作忙加上DataWhale的任务没有继续，今天开始第三章渐近记法

-----------2021.12.23-------------
第3章和第4章都是概念，相对比较简单，今天一天更完，第一部分结束，接下来是第二部分5-16章，内容非常多

-----------2021.12.26-------------
更新到第5章的5.3.3 类arrayList，主要是关于如何创建一个数组描述的线性表的抽象类和具体类，已经学习完毕

-----------2021.12.27-------------
今天周一，开始继续5.3.4，C++迭代器的实现

-----------2021.12.28-------------
昨天把第5章结束，学习了抽象类基于数组和vector的具体类实现
今天继续第6章，线性表的链式描述

-----------2021.12.29-------------
链式描述昨天把不带迭代器的单向链表类全部理解吃透，今天学习完带迭代器和类的拓展，就可以到循环链表了
下午4.33：没毛病，总算搞定了拓展类的继承问题，循环链表也结束了，明天是双向链表，希望放假前把第6章能结束

-----------2021.12.30-------------
花了一上午，把单向链表关于插入的部分又捋清了概念，之前理解的有些问题，头插和不头插是不一样的。
对于单向链表firstNode初始化指向NULL，第1次头插会以firstNode本身构建新节点，也就是更新firstNode让它等于构建的新节点，程序是指针赋值操作，它们是1个东西
第2次头插还是用firstNode构建,只是此时它不指向NULL了而是之前创建的新节点,再次更新firstNode等于现在新构建的节点,依然是一个东西，所以整个链表并没多出1个节点
如果不是头插，p指针总是运行到插入位置的上一个，并用p->next信息构建新节点，同时更新当前的p指向这个新节点，firstNode不会有任何影响

循环链表的headerNone和firstNode不是一个含义，headerNone是一个独立的东西(初始化指向自己),整个链表确实多了1个节点
如果是头插不会执行for遍历
第1次头插让headNode指向创建的头插节点(这个节点是用headNode->next构建的,此时它还是指向自身)
第2次头插headNode指向新创建的头插节点(这个节点是用headNode->next构建的,此时它已经指向前1个创建的节点) heardNode->n1->n0->headNode以此类推
如果不是头插,插入的位置index会执行index次，但是依然到达的是index的上一个节点位置，为什么呢？因为headNode是真的1个节点,p指向headNode的,所以执行index次还没到达index节点
之后就简单了,用p->next构建index节点，再让p指向这个新构建的节点
特别的如果取到了listSize,p就是listSize-1的节点,p->next在一开始头插的时候已经指回了headNode,所以使用p->next构建的新节点作为尾节点依然指回headNode，还是循环链表

-----------2021.12.31-------------
昨天快下班出现的问题是一个头文件"charter6_myStudentRecords.h"定义了多个结构体，现在用两个代码文件分别测试其中的2给个结构体，都在文件中包含了这个头文件
编译出现错误，重定义的错误。解决方法是每个结构体都分别定义在1个头文件中，即"charter6_studentRecord1.h"包含struct _charter6_studentRecord1
"charter6_studentRecord2.h"包含struct _charter6_studentRecord2，"charter6_studentRecord.h"包含struct _charter6_studentRecord

-----------2022.1.1-------------
今天系统性的解决了箱子排序的原理，以及作为链表成员实现和普通实现的区别，goodjob~~

-----------2022.1.2-------------
搞清了基数排序和箱子排序的关系，并更新了markdown文件

-----------2022.1.3-------------
解决了凸包问题，并查集问题较为困难，等以后合适的机会再去理解，第六章已经结束

-----------2022.1.4-------------
开始到第7章，准备矩阵的知识

-----------2022.1.5-------------
工作有点事，基本没看书

-----------2022.1.6-------------
解决了friend友元函数、普通函数和类内函数的区别，并测试代码提供了解决外部链接错误的方案
对矩阵做乘法，如果是2个矩阵T**类型的，乘法是很简单的，但matrix类使用的一维数组进行存储
所以计算每行和每列的元素相乘时还要找到对应的一维数组的位置
行主映射，每行的元素遍历，就需要跳到下1个地址即可，每列的元素遍历要跳过1行
矩阵乘法A*B,要注意是从(1,1)开始索引的,但是element存储是从0索引开始的
矩阵乘法的结果是A.rows * B.cols,且A.cols == B.rows
for (int i = 1 ; i <= A.rows; i++) 
  for (int j = 1; j <= B.cols; j++)
  {
     T sum = 0
     for ( int k =2 ; k<= A.cols; k++) // 遍历A.cols-1次
     ....
  }
    

-----------2022.1.7-------------
解决了矩阵的转置问题，同样2个矩阵直接转置不困难，m!=n时只需要调整分配的内存空间即可
但是matrix类实现的话，要映射到一维数组的实际位置上，增加了一些难度
深夜继续：解决了一个内存泄露的问题。。。检查了两个多小时，最后特么发现就是变量输错了，我尼玛

-----------2022.1.8-------------
今天结束了对角矩阵、三对角矩阵，并反映出了和昨天类似的问题。
析构函数出错，在析构中不要直接使用delete [] element，应当先判断是否为空，不为空先置空然后再删除，空指针删除是无害的
晚上继续解决了上、下三角矩二维坐标和一维坐标的映射关系，明天应该是稀疏矩阵，不弄了，陪我家的宝宝

-----------2022.1.9-------------
休息

-----------2022.1.10-------------
八嘎，这都什么bug

-----------2022.1.12-------------
花了3天时间，终于解决了稀疏矩阵的add和transpose问题，transpose书上是移动了内存，移动内存的顺序应当根据列坐标的大小
但是书上以看不懂的方式得到真实的位置，我给了两个方法。第一个transpose是不改变内存顺序的，只是交换了col和row
第2个t函数是移动了内存，但是我用的是名次排序得到内存应当存放的位置，结果是一样的，以自己的方式重写
add函数也是以自己方式，书上的如果是对2个都满足行主映射的矩阵没有bug，但是如果使用了我的transpose函数相当于没有移动过内存
那么就会产生问题，因为行主映射应当按照坐标从小到大的顺序。所以我也一次性重写了add函数，内存没有按照行主映射排列。
下午继续解决链表矩阵，这是第七章最后的内容了。

-----------2022.1.13-------------
重写了稀疏矩阵链表类，这是为了向前兼容，去除复杂的继承逻辑和使用简单的命名，增加了运算符=的重载（为了在链表稀疏矩阵类的构造函数中使用）
第七章彻底完结，接下来就是第八章的栈。

-----------2022.1.14-------------
