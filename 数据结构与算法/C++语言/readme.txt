-----------2022.1.15-----------
今天周五，把栈的pop、push和top使用数组和链表的方式搞定~
-----------2022.1.17-----------
玩了两天没学习，解决了汉诺托和括号匹配问题~
-----------2022.1.18-----------
艹，因为先要把之前的代码文件按照章节整理，但是readme.txt忘了保存，以前的学习记录没了，从现在重新开始
对前几天的学习记录还有印象，补了几天
今天把第八章结束，学习栈在车厢重排、开关盒布线上的应用，其中开关盒布线感觉有些问题~~，暂时留给以后解决
明天将开启第九章：队列的数据结构~
-----------2022.1.19-----------
今天给队列的具体类的push函数打了log，大体上了解了代码的实现
队列是插不满的，总是留一个，theFront在测试代码中依次为0、7、15以及31，theFront指向的内存总是没有用到
也就是没有插满之前总是满足2*arrayLength-1，当arrayLength=0时,没有意义，所以指定theFront=0,此时queue是从下标1开始用的
theBack依次为0、1、2、[3、2、3]、4、5、[6、6、7]、8、9、10、11、12、13、[14、14、15]、
16、17、18、19、20、21、22、23、24、25，总是在插满之前theBack重新赋值为arrayLength-2，所以除了[3、2、3]之外总是重复2次arrayLength-2
原因在于queue最开始用的下标是[1，arrayLength-1]，然后复制到newQueue的[0，arrayLength-1-1]
之后还是在arrayLength-1的位置上插入元素，所以对newQueue已经是插满arrayLength个了
此时queue更改指向newQueue，之后的问题就简单了，重复到不够用就拓展2倍容量
不过以上是在队列没有进行过pop的情况规律，theFront是容量不够自动变为2*arrayLength-1
如果在push的过程中有过pop，那么问题就比较复杂，theFront会从0变成1或者2，而不是7，这个问题明天讨论
-----------2022.1.20-----------
今天把数组描述的队列解决的比较完善了，程序没有问题，明天把md文档更新完。
-----------2022.1.21-----------
今天没写代码，一直在写md文档，把数组描述的队列用比较der的人话描述了一遍
又要周末了，这周没带书，太累了，想换换脑子写写python
-----------2022.1.24-----------
由于md文档写的不够清楚，昨天做梦的时候想明白了整个逻辑，重新总结了一下队列的设计过程以及output函数。
因为栈的应用还有个迷宫老鼠，最近看到这个能看懂，所以今天补了一下这部分内容，更新栈的md文档和C++文件
-----------2022.1.25-----------
研究不借助栈和队列怎么重排车厢
-----------2022.1.26-----------
上午回归对比了栈和队列重排车厢的区别，发现关键在于栈插入元素是在top，缓存栈的top()是可能的最小车厢编号，缓存栈之间更小的top是bestTop。
缓存队列的front()是最小的车厢编号，但是因为队列插入元素是在back，所以比较更合适的缓存队列时其实是比较back()谁更大，越大的越接近输入车厢编号nextCar
下午继续解决了没有栈、队列如何实现的逻辑，并对代码加以修改，补全了md文档的分析，告一段落，明天的队列应用问题是电路布线问题。
-----------2022.1.27-----------
今天上午在工作，处理了焊接的bom表，下午把电路布线问题解决了，还是比较完美的，明天周五咯
-----------2022.1.31-----------
1.29在公司学习，基本上把队列的应用问题过完，工厂仿真问题总体比较复杂，讲不清楚，所以暂时就跳过。
因为后边还有更重要的知识没学完，某个具体问题如果看不懂就暂时不深究转牛角尖了，浪费时间
昨天是玩了一下午联盟，回家了，今天是除夕，准备学一点跳表和散列的知识
-----------2022.2.1-----------
也不算玩了两天吧，但是基本玩了，这2天做的事是把git和vscode配置好了，而且观看b站视频解决了git的使用问题
-----------2022.2.4-----------
大年初一太困光玩游戏了，然后陪女朋友、串亲戚2天，今天第四天，完成了字典链表和字典数组的实现。
字典数组是自己的方式实现，并解决了一个pair<const K,V>* 和pair<K,V>*返回值不匹配问题，并给出了解决方案
明天研究跳表和散列
-----------2022.2.5-----------
跳表和散列描述的字典大体上能看懂含义，具体的实现确实比较困难，更新这部分代码和markdown文件就结束
以后合适的机会再回过头看，主要是这玩意看多了即使明白了也记不住。。第十章的应用自然也不讲了，为了进度，需要进入下一章节
下一章节是第十一章的二叉树
-----------2022.2.6-----------
啥也没干，陪女朋友
-----------2022.2.7-----------
回宿舍上班了要
-----------2022.2.8-----------
开工大吉，今天完成了二叉树的节点测试和遍历方式的测试。
-----------2022.2.9-----------
二叉树的链表描述搞定，第11章结束，进入下一章，优先级队列
-----------2022.2.10-----------
今天优先级队列自己用无序数组实现，花了些时间，明天继续学习书上给出的堆实现
-----------2022.2.11-----------
西巴，把堆实现的优先级队列解决了，下周左高树把，这周回家
回家不带东西，看看家里的那本书，effective系列
-----------2022.2.12-----------
做了三天leetcode的题
-----------2022.2.16-----------
今天解决了左高树的问题
-----------2022.2.17-----------
上午，把左高树的笔记完善，并学习了堆排序，下午想要继续增加leetcode的题目
即判断一棵二叉树是不是完全二叉树，和合并2棵左高树的两个算法
-----------2022.2.21-----------
前几天在搞leetcode，今天下午搞得是竞赛树，很遗憾，除了概念基本看不懂代码的含义
大概看了下14-16章的搜索树、平衡搜索树以及图论，打算都跳过，直接进入第三部分的算法设计部分
算法设计部分主要是贪婪算法、分而治之、动态规划、回溯法四部分，必要的话也会跳过，后面集中精神看其他的书和刷leetcode
其它的书包括C++设计模式、代码整洁之道以及Effective三本书系列。
-----------2022.2.23-----------
了解完贪婪算法，进入分而治之，解决了最大最小问题，下一个是归并排序问题。