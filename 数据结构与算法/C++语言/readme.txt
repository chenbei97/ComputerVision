-----------2022.1.15-----------
今天周五，把栈的pop、push和top使用数组和链表的方式搞定~
-----------2022.1.17-----------
玩了两天没学习，解决了汉诺托和括号匹配问题~
-----------2022.1.18-----------
艹，因为先要把之前的代码文件按照章节整理，但是readme.txt忘了保存，以前的学习记录没了，从现在重新开始
对前几天的学习记录还有印象，补了几天
今天把第八章结束，学习栈在车厢重排、开关盒布线上的应用，其中开关盒布线感觉有些问题~~，暂时留给以后解决
明天将开启第九章：队列的数据结构~
-----------2022.1.19-----------
今天给队列的具体类的push函数打了log，大体上了解了代码的实现
队列是插不满的，总是留一个，theFront在测试代码中依次为0、7、15以及31，theFront指向的内存总是没有用到
也就是没有插满之前总是满足2*arrayLength-1，当arrayLength=0时,没有意义，所以指定theFront=0,此时queue是从下标1开始用的
theBack依次为0、1、2、[3、2、3]、4、5、[6、6、7]、8、9、10、11、12、13、[14、14、15]、
16、17、18、19、20、21、22、23、24、25，总是在插满之前theBack重新赋值为arrayLength-2，所以除了[3、2、3]之外总是重复2次arrayLength-2
原因在于queue最开始用的下标是[1，arrayLength-1]，然后复制到newQueue的[0，arrayLength-1-1]
之后还是在arrayLength-1的位置上插入元素，所以对newQueue已经是插满arrayLength个了
此时queue更改指向newQueue，之后的问题就简单了，重复到不够用就拓展2倍容量
不过以上是在队列没有进行过pop的情况规律，theFront是容量不够自动变为2*arrayLength-1
如果在push的过程中有过pop，那么问题就比较复杂，theFront会从0变成1或者2，而不是7，这个问题明天讨论
-----------2022.1.20-----------

