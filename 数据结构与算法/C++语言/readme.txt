持续更新中

 ---------2021.12.15-------------
更新完《数据结构、算法与应用C++语言描述》前两章  

-----------2021.12.23-------------
前一阵工作忙加上DataWhale的任务没有继续，今天开始第三章渐近记法

-----------2021.12.23-------------
第3章和第4章都是概念，相对比较简单，今天一天更完，第一部分结束，接下来是第二部分5-16章，内容非常多

-----------2021.12.26-------------
更新到第5章的5.3.3 类arrayList，主要是关于如何创建一个数组描述的线性表的抽象类和具体类，已经学习完毕

-----------2021.12.27-------------
今天周一，开始继续5.3.4，C++迭代器的实现

-----------2021.12.28-------------
昨天把第5章结束，学习了抽象类基于数组和vector的具体类实现
今天继续第6章，线性表的链式描述

-----------2021.12.29-------------
链式描述昨天把不带迭代器的单向链表类全部理解吃透，今天学习完带迭代器和类的拓展，就可以到循环链表了
下午4.33：没毛病，总算搞定了拓展类的继承问题，循环链表也结束了，明天是双向链表，希望放假前把第6章能结束

-----------2021.12.30-------------
花了一上午，把单向链表关于插入的部分又捋清了概念，之前理解的有些问题，头插和不头插是不一样的。
对于单向链表firstNode初始化指向NULL，第1次头插会以firstNode本身构建新节点，也就是更新firstNode让它等于构建的新节点，程序是指针赋值操作，它们是1个东西
第2次头插还是用firstNode构建,只是此时它不指向NULL了而是之前创建的新节点,再次更新firstNode等于现在新构建的节点,依然是一个东西，所以整个链表并没多出1个节点
如果不是头插，p指针总是运行到插入位置的上一个，并用p->next信息构建新节点，同时更新当前的p指向这个新节点，firstNode不会有任何影响

循环链表的headerNone和firstNode不是一个含义，headerNone是一个独立的东西(初始化指向自己),整个链表确实多了1个节点
如果是头插不会执行for遍历
第1次头插让headNode指向创建的头插节点(这个节点是用headNode->next构建的,此时它还是指向自身)
第2次头插headNode指向新创建的头插节点(这个节点是用headNode->next构建的,此时它已经指向前1个创建的节点) heardNode->n1->n0->headNode以此类推
如果不是头插,插入的位置index会执行index次，但是依然到达的是index的上一个节点位置，为什么呢？因为headNode是真的1个节点,p指向headNode的,所以执行index次还没到达index节点
之后就简单了,用p->next构建index节点，再让p指向这个新构建的节点
特别的如果取到了listSize,p就是listSize-1的节点,p->next在一开始头插的时候已经指回了headNode,所以使用p->next构建的新节点作为尾节点依然指回headNode，还是循环链表




