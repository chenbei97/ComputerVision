持续更新中

 ---------2021.12.15-------------
更新完《数据结构、算法与应用C++语言描述》前两章  

-----------2021.12.23-------------
前一阵工作忙加上DataWhale的任务没有继续，今天开始第三章渐近记法

-----------2021.12.23-------------
第3章和第4章都是概念，相对比较简单，今天一天更完，第一部分结束，接下来是第二部分5-16章，内容非常多

-----------2021.12.26-------------
更新到第5章的5.3.3 类arrayList，主要是关于如何创建一个数组描述的线性表的抽象类和具体类，已经学习完毕

-----------2021.12.27-------------
今天周一，开始继续5.3.4，C++迭代器的实现

-----------2021.12.28-------------
昨天把第5章结束，学习了抽象类基于数组和vector的具体类实现
今天继续第6章，线性表的链式描述

-----------2021.12.29-------------
链式描述昨天把不带迭代器的单向链表类全部理解吃透，今天学习完带迭代器和类的拓展，就可以到循环链表了
下午4.33：没毛病，总算搞定了拓展类的继承问题，循环链表也结束了，明天是双向链表，希望放假前把第6章能结束

-----------2021.12.30-------------
花了一上午，把单向链表关于插入的部分又捋清了概念，之前理解的有些问题，头插和不头插是不一样的。
对于单向链表如果是头插，是以首节点firstNode构建新节点，firstNode就是首个元素，程序是指针赋值操作，本质上和构建的新节点是1个东西
如果不是头插，指针总是运行到插入位置的上一个，并用p->next信息构建新节点，同时更新当前的p指向这个新节点
循环链表的headerNone和firstNode不是一个东西，headerNone总是一个独立的东西(初始化指向自己)指向首个节点，尾节点又会指回它。
firstNode初始化指向NULL，总是和头插的节点相等，如果没有头插，firstNode就不会改变，此时新的节点就是以插入的节点来构建，最后尾节点指向NULL




