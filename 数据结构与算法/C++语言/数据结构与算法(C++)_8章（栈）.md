## 概述

​		回顾线性表的知识，一个抽象类型的线性表具有这些函数：empty()、size()、get(idx)、insert(idx,x)、erase(idx)、indexOf(x)以及output()。核心操作就是insert和erase函数，以数组描述的线性表的erase函数为例，如下方代码所示。

```c++
template<class T>
void _charter5_arrayList<T>::erase(int theIndex)
{
	checkIndex(theIndex);
	std::copy(element + theIndex + 1, element + listSize, element + theIndex);
	element[--listSize].~T(); 
}
```

​		可以看出erase的操作就是把index后面的元素整体向前复制进行覆盖，index可以取任何值，insert和get操作同理。所以限制index的取值在一端，就可以得到**<u>栈的数据结构，即"后进先出"的结构</u>**。栈有自己的3种操作，即获取栈顶元素top、出栈pop和入栈push。那么定义哪一端为栈顶呢？因为top内部调用的其实就是get，pop是erase，push是insert，那么肯定希望使用最好情况的插入、删除和获取操作。显然数组右端进行这3个操作时间复杂度最低，无需整体向后移动或者向前覆盖。故定义栈顶为数组右侧，栈底为数组左侧，实现只能栈顶进行操作只需要idx限制为listSize即可，或者size()。

​		由于线性表和栈之间的关系，所以定义栈的数据结构可以通过派生自线性表具体类实现，也可以不派生直接自定义抽象类Stack，这两种方式都可以，但是派生线性表的具体类效率比较低，下边给出数组描述和链表描述分别在具体类派生和自定义抽象类Stack派生的实现。

## 8.1  数组描述的栈

​		既然是栈，就必须定义一个栈的抽象数据结构Stack，根据概述中的描述，栈主要具备3个函数，top、pop和push，以及栈空empty和栈的元素数量size，其抽象类的声明如下所示。

```c++
template<class T>
class abstractStack
{
public:
	virtual ~abstractStack() {};
	virtual bool empty() const = 0;
	virtual int size() const = 0;
	virtual T& top() = 0;
	virtual void pop() = 0;
	virtual void push(const T& theElement) = 0;
};
```

### 8.1.1 数组线性表派生栈		

​		派生栈具体类的声明如下所示，派生自线性表具体类，output和<<重载函数是额外实现的，且output定义为私有，便于测试

```c++
#include "charter8_arrayList.h"
#include "charter8_abstractStack.h"
#include "charter8_stackEmpty.h"
template<class T>
class derivedArrayStack : private _charter8_arrayList<T>, public abstractStack<T>
{
public:
	derivedArrayStack(int initialCapacity = 10) : _charter8_arrayList<T>(initialCapacity) {} // 构造函数直接继承
	bool empty() const { return _charter8_arrayList<T> ::empty(); } // empty直接继承
	int size() const { return _charter8_arrayList<T>::size(); } // size直接继承
	// 抽象栈类的具体实现
	T& top(); 
	void pop();
	void push(const T&);
	friend ostream& operator<<<>(ostream&, const derivedArrayStack<T>&);
private:
	void output(std::ostream& out) const ; // 重写output方法
};
```

​		派生栈具体类的实现部分如下所示，除output和<<重新定义以外，其他函数都来源于继承或者使用继承的方法间接实现。

​		top、pop和push函数：

```c++
template<class T>
T& derivedArrayStack<T> ::top()
{
	// 下方程序是正确的,但是有个地方需要改善,get的索引出错时抛出的异常是illegalParameterValue
	// 那么对于外部的使用人员来说,他并不知道这个继承的逻辑,所以应该把这种类型异常转为栈空类型的异常
	//if (_charter8_arrayList<T>::empty())
	//	throw stackEmpty();
	//return  _charter8_arrayList<T>::get(_charter8_arrayList<T>::size() - 1); // 获取右端的元素 即listSize-1
	try { return _charter8_arrayList<T>::get(_charter8_arrayList<T>::size() - 1); }
	catch (illegalParameterValue) { throw stackEmpty(); } // 借助try_catch结构进行转换
}

template<class T>
void derivedArrayStack<T> ::pop()
{
	if (_charter8_arrayList<T>::empty())
		throw stackEmpty();
	  _charter8_arrayList<T>::erase(_charter8_arrayList<T>::size() - 1); // 删除的是listSize-1的元素
}

template<class T>
void derivedArrayStack<T> ::push(const T& theElement)
{
	  _charter8_arrayList<T>::insert(_charter8_arrayList<T>::size(), theElement); // 插入的位置在listSize
}
```

​		output和<<重载函数：

```c++
template<class T>
void derivedArrayStack<T> ::output(std::ostream &out) const
{
	// 原来的实现方法
	/*std::copy(element, element + listSize, std::ostream_iterator<T>(std::cout, "   "));*/
	if (_charter8_arrayList<T>::size() == 0)
		throw stackEmpty();
	for (int i = 0; i < _charter8_arrayList<T>::size(); i++)
	{
		cout << _charter8_arrayList<T>::element[i] << "  ";
		if ((i + 1) % 10 == 0)
			out << endl;
	}
}

template<class T>
ostream& operator<<<>(ostream& out, const derivedArrayStack<T>& theStack)
{
	theStack.output(out);
	return out;
}
```

​		本派生栈类的测试代码如下。

```c++
void _charter8_derivedArrayStack()
{
	derivedArrayStack<int> s;
	if (s.empty())
		cout << "The stack is empty" << endl;
	for (int i = 1; i <= 25; i++)
		s.push(i);
	cout << "The stack size is " << s.size() << endl;
	cout << "Stack should be 1234, bottom to top" << endl;
	cout << s << endl;

	while (!s.empty())
	{
		cout << "Stack top is " << s.top() << endl;
		s.pop();
		cout << "Popped top element" << endl;
	}
	try { s.pop(); }
	catch (stackEmpty message)
	{
		cout << "Last pop failed " << endl;
		message.outputMessage();
	}
}		
```

### 8.1.2 数组抽象栈派生

​		无需复杂的继承逻辑，相比线性表具体类的派生要简单直接。

​		其声明如下。

```c++
template<class T>
class arrayStack : public abstractStack<T>
{
public:
    arrayStack(int initialCapacity = 10);
    ~arrayStack() { delete[] stack; }
    bool empty() const { return stackTop == -1; }
    int size() const{return stackTop + 1;}
    T& top();
    void pop();
    void push(const T& theElement);
    friend ostream& operator <<<>(ostream&, const arrayStack<T>&);
private:
    int stackTop;         // 栈顶元素对外索引是0,但是在内部是stack[stackTop],栈底是stack[0]
    int arrayLength;      // 栈容量
    T* stack;           // 存储栈元素
};
```

​		实现如下。

```c++
template<class T>
arrayStack<T>::arrayStack(int initialCapacity)
{
    if (initialCapacity < 1)
    {
        ostringstream s;
        s << "Initial capacity = " << initialCapacity << " Must be > 0";
        throw illegalParameterValue(s.str());
    }
    arrayLength = initialCapacity;
    stack = new T[arrayLength];
    stackTop = -1; // 默认栈空此时为-1
}

template<class T>
T& arrayStack<T>::top()
{
    if (stackTop == -1)
        throw stackEmpty();
    return stack[stackTop]; 
}

template<class T>
void arrayStack<T>::pop()
{
    if (stackTop == -1) 
        throw stackEmpty();
    stack[stackTop--].~T();  // 直接析构掉stack的最后1个元素即可无需借助erase
}

template<class T>
void arrayStack<T>::push(const T& theElement)
{
    if (stackTop == arrayLength - 1) // 没有容量,扩充2倍
    {
        T* temp = new T[2 * arrayLength];
        std::copy(stack, stack + arrayLength, temp);
        delete[] stack;
        stack = temp;
        arrayLength *= 2;
    }
    stack[++stackTop] = theElement; // 先++,也就是在后1位存储该元素
}

template<class T>
ostream& operator <<<>(ostream&out, const arrayStack<T>& theStack)
{
    if (theStack.empty())
        out << "Stack is empty!" ;
    for (int i = 0; i < theStack.size(); i++)
    {
        out << theStack.stack[i] << "  ";
        if ((i + 1) % 10 == 0)
            out << endl;
    }    
    return out;
}
```

## 8.2 链表描述的栈

​		链表描述的栈也可以通过第六章的chain进行派生，但是限于效率较低不在给出，直接从抽象类具体化实现。

​		其声明如下，带有1个私有属性topNode用来替换数组描述的stack来存储数据。

​		要注意的是每次topNode都是用原来的topNode构建的，最早的topNode=NULL。

```c++
#include "charter8_abstractStack.h"
#include "charter8_stackEmpty.h"
#include "charter8_stackNode.h"
template<class T>
class linkedStack : public abstractStack<T>
{
public:
    linkedStack(int initialCapacity = 10) { topNode = NULL; stackSize = 0; log = false; }
    //最初的topNode是NULL,最后的topNode是栈顶
    //next相当于是自顶向下第2个元素地址,一路到栈底再到NULL
    ~linkedStack();
    bool empty() const{return stackSize == 0;}
    int size() const{return stackSize;}
    T& top();
    void pop();
    void push(const T&);
    void isLog(bool log) { this->log = log; }
    friend ostream& operator <<<>(ostream&, const linkedStack<T>&);
private:
    stackNode<T>* topNode;  // 数组描述的使用T* stack存储数据,链表描述则是使用topNode存储
    // topNode.data代替的就是数组描述时T*stack的存储功能,且多1个next指针功能
    int stackSize; 
    bool log ;
};
```

​		实现如下。

```c++
template<class T>
linkedStack<T>::~linkedStack()
{
    while (topNode != NULL)
    {
        stackNode<T>* nextNode = topNode->next;
        if (log == true)
            cout << "xigou~~  "<<"top = "<<topNode<<"  next = "<<nextNode<< endl;
        delete topNode; // 删除的是值而不是这个属性
        topNode = nextNode; // 重复等于它自身的下一个,topNode的下一个总是NULL
    }
}

template<class T>
T& linkedStack<T>::top()
{
    if (stackSize == 0)
        throw stackEmpty();
    return topNode->data; //真实的数据存储地方
}

template<class T>
void linkedStack<T>::push(const T& theElement )
{
    if (log == true)
        if (stackSize == 0 )
            cout << "0：" << "top = " << topNode <<"  previous = unknown"<<endl; // <<topNode->next 会出错
    // topNode总是指向新增的节点,并让next指向原来的的topNode,最初始的topNode=NULL
    topNode = new stackNode<T>(theElement, topNode); //相当于newTop->data=theElement,newTop->next=oldTop
    // 最终的topNode一路next下去就是NULL,通过对topNode的遍历即可得到存储的数据
    stackSize++;
    if (log == true)
        cout << "Node("<<stackSize<<") = " << topNode << "  previous = " << topNode->next << "  value = " << theElement << endl;
        // 从输出信息知道栈底的next就是NULL,栈顶元素是topNode,next为下1个,一路到栈底再到NULL
}

template<class T>
void linkedStack<T>::pop()
{
    if (stackSize == 0)
        throw stackEmpty();
    stackNode<T>* nextNode = topNode->next; // 那么nextNode为原来自顶向下的第2个元素
    delete topNode;
    topNode = nextNode; // 第2个元素成为新的栈顶
    stackSize--;
}

template<class T>
ostream& operator <<<>(ostream& out, const linkedStack<T>& theStack)
{
    if (theStack.empty())
        out << "Stack is empty!";
    stackNode<T> *Node = theStack.topNode;
    int idx = 0;
    while (Node != NULL )
    {
        out << Node->data << "  ";
        if ((idx + 1) % 10 == 0)
            out << endl;
        Node = Node->next;
        idx++;
    }
    return out;
}
```

## 8.3 应用

### 8.3.1 括号匹配问题

​		括号匹配就是一个左括号和一个右括号匹配，可以观察知道从左到右扫描表达式的时候，右括号总是和最近的左括号匹配。那么可以每次扫描到左括号时入栈，扫描到右括号时就和栈顶的括号匹配，如果栈顶有元素说明匹配成功，否则说明剩余的右括号没有左括号可以与之匹配。或者右括号都匹配完了，左括号还有剩余，也是没匹配完全。

​		举例：

```c++
e x p (  (  (  (  a + b  )  / c ) -  d ) - 1 ) /  ( f + g )
         3 4 5 6           10    13     16   19   21      25
```

​		关于括号匹配的C++程序如下，使用的是数组描述的栈。

```c++
void parenthesis_matching(const std::string & str)
{
	arrayStack <int > stack;
	int length = (int)str.size();
	for (int i = 0; i < length; i++)
	{
		if (str.at(i) == '(')
		{
			stack.push(i); //push的是索引位置
			cout << "now stack is " << stack << endl;
		}
			
		else
			if (str.at(i) == ')')
                try
                {
                        cout << "left parenthesis ("<<stack.top() << 
                            ") and right parenthesis ("<<i <<") is match" << endl;
                        stack.pop(); // 匹配到1个就删除,否则栈空抛出
                }
                catch (stackEmpty)
                {
                    cout << " No match right parenthesis" << " at (" << i << ")" << endl;
                }	
	}
	while (!stack.empty())
	{
		cout << " No match left parenthesis" << " at (" << stack.top() << ")" << endl;
		stack.pop();
	}
}
```

​		上述例子的测试程序结果：

```c++
now stack is 3
now stack is 3  4
now stack is 3  4  5
now stack is 3  4  5  6
left parenthesis (6) and right parenthesis (10) is match
left parenthesis (5) and right parenthesis (13) is match
left parenthesis (4) and right parenthesis (16) is match
left parenthesis (3) and right parenthesis (19) is match
now stack is 21
left parenthesis (21) and right parenthesis (25) is match
```

### 8.3.2 汉诺塔问题

​		问题描述：一共有3个塔，第1个塔有n个碟子，从塔的底部到顶部碟子越来越小，即碟子小的在上，大的在下。现在要把第1个塔的碟子还是按照自下(大碟子)而上(小碟子)的摆放模式放在第2个塔上，第3个塔是借助。规则：大碟子永远不能压在小碟子上边，而且每次只能移动1个碟子。

​		现在举例，n=4，记小碟子编号为1，大碟子编号4，开始的塔A、B、C情况为塔A=1,2,3,4，B和C没有碟子。那么共计需要15个步骤才能完成交换，如下图所示。

![](C:\Users\chenb\Desktop\2022.1备份\markdown文件\汉诺塔问题.jpg)

​		上述图片相当于完成的逻辑是

​		A.pop、C.push ; A.pop、B.push ; 2次  =>1、3；1、2；

​		C.pop、B.push；A.pop、C.push；2次 =>3、2；1、3；

​		B.pop、A.push；B.pop、C.push；2次 =>2、1；2、3；

​		A.pop、C.push；A.pop、B.push；2次 =>1、3；1、2；

​		C.pop、B.push；C.pop、A.push；2次 =>3、2；3、1；

​		B.pop、A.push；C.pop、B.push；2次 =>2、1；3、2；

​		A.pop、C.push；A.pop、B.push；2次 =>1、3；1、2

​		C.pop、B.push；                                   1次 =>3、2；

​		根据上述图片的分析，发现碟子的数量n与移动的次数move(n)最终满足如下表达式。

```c++
		 0  n = 0
move(n)=
    	 2move(n-1)+1 n >0
递推有 
move(n) = 2^n - 1 次
```

​		根据上述分析，可以看出一定的规律。图片左半部分是把n-1个元素从塔1借助塔2移动到塔3，右半部分是借助塔1把n-1个元素移动到塔2上。下方程序借助了递归，其输出语句可以显示从哪个塔pop的元素被push到哪个塔上，之后就可以利用这种规律来进行入栈和出栈的操作。towerx、towery、towerz是塔的索引，可以看成arrayStack数组的1个元素，按下方这样的顺序对不同的塔进行pop和push操作就可以完成调换。

```c++
void towerOfHanoi_byRecursion(int n , int towerx, int towery, int towerz)
{
	// 此程序并不是移动元素的程序，只是一个测试程序步的程序
	// 把n个碟子从x转移到y
	if (n > 0)
	{
		// 先把前n-1个碟子转移到z,最大的碟子就可以放在y
		towerOfHanoi_byRecursion(n-1,towerx, towerz, towery); 
		cout << "mov top disk from tower " << towerx << " to top of tower " << towery << endl;
		// 之后就可以把z上的n-1个碟子移动到y
		towerOfHanoi_byRecursion(n - 1, towerz, towery, towerx);
	}
}
```

​		下方程序就是依据上方程序进行的改变，需要定义一个全局栈数组，每个元素存储1个塔，事先需要先被初始化。因为塔的名字取的是1、2、3，所以为了能用到这个索引，定义的栈数组容量为4，但是只用到后3个。初始化完毕以后，就开始调用函数，初值给的是1、2、3。

```c++
arrayStack<int> charter8_tower[4];
void towerOfHanoi_byStack(int n )
{
	for (int d = n; d > 0; d--)
		charter8_tower[1].push(d);//初始状态,塔x把大碟子到小碟子(用整数代替)压入栈,塔y,z为空
	moveTopDisk(n, 1, 2, 3);
}
```

​	多的3条语句是将塔x的顶元素pop，再被push进塔y。

```c++

void moveTopDisk(int n , int x , int y, int z)
{
	if (n > 0)
	{
		moveTopDisk(n - 1, x, z, y);// 移动塔x的元素到z
		int d = charter8_tower[x].top(); // 每次从1个塔pop的元素被push到另外1个塔
		charter8_tower[x].pop();
		charter8_tower[y].push(d);
		cout << "mov top disk "<<d<<" from tower " << x << " to top of tower " << y << endl;
		moveTopDisk(n - 1, z, y, x); // 移动塔z的元素到y
	}
}
```

### 8.3.3 车厢重排问题

​		关于车厢重拍只给出1个例子进行示例说明，代码具体的含义不再说明，见程序的注释。

​		车厢的编号一开始是无序的，要求经过重排后编号是从小到大排列的。给定3个缓冲通道和9个车厢，车厢初始顺序为581742963，那么输出的应该是987654321。

​		分析：

​		一开始车厢编号是3，而不是应该输出的1，那么应当就近原则把车厢3先存入缓存通道H1；

​		继续下一个车厢是6仍然不是1那么继续缓存至H2，不放在H1上是因为6＞3，这里涉及一条准则：**<u>任何一条缓冲通道的车厢从顶到底的车厢编号不按照递增顺序时，重排是无法完成的</u>**；

​		类似的车厢9缓存至H3；

​		继续，车厢2可以缓存至任何1个，但是要注意：**<u>编号为u的车厢应该进入的缓存通道，其顶部车厢编号应该是大于u的最小值</u>**，换言之现在的H1=3、H2=6、H3=9，而比车厢2大的最小值是3所以应该存放至H1，如果存放到H2，那么后续的车厢4、5、7和8不能使用H1也不能使用H2，H3虽然能够使用但是可能不够用，如果存放到H3，后续的车厢4、5仍然能够使用H2，车厢7、8可以使用H3；		所以按照规律，车厢4缓存到H2，车厢7缓存到H3；

​		之后终于等到了车厢1，无需缓存直接出库，下一个应当是车厢2出库，此时审视目前已经缓存的车厢，如果有车厢2就出库，继续审视车厢3(while循环)，直到没有这样的车厢，也就是2、3、4都直接出库了，直到车厢5发现缓存里边并没有；

​		那么就遍历下一个车厢，发现是8，也不是5，那么先缓存，因为现在的H1是空的所以就近，H2还有车厢6，H3有车厢7、9；

​		等到最后1个车厢5，当前应该出库的就是车厢5，所以直接出库；

​		继续，应该车厢6出库，此时寻找缓存的车厢，释放H2的6，然后释放H3的7，再释放之前H1缓存的8，最后释放H3的9，这些缓存的车厢全部出库完毕。

​		代码如下。

```c++
arrayStack<int>* trackC8; // 全局栈指针,动态的开辟指定数量的缓冲轨道
arrayStack<int> sortedCarriageC8; // 排序好的车厢存放处
int nCarsC8; // 给定的车厢数
int nTracksC8; // 给定的缓冲轨道数
// nCarsC8和nTracksC8都是主程序自行给定的,不同的车厢数需要的最小缓冲轨道数是不同的
// 如果给错,可能会排列失败,例如1,n,n-1,...,2这个排列的车厢要求最少n-1个缓冲轨道
int smallestNumC8; // 缓冲轨道最小的车厢编号
int belongToTrackC8; // 最小的车厢编号所属的缓冲轨道编号
bool carriageRearrange(int permutation[], int nCars, int nTracks)
{
	nCarsC8 = nCars;
	nTracksC8 = nTracks;
	const int temp = 10; // 这里是为了说明temp≥1就可以,无关紧要
	// 如果给的9节车厢则初始化最小编号为9+temp,表示缓冲轨道暂时没有车厢
	smallestNumC8 = nCarsC8 + temp; // 因为必须要初始化所以先给定任意1个值,这里取10罢了
	// 下标0不使用,从1开始方便,即trackC8[1]为第1个缓冲轨道
	trackC8 = new arrayStack<int>[nCarsC8 + 1]; 
	int nextNum = 1; // 按顺序下1个进入出轨道的车厢编号,从编号1开始

	for (int i = 1; i <= nCarsC8; i++) // through every permution's num 581742963
	{
		int currentNum = permutation[i]; // actual number 3,6,9,2,4,7,1,8,5
		if (currentNum == nextNum) // currentNum=1,5的时候执行
		{
			cout << "move car(" << currentNum << ") to output track" << endl;
			sortedCarriageC8.push(currentNum);
			cout <<"sortedCarriage is " << sortedCarriageC8 << endl;
			nextNum++; // 下一个应该出去的车厢编号是2
			cout << "nextNum = "<<nextNum << endl;
			// 如果缓冲道最小的车厢编号(一定是最小的先出)是下一个要出的车厢,则移到出轨道
			while (smallestNumC8 == nextNum) // 第1次执行时nextNum=2,smallestNumC8=2
			{
				moveInOutputTrack(); // 车厢2被移出去了,smallestNumC8=3
				nextNum++; // nextNum =3 , 如此反复运行
				cout << "nextNum = " << nextNum << endl;
				if (nextNum == nCarsC8 + 1)
					break;
				// 从(nextNum,smallestNumC8)=(2,2)开始依次执行(3,3),(4,4)共3次,然后(5,6)停止执行
				// 此时缓冲轨道只有6,7,9,而下1个该出去的是5,所以会执行moveInBufferTrack
				// 而当前的currentNum是1,下1个是8和5,8执行moveInBufferTrack,此时缓冲轨道6,7,8,9
				// 然后currentNum=5,在while之前就已经执行出去了,currentNum=6
				// (6,6)=>(7,7)=>(8,8)=>(8,8),缓冲轨道的车厢全部移出完毕
			}
		}
		else
		{
			// 从一开始,如果车厢编号一直不是1,会把不是1的车厢先存入缓冲轨道
			// 这里会把3移入H1,6->H2,9->H3,紧接着2->H1,4->H2,7->H3
			// 直到currentNum=1会执行上方程序,把缓冲轨道的一些车厢移出,然后while在(5,6)也不执行了
			// currentNum = 8,nextNum = 5,移入缓冲轨道 currentNum = 5 执行上方程序
			if (!moveInBufferTrack(currentNum))  // currentNum = 3,6,9,2,4,7,8的时候执行
				return false; // 如果没有缓冲轨道了说明重排失败
		}
	}
	return true;
}
void moveInOutputTrack()
{
	//cout << "belongToTrackC8 = " << belongToTrackC8 << endl; 1,1,2,2,3,1,3
	// belongToTrackC8在moveInBufferTrack已经变成1了
	trackC8[belongToTrackC8].pop(); // 把最小的车厢从相应的缓冲道移出
	cout << "move car(" << smallestNumC8 << ") from bufferTrack(" 
		<< belongToTrackC8 << ") to outputTrack" << endl;
	sortedCarriageC8.push(smallestNumC8);
	cout << "sortedCarriage is " << sortedCarriageC8 << endl;
	smallestNumC8 = nCarsC8 + 1; // 如果下方没找到目前最小的车辆编号说明缓冲道没有车厢
	for (int i = 1; i <= nTracksC8; i++) // through every not empty track
	{
		cout << "smallestNum = " << smallestNumC8 
			<<" belongToTrack "<< belongToTrackC8<< endl;
		if (!trackC8[i].empty() && (trackC8[i].top() < smallestNumC8))
		{ //  如果顶部元素有更小的车辆编号就更新2个全局变量
			smallestNumC8 = trackC8[i].top();
			belongToTrackC8 = i;
		}
	}
}
bool moveInBufferTrack(int currentNum)
{
	// 有可用的缓冲道那么可以移入,返回true;否则说明有限的缓冲道无法进行重排
	const int temp = 10; // 这里是为了说明temp≥1就可以,无关紧要
	int bestTrack = 0; // currentNum最合适移入的Track,应该从1到nTracksC8,0是初始化
	int smallerNum= nCarsC8 + temp; // 如果有比currentNum更小的编号就会更新这个值否则不变
	for (int i = 1; i <= nTracksC8; i++)
		if (!trackC8[i].empty()) // through every not empty track
		{
			// 不为空时当前的Track至少有1个top,取出来和当前的车厢编号比较,更小的被记录用于下一个Track比较
			int topCar = trackC8[i].top(); // 获取不同Track的top和smallerNum比较,找到最小的
			// 且当前的车厢编号还小于smallerNum,说明可以在这个Track存储,记录存储的Track编号
			if (currentNum < topCar && topCar < smallerNum) // smallerNum总是一开始等于10
			{
				// 此时有更小的车厢编号,位置在trackC8[i]的栈顶
				smallerNum = topCar; // 记录更小的车厢编号(如果有的话更新它用于比较下1个Track)
				bestTrack = i; // 记录此时的车厢编号所属的缓冲道
			}
		}
		else
			// 如果还是初始化状态,说明之前的Track不为空但也没有更小的车辆编号
			if (bestTrack == 0) bestTrack = i;  // 移入首个为空的Track,i=1必定执行
	if (bestTrack == 0) return false;// 空Track也没有,说明无法重排
	trackC8[bestTrack].push(currentNum); // i=1,bestTrack=1,currentNum=3
	cout << "move car(" << currentNum << ") from inputTrack to bufferTrack(" 
		<<bestTrack<<")" << endl;

	// 如果有必要需要更新2个全局变量，3,6,9,2,4,7,1,8,5
	if (currentNum < smallestNumC8) // 最开始是3<10,6<3? 均不执行直到1<3才会执行
	{
		smallestNumC8 = currentNum; // =3,=1,
		belongToTrackC8 = bestTrack; // =1,
	}
	return true; 
}
```

​		测试代码如下。

```c++
void _charter8_carriageRearrange()
{
	const int nCars = 9; // 9节车厢
	const int nTracks = 3; // 3个缓冲道
	int permutation[nCars + 1] = { 0, 3,6,9,2,4,7,1,8,5 }; // 数组小标0的位置不用,从1开始比较方便
	cout << "Input permutation is 581742963" << endl; // 初始的输入排列
	if (carriageRearrange(permutation, 9, 3))
	{
		cout << "carriage rearrange is successful, permutation is : " 
			<< sortedCarriageC8<< endl;
	}
	else {cout << "carriage rearrange is failed " << endl;}	
}
```

### 8.3.4 开关盒布线问题

​		老实讲，这个开关盒布线问题，书上的翻译问题很大，完全不明白说的什么意思。原书P192页给出的可布线的正面例子是4个网组为(1,4)、(2,3)、(5,6)和(7,8)，不可布线的反面例子为(1,5)、(2,3)、(4,7)、(6,8)，但是P193页书上说测试的数组为[1,2,2,1,3,3,4,4]，完全不知所以然。书的源代码中也没有找到"checkBox.cpp"的程序文件和相应的测试案例，百度的也是抄的书上，所以这个问题暂时没解决，留到以后可能的机会去看。

​		程序先贴出来。

```c++
void switchBoxWiring(int net[], int n)
{
	arrayStack<int>* stack = new arrayStack<int>[n];
	for (int i = 1; i <= n; i++)
		if (!stack->empty())
		{
			int Pin = net[i];
			int topPin = net[stack->top()];
			if (Pin == topPin) // net[i]是可布线的,可以从栈中删除
				stack->pop();
			else stack->push(i);
			cout << "if：pin = " << Pin <<" topPin = "<<topPin<< " and stack is " << *stack << endl;
		}
		else
		{
			stack->push(i);
			cout << "el：pin = " << net[i] << " topPin = " << net[stack->top()] << " and stack is " << *stack << endl;
		}
	if (stack->empty()) // 可布线的条件是所有管脚检查完栈空
		cout << "switch box wirnet is routable" << endl;
	else
		cout << "switch box wirnet is not routable" << endl;
}
```

​		测试程序。

```c++
void _charter8_switchBoxWiring()
{
	const int n = 8;
	int net1[n + 1] = { 0,1,2,2,1,3,3,4,4 };
	int net2[n + 1] = { 0,1,4,2,3,5,6,7,8 };
	int net3[n + 1] = { 0,1,1,2,1,3,3,4,4 };
	switchBoxWiring(net1, n);
	switchBoxWiring(net2, n);
	switchBoxWiring(net3, n);
}
```

​		输出结果：

```c++
el：pin = 1 topPin = 1 and stack is 1
if：pin = 2 topPin = 1 and stack is 1  2
if：pin = 2 topPin = 2 and stack is 1
if：pin = 1 topPin = 1 and stack is Stack is empty!
el：pin = 3 topPin = 3 and stack is 5
if：pin = 3 topPin = 3 and stack is Stack is empty!
el：pin = 4 topPin = 4 and stack is 7
if：pin = 4 topPin = 4 and stack is Stack is empty!
switch box wirnet is routable
el：pin = 1 topPin = 1 and stack is 1
if：pin = 4 topPin = 1 and stack is 1  2
if：pin = 2 topPin = 4 and stack is 1  2  3
if：pin = 3 topPin = 2 and stack is 1  2  3  4
if：pin = 5 topPin = 3 and stack is 1  2  3  4  5
if：pin = 6 topPin = 5 and stack is 1  2  3  4  5  6
if：pin = 7 topPin = 6 and stack is 1  2  3  4  5  6  7
if：pin = 8 topPin = 7 and stack is 1  2  3  4  5  6  7  8
switch box wirnet is not routable
el：pin = 1 topPin = 1 and stack is 1
if：pin = 1 topPin = 1 and stack is Stack is empty!
el：pin = 2 topPin = 2 and stack is 3
if：pin = 1 topPin = 2 and stack is 3  4
if：pin = 3 topPin = 1 and stack is 3  4  5
if：pin = 3 topPin = 3 and stack is 3  4
if：pin = 4 topPin = 1 and stack is 3  4  7
if：pin = 4 topPin = 4 and stack is 3  4
switch box wirnet is not routable
```

其它的应用问题比较困难，暂时跳过，本章结束~

