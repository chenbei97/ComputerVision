#pragma once
#ifndef chapter10_skipNode_
#define chapter10_skipNode_
using namespace std;
/*
    跳表的数组对数N,那么链表最大级别为ceil[log2N]-1
    N = 1024, maxLevel = 10-1 = 9
    N = 1000, maxLevel = [9.96]-1 = 9
    1,2,3,4.................................999,1000 0级链表
    1,3,5,7,........................................999 1级链表 499*2+1=999
    1,5,9,13,......................................997 2级链表 249*4+1=997
    1,9,17,25,....................................993 3级链表 124*8+1=993
    1,17,33,49,..................................993 4级链表 62*16+1=993
    1,33,65,97,..................................993 5级链表 31*32+1=993
    1,65,129,193,..............................961 6级链表 15*64+1=991
    1,129,257,285,............................897 7级链表 7*128+1=897
    1,257,513,...................................769 8级链表 3*256+1=769
    1,................................................513 9级链表 1*512+1=513
    可以看出规律,[高级的链表是低级链表的子集],前提是有序链表查找元素
    跳表的节点属性除了存储数据域(key,value)的pair对象data
    还要对指针域进行改造,next不再是只有1个指针,可能有多个指针
    头节点会有[log2N]个next指针,所以next是指针数组,next[i]是i级链表的下一个节点
     最中间的节点或者说最大级的链表唯一的那个节点也需要[log2N]个next指针
     其它的节点根据链表的等级,可能拥有不同的next指针个数,如
     节点2∈0级链表只有1个next,next为节点3
     节点3∈0,1级链表有2个next,next[0]指向节点4,next[1]指向节点5
     节点5∈0,1,2级链表有3个next,next[0]指向节点6,next[1]指向节点7,next[2]指向节点9
     可以看出规律,next[i]和当前节点隔开2^(i)个节点,如5的next[2]和5隔开4个节点
     递推规律:
     节点1∈0,1,2,...,9级链表,有10个next,next[9]=513和1隔开512个节点
     节点513∈9级链表,有1个next,next[0]=NULL尾节点
*/
template <class K, class V>
struct skipNode
{
    typedef pair<const K, V> pairType;
    pairType data;
    skipNode<K, V>** next;   // 指针数组,索引在[0,[log2N]-1]范围

    skipNode(const pairType& thePair, int size)
        :data(thePair) {
        next = new skipNode<K, V>*[size];
    }
};
#endif // !chapter10_skipNode_
