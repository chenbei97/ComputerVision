## 9.1 抽象数据类型

​		队列是一个先进先出的数据结构，而上一章的栈是先进后出的结构。举例，售卖机的矿泉水在底部出来被买家拿走，但是在顶部被添加，所以相当于是在队首删除商品，在队尾追加商品，先添加的商品也先被卖出。

​		所以队列的抽象数据类型如下。

```c++
抽象数据类型 queue
{
    实例
        元素的有序表，一端为队首，一端为队尾
    操作
        empty() 队列为空返回true,否则返回false
        size()	返回队列元素个数
        front() 返回队首元素
        back()  返回队尾元素
        push()  队尾追加元素
        pop()   队首删除元素
}
```

​		抽象数据类型的C++代码如下。

```c++
template<class T>
class abstractQueue
{
public:
	virtual ~abstractQueue() {}
	virtual bool empty() const = 0;
	virtual int size() const = 0;
	virtual T& front()  = 0;
	virtual T& back() = 0;
	virtual void pop() = 0;
	virtual void push(const T&) = 0;
};
```

## 9.1 数组描述

​		先给出类的声明，说明几个bool型变量的含义，再对具体的函数进行说明。

```c++
template<class T>
class arrayQueue : public abstractQueue<T>
{
public:
	arrayQueue(int initialCapacity = 10);
	~arrayQueue() { if (queue != NULL) queue = NULL; delete[] queue; }
    bool empty() const { return theFront == theBack; }
    int size() const;
    T& front();
    T& back();
    void pop();
    void push(const T&);
    friend ostream& operator<<<>(ostream&, arrayQueue<T> &);
    void log(bool);
    void output(ostream&) const;
    int getFrontIndex() { return theFront; }
    int getBackIndex() { return theBack; }
private:
    int theFront;       // 队首元素索引的逆时针前1位
    int theBack;        // 队尾元素索引
    int arrayLength;  
    T* queue;
    bool isChangeArrayLength; // 最初没有改变过容量
    bool isPop; // 没有执行过1次pop
    bool isLog;
};
```

### 9.1.1 队列的索引

#### 9.1.1.1 下标0索引

​		1、队列本质上存储数据的就是一个数组queue，数组queue的下标索引是从0到arrayLength-1的。所以按比较自然的逻辑，如果我们访问队列的首元素，应该是访问queue[0]，访问队尾元素应该是访问queue[arrayLength-1]。相应的theFront应当总是为0，theBack应当是arrayLength-1，队列长度应当为theBack+1也就是arrayLength。

​		2、分析时间复杂度，每次插入1个元素，应当在位置queue[theBack+1]插入，然后将theBack增1，插入所需的时间复杂度为Θ(1)；但删除1个元素比较复杂，需事先整体左移1个单位，并把原来的队尾元素~T()，所以时间复杂度为Θ(n)，n为队列的元素个数。

​		3、这样的访问方式就是访问queue[i],i≥0，总是保持theFront=0，theBack∈[0,arrayLength-1]，初始化的时候theFront=theBack=0。如果队列插满，此时theBack=arrayLength-1，检测到(theBack+1)%arrayLength==0时就拓展容量，把原来的oldQueue[0,arrayLength-1]复制到新的newQueue[0,arrayLength-1]即可，theBack不变。

​		4、由于theFront始终保持0，theBack除了初始化的时候为0之后永远不会为0，所以队空的条件就是theFront == theBack，队列元素的个数是theBack+1，闭区间[a,b]的元素个数是b-a+1，所以[0,theBack] =  [0,arrayLength-1] => theBack + 1 = arrayLength

​		下标0开始索引的方式很容易理解，但是删除操作很费时，现在考虑1个新的索引方式。

#### 9.1.1.2 下标i索引

​		1、队列的第i个元素在queue的第i个索引查找，即队首元素实际上是queue[1]，而queue[0]是theFront，队尾元素是queue[theBack]=queue[arrayLength-1]。theBack确实能访问到元素，而theFront访问的是NULL，因为queue[0]没有。如果**<u>队列不满且没有过pop进行push</u>**，语句1不成立，则theFront不变，theBack应当增1，并在增1的位置插入元素theElement，见语句9和10。其实**<u>队列不满没有过pop还可以细分是否拓展过容量</u>**，如果没拓展过，**<u>theFront=0</u>**，[theFront+1,theBack]的元素个数为theBack-theFront。如果拓展过，**<u>theFront=2*arrayLength(old)-1</u>**，这也是为何语句1的判断条件是 "== theFront" 而不是 "== 0"。

```c++
if ((theBack + 1) % arrayLength == theFront) // 语句1
```

​		如果拓展过，**<u>theBack先向后退了1步再前进一步</u>**(push函数的语句8和语句9)，这是因为从oldQueue的转移到newQueue索引0的位置用上了1个元素，所以theBack位置不变，theBack始终≥theFront(没有过pop不会跑到0)且最多取到arrayLength-1。例如theBack=arrayLength-1(oldQueue) => theBack=arrayLength-2(newQueue) 位置不变（**<u>复制到newQueue使用的是语句4</u>**）。无论是哪种情况，**<u>theBack最多取arrayLength-1，且≥theFront</u>**

​		theBack表达式是(theBack + 1) % arrayLength。

```c++
theBack = arrayLength - 1 - 1;// 语句8
theBack = (theBack + 1) % arrayLength;// 语句9
```

​		theBack为何取对arrayLength的余数呢？因为pop操作会导致theFront>0，相应的theBack可能>theFront也可能<theFront，**<u>如果队尾还有位置，theBack就会大于theFront，如果没有位置，队首有空出来的位置，元素被插到队首，theBack就会小于theFront，这两部分再分别复制到newQueue的对应起始位置</u>**，现在分别对这2个情况进行分析。

​		2、考虑**<u>队列pop过但队尾还有位置进行push</u>** 的情况，这个情况比较简单。因为theBack的取值取决于push函数，最多取到arrayLength-1(无论是对oldQueue还是newQueue而言)，注意是push完1个元素，theBack才增1，所以push第arrayLength-1个元素时，theBack增加到arrayLength-1，此时队列没满但是oldQueue已经满了。如果再次push，只能插到oldQueue左端，这个情况在第3条说明。

​		根据上述的分析，这种情况下<u>**theBack只需要增1即可，且一定≥theFront，并≤arrayLength-1，和第1节的分析一致**</u>，而theFront的情况取决于pop函数，如下所示。一开始theFront=0，进入pop函数就会跳到1，这是因为要删除的是queue[1]，如果取极端情况，theFront=arrayLength-2,theBack=arrayLength-1，此时两者不相等不会抛出栈空错误，然后theFront增1，实现了queue[arrayLength-1]的元素删除。由于oldQueue存储的区间是[theFront+1,theBack]，所以**<u>元素个数就是theBack-theFront</u>**。

```c++
template<class T>
void arrayQueue<T> ::pop()
{
    if (theFront == theBack)
        throw queueEmpty();
    theFront = (theFront + 1) % arrayLength;
    queue[theFront].~T();
    isPop = true;
}
```

​		3、考虑**<u>队列pop过但队尾没有位置进行push</u>**的情况，这个时候只能头插，theBack要从arrayLength-1变化到0，所以这也是**<u>为何theBack要取对arrayLength的余数</u>**，第1节的问题回答完毕。此时theBack属∈[0,theFront)范围，这个时候是oldQueue后面的位置已经插满，再插应该插入到因为pop腾出来的左端元素，也就是0到theFront之间，所以theBack取了余数，总的使用空间实际上是[theFront+1,arrayLength-1]和[0,theBack] (**<u>所以在复制到newQueue时使用的是语句5和6</u>**，后续会继续解释)，**<u>元素个数合计为arrayLength+theBack-theFront</u>**。合并第2节和本节的2种情况，对于元素个数的表达式，就有了size()函数的表达式如下。

```c++
template<class T>
int arrayQueue<T>::size() const
{
    return (theBack - theFront + arrayLength) % arrayLength;
    // 等价于
    if (theBack > theFront) 
        return theBack - theFront;
    else
        return arrayLength + theBack - theFront;
}
// theBack-theFront看成整体X,考虑(X+C)%C的情况
// X不是大于0就是小于0,小于0时相当于不够除1个C,剩下的就是X+C
// X大于0时,够除1个C,因为X再大也不到1个C(最多C-1,原因见下),那剩下的余数其实还是X
// theFront=0,theBack=C-1达到了差值最大,所以余数最大为C-1,也就是arrayLength-1
// 所以2个分开的表达式等价于1个表达式(theBack - theFront + arrayLength) % arrayLength
```

​		4、再来分析copy函数的使用，队列要满足queue满时(队列即将满)才能执行复制语句，也就是theBack已经取到了arrayLength-1，那么语句1就成立。关于copy执行语句4还是执行语句5、6，取决于语句3是否成立。

```c++
if (start < 2) // 语句3
```

​		在分析语句3之前，先说明copy的复制方式。队列**<u>有2种复制方式：一种是对应位置复制，另一种是左端对齐复制</u>**，以没有pop过的队列，theFront=0为例分析过程，是否拓展过容量无关紧要，也就是第1小节的场景。

​		如果没拓展过容量，即把oldQueue[1,arrayLength-1]的内容复制到newQueue[1,arrayLength-1]，然后尾部插入元素，让newQueue[theBack] = newQueue[arrayLength] = theElement ，也就是newQueue在区间[1,arrayLength]有元素，元素个数为arrayLength个。因为没拓展过容量且由于没有执行过删除操作，theFront=0是不会变的，newQueue也永远第0个索引没有元素，空间浪费的不显著。但是如果没拓展过容量，但是执行过pop呢？无论是第2还是第3小节的情况，每次执行pop，都会使得theFront右移1个位置，一开始是0，删除1个就移到了1，删除m次theFront就会移动到m索引，但是theBack永远不变。假设theBack==arrayLength-1，如果根据上边的**<u>对应位置复制方式</u>**，每次都是复制oldQueue[m+1,arrayLength-1]的内容到newQueue相对应的位置上[m+1,arrayLength-1]，这相当于newQueue[0,m]共m+1个的空间没有使用，造成了极大的浪费。所以现在希望是这arrayLength-m-1个元素复制到newQueue[0,arrayLength-m-2]的位置上，**<u>也就是第2种复制方式左端对齐复制</u>**。这个m每次都需要根据当前theFront的位置确定，就是程序中语句2的start，start总是等于(theFront+1)%arrayLength。

```c++
int start = (theFront + 1) % arrayLength; // 语句2
```

​		为什么start也要对arrayLength取余数呢？这时候就要考虑拓展过容量的情形了，此时按照第1节的分析，队列拓展过容量时theFront=2 * arrayLength-1，不取余数start就等于2 *  arrayLength，队首元素虽然是从queue[0]开始的，但是theFront并不是0，为此取余数就可以得到队首的实际位置。

​		5、现在开始分析语句3，**<u>它成立与否的条件翻译过来就是theFront是否属于{0,2 * arrayLength-1 }，属于的话说明没有pop过，否则就是pop过</u>**。

​		没有pop过，start必定取值0或者1，那么复制只需要把oldQueue在**<u>[start=1,theBack]</u>** (没pop,没拓展过容量,theFront=0)或者 **<u>[start=0,theBack-1]</u>** (没pop,拓展过容量,theFront=2 * arrayLength - 1)的元素复制到**<u>newQueue[0,theBack-1]</u>**即可，然后在theBack的位置插入新元素theElement，两种情况插入之前元素个数都是theBack，假如theBack=arrayLength-1,那么元素就是arrayLength个，执行的语句4如下。copy语句要求左闭右开的指针，首指针指向首元素，尾指针指向尾元素的后一位。

```c++
copy(queue + start, queue + start + arrayLength - 1, newQueue);// 语句4
```

​		如果pop过，语句3就不会成立，因为theFront不会等于0，可能的取值介于[1,arrayLength-1]之间，start>=2，执行的copy语句是5和6。需要分别把oldQueue在区间<u>**[start,arrayLength-1]和区间[0,theBack]**</u>复制到newQueue的区间[0,arrayLength-start-1]和区间[**<u>arrayLength-start</u>**,arrayLength+theBack-start]上，所以newQueue整体有arrayLength+theBack-start+1=arrayLength+theBack-theFront个元素，和上述的size()结果对应的上。

​		copy语句要求左开右闭的指针，故第1个区间对应的是**<u>[start,arrayLength]</u>**，第2个区间对应的是**<u>[0,theBack+1]</u>**，尾部+1即可。

```c++
copy(queue + start, queue + arrayLength, newQueue);// 语句5
copy(queue, queue + theBack + 1, newQueue + arrayLength - start);// 语句6
```

​		至此push函数分析完毕，完整的代码如下所示。

```c++
template<class T>
void arrayQueue<T> ::push(const T & theElement)
{
    if ((theBack + 1) % arrayLength == theFront) // 语句1
    {
        T* newQueue = new T[2 * arrayLength];
        int start = (theFront + 1) % arrayLength; // 语句2
        if (start < 2) // 语句3
            copy(queue + start, queue + start + arrayLength - 1, newQueue);// 语句4
        else
        { 
            copy(queue + start, queue + arrayLength, newQueue);// 语句5
            copy(queue, queue + theBack + 1, newQueue + arrayLength - start);// 语句6
        }
        theFront = 2 * arrayLength - 1;// 语句7
        theBack = arrayLength - 1 - 1;// 语句8
        arrayLength *= 2;
        isChangeArrayLength = true;
        queue = newQueue;
    }
    theBack = (theBack + 1) % arrayLength;// 语句9
    queue[theBack] = theElement; // 语句10
}
```

​		  还有2个函数，front和back函数，如下所示。

```c++
template<class T>
T& arrayQueue<T> ::front()
{
    if (theFront == theBack)
        throw queueEmpty();
    return queue[(theFront + 1) % arrayLength]; // 大面上就是有无拓展过容量,比如theFront=7,但是真正的front应该在0这里;至于pop对theFront的影响在pop已经执行了对theFront的更改,不影响这里
};
template<class T>
T& arrayQueue<T> ::back()
{
    if (theFront == theBack)
        throw queueEmpty();
    return queue[theBack]; // theBack就是尾部元素的实际位置
};
```

​		最后1个函数是<<重载函数，如果不借助私有函数output，在<<的重载函数中只能利用pop和front，但是不能利用queue，那么很难实现打印操作，因为front总是访问首部元素。如果是栈，可以每次访问top，然后pop，再访问top，这样要求传入的参数是复制而不是引用，还是可以实现打印整个栈的。下边这段程序，如果只有push，打印出来是对的，但是有过pop就会有一些元素打不出来，因为那些元素的内存还在只是没有赋值，就显示不出想要的打印效果。

```c++
template<class T>
ostream& operator<<<>(ostream& out, arrayQueue<T> theQueue)
{
    while( !theQueue.empty())
	{
    	out << theQueue.front()<<"  ";
    	theQueue.pop();
	}
	return out;
}

```

​			借助output私有函数，就简单了，因为output可以直接访问queue，对于重载函数，只需要借助这个函数即可。

```c++
template<class T>
ostream& operator<<<>(ostream& out, arrayQueue<T> & theQueue)
{
    theQueue.output(out);
    return out;
}
```

​		output函数，打印queue时，因为是否pop过会影响queue的起始位置，是否拓展过容量也会影响queue的起始访问位置。如果没有pop过且没有拓展过容量，问题就比较简单，只需要从1访问到theBack即可，0的位置就是NULL；但是拓展过容量，需要从0开始访问，但是此时theFront对应的位置还是NULL。如果pop过，也是从0访问到arrayLength-1，还要看theFront和theBack的关系，如果theBack大，说明只有[theFront+1,theBack]才有元素，其余是NULL；如果是theFront大，那就有点麻烦，[theFront+1,arrayLength-1]和[0,theBack]有元素，其余都是NULL。

```c++
template<class T>
void arrayQueue<T>::output(ostream & out) const
{
    if (empty())
    {
        for (int i = 0; i < arrayLength; i++)
        {
            out << "queue[" << i << "] = " << "NULL" << "  ";
            if ((i + 1) % 5 == 0)
                out << endl;
        }
        return;
    }

    if (isPop)
    {
        for (int i = 0; i < arrayLength; i++)
        {
            if (theFront > theBack)
            {
                if (theBack < i && i <= theFront)
                    out << "queue[" << i << "] = " << "NULL" << "  ";
                else
                    out << "queue[" << i << "] = " << queue[i] << "  ";
            }
            else
            {
                if (i >theBack || i <= theFront)
                    out << "queue[" << i << "] = " << "NULL" << "  ";
                else
                    out << "queue[" << i << "] = " << queue[i] << "  ";
            }
            if ((i + 1) % 5 == 0)
                out << endl;
        }
    }
    else
    {
        for (int i = 0; i <= theBack; i++) 
        {
            if (i == theFront)
                out << "queue[" << i << "] = " << "NULL" << "  ";
            else
                out << "queue[" << i << "] = " << queue[i] << "  ";
            if ((i + 1) % 5 == 0)
                out << endl;
        }
    }
}
```

#### 9.1.1.3 总结

​		首先分析没有过pop过元素，只是执行push和拓展容量。

​		①  初始化，theFront=theBack=0，queue[1]到queue[arrayLength-1]可用于存储数据。

​		②  开始push，theBack一直增加直到arrayLength-2趋近临界点，(theBack+1)%arrayLength==0的条件始终不满足，照例执行theBack = (theBack + 1) % arrayLength并在queue[arrayLength-1]插入元素。theFront不变始终为0并指向queue[0]，是队首元素的前1个。

​		③  此时queue已满，但对外theBack=arrayLength-1没满，再插入要拓展容量，此时满足(theBack+1)%arrayLength==0。而theFront还是0，所以start=(theFront+1)%arrayLength=1，把oldQueue[start,arrayLength]也就是[1,arrayLength-1]的元素copy至newQueue[0,arrayLength-2]，所以将theBack变为arrayLength-2。因为newQueue[0]是队首元素，它的前一个应当是theFront，所以赋值为2 * arrayLength - 1。

​		④  如果没有pop元素，theFront的值不会发生改变，继续push，(theBack+1)%arrayLength==0的条件始终不满足直到theBack=2 * arrayLength - 2接近临界点，然后theBack增至2 * arrayLength - 1。之后if判断语句再次成立，由于theFront为上一次拓展容量后的值2 * arrayLength - 1没变过，所以start=0(**<u>这也是为何要对arrayLength-1取余数的原因，总能回到真正的队首元素所在位置</u>**)，然后将oldQueue[start,2 * arrayLength-1]=oldQueue[0,2 * arrayLength-1]复制到newQueue[0,2 * arrayLength-2]，所以theBack要变为2 * arrayLength-2，然后在newQueue[2 * arrayLength-1 ]的位置插入元素，同时theFront又变成了4 * arrayLength - 1 。

​		后面继续push插入元素到满，再拓展容量的过程分析过程类似，theFront总是∈{0,2 * arrayLength - 1}，theBack总是取到arrayLength-1后退后1步，size总是∈{0,1}。

​		观察可以看出，没有pop的情况下，以上过程总是满足以下的逻辑顺序。

​		1. theBack先到达arrayLength-2的位置，然后增至arrayLength-1 => 

​		2. 满足if判断条件，拓展容量，确定真实的队首元素位置start，theFront总是在start的前1位，theFront∈{0,2 * arrayLength - 1}，所以总是start=1或0满足<2(前提是没有过pop)，且1只会取到1次(在第1次拓展容量取到即theFront=0) => 

​		3. 复制元素oldQueue[start,arrayLength-1]到newQueue[0,arrayLength-2]，将theBack也改为arrayLength-2(只在拓展容量的时候才会减1，也就是if语句成立的时候执行，这是为了兼容独立于if语句本就有的theBack = (theBack + 1) % arrayLength) =>

​		4. 把theFront改为2 * arrayLength - 1 ，arrayLength * 2，if语句执行结束 =>

​		5. 执行theBack = (theBack + 1) % arrayLength)，增至arrayLength-1，在newQueue[arrayLength-1]的位置插入元素 =>

​		6. 之后又回到1.的逻辑，只是arrayLength是原来的2倍，if语句自然不成立，直到theBack再一次到达arrayLength-2的位置

​		所以可以看出，front函数返回queue[(theFront + 1) % arrayLength]，是正确的，相当于queue[start]，start才是真实的队首元素位置；back函数返回queue[theBack]也没有问题，且theBack总是会取到arrayLength-1的位置。

​		继续分析执行过pop的情况。

​		⑤ pop会先执行theFront = (theFront+1) % arrayLength，也就是会增1，其实就是到达start的真实队首元素位置，然后再执行queue[theFront]~T()删除队首元素。

​		⑥ 删除1个theFront就会前进1次，最多到达theBack=arrayLength-1时会删除queue[arrayLength-1]，此时队列为空再次执行pop时，就因为theFront == theBack而抛出队空异常。

​		⑦  如果没有拓展过容量，pop也还没有删除到队空，此时进行push。如果theBack尚未到达arrayLength-1(因为队列不是满的)，会在队尾继续添加元素，直到队尾；如果再次push，由于此时队首存在空闲位置，所以theBack=(theBack+1)%arrayLength变成了0！那么就在queue[arrayLength-1]插完元素后在queue[0]继续插入，直到queue[theFront-1]的位置。queue[theFront+1]是真实的队首元素，queue[theFront]是占位，没有元素，看起来形成了1个环状队列。

​		⑧  如果没有拓展过容量，pop已经删除到队空，此时进行push。在pop结束的时候，必定theBack=theFront=arrayLength-1，然后执行push的if判断，发现成立！所以依然会拓展容量，只是此时start=0(相当于又回到最初的状态，但是容量是2 * arrayLength)，copy语句其实就是啥也没复制，theBack要退后1步，theFront等于2 * arrayLength - 1，然后theBack再增加1步变成arrayLength - 1，在这个位置插入元素！所以即使已经删除到队空，插入第1个元素依然是从queue[arrayLength - 1]开始，然后是queue[arrayLength]，直到queue[2 * arrayLength-1]，此时theBack = 2 * arrayLength-1，回到⑦的过程，theBack=0。

​		⑨  如果已经拓展过容量，pop没删除到队空，还是执行⑦的逻辑，删除到队空再插，执行⑧的逻辑。

​		无论有没有pop、有没有拓展过容量以及它们交叉的情况都已经分析完毕，现在回到size函数。

​		size函数返回(theBack - theFront + arrayLength) % arrayLength。在没有过pop函数的情况下，其实queue的元素在(theFront,theBack]之间，theFront总是在start的后边，根据闭区间[a,b]元素个数为b-a+1，刨除开区间，所以元素个数为theBack-theFront；如果有过pop，theBack可能小于theFront，实际上元素个数要分为2个闭区间进行计算，即[theFront+1,arrayLength-1]和[0,theBack]，根据b-a+1的计算合计恰好为arrayLength + theBack - theFront。合并2种情况，其实就等价于(theBack - theFront + arrayLength) % arrayLength。

```c++
if (theBack > theFront) 
    return theBack - theFront;
else
    return arrayLength + theBack - theFront;
```

​		再次分析output函数。

  1. 如果没有过pop，queue从下标1或者拓展过容量从下标0开始存储数据，所以需要统一从下标0开始遍历，结束值一定是theBack，只是theBack最大取到arrayLength-1，不会越过0，即for (int i = 0; i <= theBack; i++)。但是queue[theFront]没有元素，但是theFront会取到0或者arrayLength-1，所以还需要限定if (i == theFront) 则输出NULL。

  2. 如果有过pop，queue元素应当从theFront+1索引访问到theBack索引，但是因为theBack可能越0的原因，需要分成两种情况。如果不越0，即theBack > theFront，theBack最大取到arrayLength-1，此时只有[theFront+1,theBack]会有元素，等价于(i >theBack || i <= theFront)没有元素；如果越过0，其实就是[theFront+1,arrayLength-1]和[0,theBack]有元素，即(theBack,theFront]没有元素，和(theBack < i && i <= theFront)等价。

  3. 鉴于theBack会取到0，也会取到arrayLength-1，所以遍历语句为(int i = 0; i < arrayLength; i++)。

     ```c++
     for (int i = 0; i < arrayLength; i++)
         if (theFront > theBack)
             if (theBack < i && i <= theFront)
                 out << "queue[" << i << "] = " << "NULL" << "  ";
     		else
         		out << "queue[" << i << "] = " << queue[i] << "  ";
     	else
         	if (i >theBack || i <= theFront)
             	out << "queue[" << i << "] = " << "NULL" << "  ";
     		else
         		out << "queue[" << i << "] = " << queue[i] << "  ";
     ```


## 9.3 链表描述

​		链表描述，分析过程要比数组描述简单。数组描述theFront总是在队首元素的前一位，因为pop的关系可能会造成theFront向前移动，同时theBack也可能越过0，两种情况下还要进行不同的copy操作，原因都来源于数组访问元素要进行遍历。所以对索引在特殊情况、边界情况的处理会很麻烦，而链表描述使用的是结构体的data来访问，只需要定义2个指针，分别指向队首元素和队尾元素即可，然后从队首元素开始依次链接到下一个，队尾指针的next是NULL。链表描述的具体类声明如下。

```c++
#include <sstream>
#include "charter9_abstractQueue.h"
#include "charter9_queueEmpty.h"
#include "charter9_queueNode.h"
template<class T>
class linkedQueue : public abstractQueue<T>
{
public:
    linkedQueue(int initialCapacity = 10){queueBack=queueFront = NULL; queueSize = 0;}
    ~linkedQueue();
    bool empty() const{return queueSize == 0;}
    int size() const{return queueSize;}
    T& front();
    T& back();
    void pop();
    void push(const T&);
    void output(std::ostream &) const;
    friend ostream& operator <<<>(ostream&, const linkedQueue<T>&);
private:
    // 采用从头到尾的链接方式,初始时queueFront=queueBack=NULL
    // 当且仅当队列为空时queueFront=NULL,queueBack就是队尾元素,queue->next始终为NULL
    queueNode<T>* queueFront;  // 队首元素指针
    queueNode<T>* queueBack;   // 队尾元素指针
    int queueSize;            
};
```

​		front和back函数如下，只需要判断是否队空，然后直接返回存储的数据即可。

```c++
template<class T>
T& linkedQueue<T> ::front()
{
    if (queueSize == 0)
        throw queueEmpty();
    return queueFront->data;
}

template<class T>
T& linkedQueue<T> ::back()
{
    if (queueSize == 0)
        throw queueEmpty();
    return queueBack->data;
}
```

​		push函数如下，需要分2种情况，以前没有节点则让队首指针直接指向它即可；如果有节点，就要让以前的队尾指针的下一个指向new的节点，再更新队尾指针。new的节点一开始是以NULL构建的，即new的next总是NULL。

```c++
template<class T>
void linkedQueue<T>::push(const T& theElement)
{

   // 以新数据和NULL创建1个新节点,newNode->next=NULL,newNode->element=theElement
    queueNode<T>* newNode = new queueNode<T>(theElement, NULL);

    if (queueSize == 0)
        queueFront = newNode;       // 如果以前没节点,新节点就是队首节点
    else
        queueBack->next = newNode;  // 否则直接连接上原来的队尾节点和新节点
    queueBack = newNode; // 更新队尾节点

    queueSize++;
}
```

​		pop和析构函数如下，处理过程差不多。

```c++
template<class T>
void linkedQueue<T>::pop()
{
    if (queueFront == NULL)
        throw queueEmpty();

    queueNode<T>* nextNode = queueFront->next;
    delete queueFront;
    queueFront = nextNode; // 类似于析构的代码,只是这里就删除1个
    queueSize--;
}

template<class T>
linkedQueue<T>::~linkedQueue()
{
    while (queueFront != NULL) // 最终到达队尾就是NULL
    {
        queueNode<T>* nextNode = queueFront->next;
        delete queueFront;
        queueFront = nextNode;
    }
}
```

​		output输出函数如下，借助一个指针指向队首，然后通过NULL即可遍历，数组队列就无法这样，只能借助数组遍历分情况处理。

```c++
template<class T>
void linkedQueue<T>::output(ostream& out) const
{
    if (empty())
    {
        out << "the queue is empty!"<<endl; 
        return;
    }
    queueNode<T>* nextNode = queueFront;
    int idx = 0;
    while (nextNode != NULL)
    {
        out << nextNode->data << "  ";
        nextNode = nextNode->next;
        idx++;
        if (idx % 10 == 0)
            out << endl;
    }
    if (idx % 10 != 0 && idx != 0)
        out << endl;
}
```

## 9.4 应用

### 9.4.1 列车车厢重排

#### 9.4.1.1 借助队列

​		相比于利用栈，队列要简单一些。相同点在于输入的车厢编号都必须大于缓冲道的所有车厢，不同点在于一个push在队列的back，删除是从队列的front删除；一个是push到栈的top，删除也是top。

​		首先需要几个全局变量。

```c++
arrayQueue<int>* trackC9; // 全局队列指针,动态的开辟指定数量的缓冲轨道
arrayQueue<int> sortedCarriageC9; // 排序好的车厢存放处
int nCarsC9; // 给定的车厢数
int nTracksC9; // 给定的缓冲轨道数
int smallestNumC9; // 缓冲轨道最小的车厢编号
int belongToTrackC9; // 最小的车厢编号所属的缓冲轨道编号
```

​		主函数如下。

```c++
bool carriageRearrangeC9(int* permutation, int nCars, int nTracks)
{
	nCarsC9 = nCars;
	nTracksC9 = nTracks - 1;// 有1个通道是用于直接输出车厢的
    trackC9 = new arrayQueue<int>[nTracks]; // 为这些缓冲通道开辟内存
    int nextCarToOutput = 1; // 初始化下一个应该输出的车厢编号为1
    smallestNumC9 = nCarsC9 + 1;  // 随便给个数初始化,目前的最小编号是10

    for (int i = 1; i <= nCarsC9; i++) // 从1遍历是因为permution[0]没用
        if (permutation[i] == nextCarToOutput) // 如果正好就是下1个直接输出
        {
            cout << "move car " << permutation[i] << " to output track" << endl;
            sortedCarriageC9.push(permutation[i]);
            nextCarToOutput++;

            // 如果缓冲道没车厢执行上方程序就结束了
            // 如果有车厢,因为nextCarToOutput已经++,继续判断缓冲道是否存在下一个该输出的车厢
            while (smallestNumC9 == nextCarToOutput) // 如果有
            {
                moveInOutputTrackC9(); // 把车厢从缓冲道移出
                nextCarToOutput++; // 更新下一个该出的车厢编号
                if (smallestNumC9 == nCarsC9 + 1) // 防止smallestNumC9=10,且nextCarToOutput也等于10退不出循环
                    break;
            }
            
        }
        else // 如果不是应该出的车厢就移入缓冲道
            if (!moveInBufferTrackC9(permutation[i])) // 移入成功就继续下一个输入轨道的车厢
                return false; // 移入失败就重排失败

    return true;

}
```

​		从缓存车道移除车厢和从输入车道移入缓存车道的函数如下。

```c++
bool moveInBufferTrackC9(int nextCar)
{
    // 目的是为了找到最合适的缓冲道给下一个输入车厢
    // 输入车厢能去的缓冲道有2个选择,一个是空缓冲道,一个是非空缓冲道但是里边的车厢编号都小于nextCar
    // 因为trackC9[i].back()是最大的,所以让它和nextCar比较就可以了
    // 如果确实有这样的非空缓冲道,也有空缓冲道,少占用1个车厢显然更好,所以应该在非空缓冲道追加该车厢
    // 而下边的代码布局,如果不为空就先进入执行,空缓冲道是最后的选择就满足了上边的优先级关系
    // 初始化,目前最好的缓冲道还是0,但编号至少从1开始
    int bestTrack = 0,  
        bestBack = 0;  // 多个可以输入的缓冲道,最大的back被记录在该变量,初始化是0

    // 遍历每个缓冲道
    for (int i = 1; i <= nTracksC9; i++)
        if (!trackC9[i].empty()) // 先判断缓冲道不为空,比较back和nextCar即可
        {
            if (nextCar > trackC9[i].back() && trackC9[i].back() > bestBack) 
            {
                // 即使缓冲道i能够满足条件,但是可能有很多这样的缓冲道都能满足条件
                // 例如nextCar=5,现在通道1有车厢4和2,通道2有车厢3,1,显然nextCar进入通道1更好
                // 也就是比较每个满足条件的缓冲道的back,更大的来追加nextCar,所以需要引入新变量bestBack
                // 第1个缓冲道的back肯定比0大会被放进bestBack,下一个缓冲道的back就会和这个bestBack比较
                // 如果下一个的back更大就更新bestBack,同时更新bestTrack
                bestBack = trackC9[i].back();
                bestTrack = i;
            }
        }
        else // 队空总是最后的选择,如果没有合适的非空缓冲道才会占用1个新的缓冲道(如果有的话)
            if (bestTrack == 0) // 如果没有合适的非空缓冲道,bestTrack还是0
                bestTrack = i;// 如果有多个空缓冲道,编号最小的空缓冲道先被使用

    if (bestTrack == 0) // 空缓冲道也没有就gg
        return false; 

     // 确定了最合适的缓冲道以后就可以添加车厢了
    trackC9[bestTrack].push(nextCar);
    cout << "move car " << nextCar << " from input track "
        << "to buffer track " << bestTrack << endl;

    if (nextCar < smallestNumC9) // 这个已经被添加的车厢可能比目前的最小车厢小
    {
        smallestNumC9 = nextCar; // 如果nextCar就更新smallestNumC9
        belongToTrackC9 = bestTrack; // 最小车厢属于的缓冲道也改变
    }
    return true;
}
void moveInOutputTrackC9()
{
    // 最小编号车厢在上次进入本函数就知道了属于那个缓冲道
    // 如果输入车厢移到了缓冲道,最小车厢及其属于的缓冲道也已经调整过
    trackC9[belongToTrackC9].pop(); // 删除这个最小编号车厢,队列的队尾删除法
    cout << "move car " << smallestNumC9 << " from bufferTrack("
        << belongToTrackC9 << ") to output track" << endl;
    sortedCarriageC9.push(smallestNumC9);
    // 检查每个缓冲队列,找到最小的车厢编号和属于的缓冲道
    smallestNumC9 = nCarsC9 + 1; // 可能缓冲道没有车厢,那么应当保持为初始化状态 =10就可以了
    for (int i = 1; i <= nTracksC9; i++) // 遍历每个缓冲队列
        if (!trackC9[i].empty() && trackC9[i].front() < smallestNumC9) // 缓冲道i不为空,且队列最小的元素都比最小编号小
        {
            // 缓冲道的车厢编号从back到front是越来越小的,所以front最小
            //如果它小于以前的smallestNumC9,就更新smallestNumC9
            smallestNumC9 = trackC9[i].front();
            belongToTrackC9 = i; // smallestNumC9对应的缓冲道
        }
}
```

#### 9.4.1.2 不借助队列

​		（1）首先回归栈和队列是如何重排车厢的。

​		如果是栈或者队列，都定义了全局变量track、最小车厢编号smallestNum以及它属于的缓冲道belongToTrackC8，并定义了2个个用于存储重排后车厢编号的变量sortedCarriage。nTracks是指定的缓存道个数，如果是栈，还需要1条非缓存道用于从入轨到出轨的操作，则track的大小为为nTracks+1；如果是队列，直接拿1条作为入轨-出轨道，剩下的nTracks-1才是缓存道，则track的大小为nTracks。也就是说，指定同样的缓存道个数，使用栈其实不够，还需要多1个主轨道。

```c++
trackC8 = new arrayStack<int>[nTracks + 1];
nTracksC8 = nTracks;
for (int i = 1; i <= nTracksC8; i++)

trackC9 = new arrayQueue<int>[nTracks];
nTracksC9 = nTracks - 1;
for (int i = 1; i <= nTracksC9; i++)
```

​		然后都定义下一个车厢的变量nextCarToOutput，遍历输入车厢序列每个车厢编号permutation[i]，**<u>如果nextCarToOutput==permutation[i]，就直接从入轨道到出轨道即可</u>**，无需缓存，队列和栈都可以使用sortedCarriage.push[permutation[i]]。因为nextCarToOutput已经++，所以下一个要出的车厢可能在缓存道里边，所以要继续判断while循环是否成立，队列和栈的判断条件都是smallestNum == nextCarToOutput，因为缓存道下一个能出去的车厢必定是smallestNum，所以比较它和nextCarToOutput是不是相等即可，如果不相等，说明下一个该出的车厢还在入轨道没过来；如果相等就移出smallestNum，即track[belongToTrack].pop()，移出1个车厢后缓存道的smallestNum发生变化会在缓存->出轨道函数进行相应的更新，同时外部的nextCarToOutput也++，直到while条件不满足为止。这里要注意的是如果smallestNum=nCars+1，而nextCarToOutput++后其实也到了nCars+1，会导致while循环不能退出，所以需要添加终止条件，即当smallestNum=nCars+1时就退出，**<u>原书代码不是这样处理的</u>**，**<u>它是让smallestNum=nCars+2</u>**，虽然这样可以，但是不太容易理解，就是每次进入这个函数都会让smallestNum=nCars+2，后边再更改为trackC8[i].top()或者 trackC9[i].front()。while循环的临界条件是nextCarToOutput=nCars+1，如果smallestNum=nCars+1就无法退出循环，所以让smallestNumC8=nCars+2。

```c++
smallestNumC8 = nCarsC8 + 2; // 原书的代码
smallestNumC9 = nCarsC9 + 2; // 原书的代码

smallestNumC8 = trackC8[i].top();
smallestNumC9 = trackC9[i].front()
```

​		对于缓存道->出轨道函数，栈和队列都使用pop把smallestNum从缓存道belongToTrackC8移出。对于**<u>队列来说，比较每个缓冲道的front()</u>**，就可以得到最小的车厢编号smallestNum；对于**<u>栈</u>**，top()也是最小的车厢编号，**<u>比较每个缓冲道的top()</u>**即可。

```c++
trackC8[belongToTrackC8].pop(); 
trackC9[belongToTrackC9].pop(); 
```

​		因为移除了1个车厢，肯定要更新smallestNum和belongToTrackC8，栈和队列进行比对，唯一的区别就是top()和front()，但都是为了找到最小的车厢编号smallestNum。因为在while循环给出了smallestNum=nCars+1就退出while循环的条件，所以这里没有按照原书代码来，就给定smallestNum = nCars + 1即可，缓冲道有车的话还会更改值。

```c++
trackC8[belongToTrackC8].pop()
smallestNumC8 = nCarsC8 + 1; 
for (int i = 1; i <= nTracksC8; i++)
{
    if (!trackC8[i].empty() && (trackC8[i].top() < smallestNumC8))
    {
        smallestNumC8 = trackC8[i].top();
		belongToTrackC8 = i;
    }
}

trackC9[belongToTrackC9].pop()
smallestNumC9 = nCarsC9 + 1; 
for (int i = 1; i <= nTracksC9; i++)
{
    if (!trackC9[i].empty() && trackC9[i].front() < smallestNumC9)
    {
        smallestNumC9 = trackC9[i].front();
        belongToTrackC9 = i;
    }
}
```

​		上述的分析已经知道**<u>缓冲栈的最大车厢编号就是栈底，最小车厢编号在栈顶top()；缓冲队列的最大车厢编号是back()，最小车厢是front()</u>**。这个区别还体现在入轨道->缓存道函数，该函数的调用前提是nextCarToOutput≠permutation[i]，下边继续分析。

​		**<u>如果permutation[i]≠nextCarToOutput不等</u>**，说明这个车厢应当被缓存，缓存的函数里边要做的事情就是找**<u>到最合适的缓冲道，相同点是都是先找非空的缓冲栈/队列，再找空的，尽量少占用空的缓冲道，所以相同的语句都有if (bestTrack == 0) bestTrack = i;</u>**。然后车厢nextCar被push到bestTrack，对于队列push的位置是back()，对于栈还是top()。然而top是缓冲栈中最小的车厢编号，back是缓冲队列最大的车厢编号，所以if判断语句是不同的。

​		对于栈，第1个条件因为栈的push在top()，要求当前的车厢nextCar编号比当前缓存栈的top小才能入栈，如果缓冲栈车厢编号大的在上边就不能完成重排，这是硬性条件。第2个条件是希望找到top()更小的那个缓存栈，出栈时可以有更多的连续性，例如trackC8[1].top()=5，trackC8[2].top()=4，而nextCar=3，显然去第2个缓存栈更合适，连续性更强，车厢3出去了紧接着就是同一缓存栈的车厢4而不用切缓存栈去pop车厢4。然后让bestTop记录。bestTop一开始初始化为nCarsC8 + 1而不是0的原因是因为top可能是任何车厢编号，最大就是nCarsC8，最终bestTop=min{trackC8[i].top()}。

​		对于队列，第1个条件也是硬性条件，但队列的push是在back()，所以要比缓冲队列的尾部车厢编号大才能完成重排。第2个条件是希望找到back()更大的那个缓冲队列，出队列时有更多连续性，例如trackC9[1].back()=5，trackC9[2].back()=6，而nextCar=7，显然去第2个缓存队列更合适，连续性更强，车厢6出去了紧接着就是同一缓存队列的车厢7而不用切缓存队列去pop车厢7。

```c++
int bestTrack = 0;
int bestTop= nCarsC8 + 1;
for (int i = 1; i <= nTracksC8; i++)
    if (!trackC8[i].empty()) 
    {
        if (nextCar < trackC8[i].top() && trackC8[i].top() < bestTop)
        {
            bestTop = trackC8[i].top(); 
            bestTrack = i;
        }
    }
	else
        if (bestTrack == 0) bestTrack = i; 
trackC8[bestTrack].push(nextCar);

int bestTrack = 0,
int bestBack = 0;
for (int i = 1; i <= nTracksC9; i++)
    if (!trackC9[i].empty()) 
    {
        if (nextCar > trackC9[i].back() && trackC9[i].back() > bestBack) 
        {
            bestBack = trackC9[i].back();
            bestTrack = i;
        }
    }
	else 
    	if (bestTrack == 0) bestTrack = i;
trackC9[bestTrack].push(nextCar);
```

​		再之后操作是一样的，因为车厢入缓存可能会改变缓存道的最小车厢编号，只需要让smallestNum=nextCar即可，同时因为上边已经找到了nextCar最适合的缓存道，让belongToTrackC8 = bestTrack即可。

```c++
if (nextCar < smallestNumC8) 
{
    smallestNumC8 = nextCar; 
    belongToTrackC8 = bestTrack; 
}

if (nextCar < smallestNumC9) 
{
    smallestNumC9 = nextCar; 
    belongToTrackC9 = bestTrack; 
}
```

​		（2）现在再来分析，不借助栈或者队列如何实现。

​		按照上述分析过程，首先是全局变量的定义。没有栈或者队列，首当其冲是入轨道->缓存道函数受到影响，bestTrack无法借助back/top之间的比较来得到，缓存道不能动态的push存入车厢，最小车厢编号也无从得知也就不知道它属于哪个缓存道belongToTrack，那么缓存->出轨道函数也就不能执行track[belongToTrack].pop()出轨操作，车辆出去1个，最小车厢编号又无法变化得不到更新。

​		全局变量只保留了车辆数和缓冲道数以及存储排序后序列的变量，即numberOfCars、numberOfTracks和sortedPermuation，就是以前的含义nCars和nTracks。smallestNum和belongToTrack删除。**<u>删除belongToTrack和smallestNum是因为引入了whichTrack</u>**，这个变量用于记录每个车厢编号应当去的缓存道，下标从1开始直到numberOfCars，下标0弃用，因为每个车厢都会事先记录好去向，所以不用找到最小车厢编号和它的去向。也就是在入轨->缓存道函数中，**<u>每个nextCar都会知道它最合适的缓存道去处，并用whichTrack[nextCar]=bestTrack∈[1,numberOfTracks]记录</u>**。lastCar[bestTrack]则是记录当前情况下缓冲道bestTrack的车厢编号，是覆盖操作，也就是不会记录以前bestTrack的车厢编号，所以是当前bestTrack的lastCar。

```c++
int* whichTrackC9;  
int* lastCarC9;
int* sortedPermuationC9; 
int numberOfCarsC9; 
int numberOfTracksC9; 

whichTrackC9 = new int[numberOfCarsC9 + 1];
lastCarC9 = new int[numberOfTracksC9 + 1];
sortedPermuationC9 = new int[numberOfCarsC9 + 1];
```

​		现在分析railRoad函数。首先whichTrack和lastCar都进行初始化，元素全部为0。whichTrack[nextCar]记录的是nextCar的缓存道索引，但**<u>有的车厢无需缓存直接从入轨到出轨，那么这样的whichTrack[nextCar]就会保持为0</u>**，while循环也不必执行，这也是为何**<u>whichTrack要初始化为0，因为后面可以作为while循环的条件</u>**。lastCar初始化为0的原因，在入轨->缓存函数进行说明。

​		在while循环外部会执行的nextCarToOutput为1、5、8，这些车厢是直接输出不借助缓存的。

```c++
bool railroad(int* inputOrder,int theNumberOfCars, int theNumberOfTracks)
{
    numberOfCarsC9 = theNumberOfCars;
    numberOfTracksC9 = theNumberOfTracks - 1; 
    lastCarC9 = new int[numberOfTracksC9 + 1]; 
    fill(lastCarC9 + 1, lastCarC9 + numberOfTracksC9 + 1, 0); 
    whichTrackC9 = new int[numberOfCarsC9 + 1]; 
    fill(whichTrackC9 + 1, whichTrackC9 + numberOfCarsC9 + 1, 0);
    sortedPermuationC9 = new int[numberOfCarsC9 + 1];
    int nextCarToOutput = 1;
    for (int i = 1; i <= numberOfCarsC9; i++) 
        if (inputOrder[i] == nextCarToOutput)
        {
            cout << "Move car " << inputOrder[i] << " from input "
                << "track to output track" << endl;
            sortedPermuationC9[nextCarToOutput] = inputOrder[i];
            nextCarToOutput++;
            while (nextCarToOutput <= numberOfCarsC9 && 
                whichTrackC9[nextCarToOutput] != 0) 
            {
                outputFromHoldingTrack(nextCarToOutput); 
                nextCarToOutput++; 
            }
        }
        else 
            if (!putInHoldingTrack(inputOrder[i]))
                return false;
    return true;
}
```

​		putInHoldingTrack函数如下，如果下一个车辆不是要输出的就执行这个函数，先缓存。bestLast和bestTop、bestBack一个意思，如果有多个缓存道合适的时候，选择更合适的那个。如果是**<u>栈或队列，与输入车厢编号更接近的top或者back就是最合适的缓存道</u>**。**<u>bestTop是寻找top更小的，bestBack是寻找back更大的</u>**，这是由栈push车厢存到top，队列push车厢存到back决定的。

​		**<u>lastCar初始化为0的原因就是它需要作为判断缓存道非空的条件</u>**。如果第1个缓存道就为0，直接使用即可；如果是第i(i＞1)个缓存道为0，说明前边的非空缓存道都不合适，所以使用第i个空的缓存道。

​		找到合适的缓存道要满足2个条件。第1个是硬性条件，nextCar车厢编号必须要比之前该缓存道的车厢编号大，有点类似于使用Queue描述一样，要求要比back大。第2个条件类似要找到更大的back，所以用bestLast记录更大的缓存道车厢。

​		这里可以看出不最大的区别是缓存栈/缓存队列可以根据入轨push很多缓存的车厢，然后根据出轨进行pop。**<u>lastCar是一个数组，所以不能动态记录和修改，只能进行覆盖操作，lastCar[i]永远是1个值，每次入轨都会变化，出轨不会</u>**。

​		本例来说，lastCar[1]从0->3->6->9，然后nextCar=2 < lastCar[1]=9，所以占用新的缓存道，lastCar[2]从0->2->4->7。继续nextCar=1直接出去了，紧接着车厢2、车厢3、车厢4出轨，lastCar[1]=9与lastCar[2]=7不会发生变化。然后nextCar=8，因为下一个应该是5，所以车厢8先入轨，因为nextCar=8不大于lastCar[1]=9但是大于lastCar[2]=7，且7的确大于bestLast=0，所以车厢8去的位置是缓存道2，即bestTrack=2，之后lastCar[2]自然被覆盖成了车厢8。然后nextCar=5，直接出轨，紧接着缓冲道的车厢6、车厢7出轨，车厢8也出轨，最后是车厢9出轨，lastCar都不会变。

​		看起来自始至终，bestLast没什么鸟用，只是本例没有测试到。因为本例最接近的测试，就是nextCar=8，而lastCar[1]=9与lastCar[2]=7。假如再增加1个lastCar[3]=6，在i=2时bestLast已经等于了lastCar[2]=7，i=3时nextCar=8>lastCar[3]=6，但是lastCar[3]＜bestLast=lastCar[2]=7，所以车厢8更适合的缓存道为bestTrack=2，因为8更接近7而不是6。**<u>所以遵循的准则类似于使用Queue的back，因为输入的车厢编号会比缓冲道的都大，所以缓冲道尾部车厢更大的会更接近输入车厢编号，也就是更好</u>**。

​		后面就是whichTrack[nextCar] = bestTrack，每个进来的车厢都记录了去向；lastCar[bestTrack] = nextCar，是每次入轨都会覆盖掉原来缓冲道的车厢，nextCar是新的车厢。

```c++
bool putInHoldingTrack(int nextCar)
{
    int bestTrack = 0,  
        bestLast = 0;  
    for (int i = 1; i <= numberOfTracksC9; i++) 
        if (lastCarC9[i] != 0) 
        {   
            if (nextCar > lastCarC9[i] && lastCarC9[i] > bestLast) 
            {
                bestLast = lastCarC9[i]; 
                bestTrack = i; 
            }
        }
        else 
            if (bestTrack == 0)
                bestTrack = i;
    if (bestTrack == 0) 
        return false; 
    whichTrackC9[nextCar] = bestTrack; 
    lastCarC9[bestTrack] = nextCar; 
    cout << "Move car " << nextCar << " from input track "
        << "to holding track " << bestTrack << endl;
    return true;
}
```

​		outputFromHoldingTrack函数如下，如果下一个要输出的车厢在缓存道里就会执行，在putInHoldingTrack函数就已经事先知道了该车厢的缓存道去向，所以打印信息即可。通过此函数执行的nextCar除了编号1、5、8之外都是，例如如果是车厢6，就在位置6存储6。

​	根据上述对本例的分析，lastCar[1]从3变到9然后不变，lastCar[2]从2变到7，后来变成8。本函数从nextCar=2开始，在这之前3、6、9、2、4、7都已经安排好了位置，所以此时lastCar[1]=9，lastCar[2]=7。然后车厢2移出，因为出轨操作不会影响lastCar，所以都没变化，紧接着车厢3、车厢4也是如此。车厢5在车厢8后面所以车厢8先入轨，lastCar[2]=8。然后车厢5直接出轨，紧接着车厢6出轨。车厢7在putInHoldingTrack函数中推荐的bestTrack为2，即whichTrack[7]=2，此时lastCar[2]=8，所以 7 ≠ 8也不执行。然后车厢8，whichTrack[8]=2，此时8＝8因为就会重置lastCar[2]=0。**<u>为什么要置0呢，因为lastCar[2]的最后1个车厢8都出去了，这个缓存道是没有车辆的，如果不修改会影响bestTrack的选择</u>**。然后车厢9，直接出去，不影响lastCar[2]，但是因为whichTrack[9]=1，而lastCar[1]=9，所以9 == 9，也**<u>会把第1个缓存道置0，因为lastCar[1]的最后1个车厢9不存在</u>**了。

```c++
void outputFromHoldingTrack(int nextCar)
{
    cout << "Move car " << nextCar << " from holding track "
        << whichTrackC9[nextCar] << " to output track" << endl;
    sortedPermuationC9[nextCar] = nextCar; // c=2,3,4,6,7,9会存储2,3,4,6,7,9
    if (nextCar == lastCarC9[whichTrackC9[nextCar]])
        lastCarC9[whichTrackC9[nextCar]] = 0; 
}
```

### 9.4.2 电路布线问题

​		与迷宫老鼠问题找到一条路径不同，还要找到最短的路径，首先定义全局变量。

```c++
int** wireGrid;       // 电路棋盘的二维数组(方阵)
int wireSize;         // 棋盘长度
wirePosition wireStart,   // 路径起点
wireFinish;  // 路径终点
arrayQueue<wirePosition> wirePath; // 用队列存储路径
```

​		主函数布局如下，其中inputWireGrid()函数和welcomeWire()函数参考了迷宫老鼠问题，只改动了少量代码。

```c++
#include <iostream>
#include <assert.h>
#include "chapter9_arrayQueue.h"
#include "chapter8_make2dArray.h"
#include "chapter9_wirePosition.h"
void welcomeWire();
void inputWireGrid();
bool findWirePath();
void outputWirePath();
void _chapter9_circuit_wiring()
{
    inputWireGrid();
    welcomeWire();
    if (findWirePath())
        outputWirePath();
    else
        cout << "There is no wire path" << endl;
}
```

​		outputWirePath()函数，原书代码使用的是wirePosition类型的数组来存储的，所以打印方式是遍历这个数组即可得到每个位置。这里笔者将其改为使用队列，所以不同于原书的代码需要wirePath[j]=here的赋值操作，只需要wirePath.push(here)即可。那么outputWirePath()函数就很简单了，因为cout<<queue<<endl已经重载过，直接输出即可。再次调用welcomeWire()函数是为了观察经过距离标记后的wireGrid的情况如何。

```c++
void outputWirePath()
{
    cout << "The wire path is" << endl;
    cout << "wireFinsh => " << wirePath << "(1,1) => wireStart" << endl;
    cout << "wireGrid has changed! The wireGrid shape is as follows " << endl;
    welcomeWire(); // 再次调用观察wireGrid的真实布局
}
```

​		核心函数是findWirePath()。寻找最短路径需要2个过程,1个是距离标记,1个是路径标记，距离标记是以起点开始记为0,它相邻的方格标记为1,1相邻的方格都标注为2，以此类推,直到终点,那么终点的距离标记就是从起点到终点的距离。路径标记可以使用队列wireQueue存储。距离标记可以使用另外1个二维数组存储距离,但是会耗费较大的内存，所以可以考虑重用wireGrid来存储,但是编号1会有冲突,1可以看成是1个障碍也可以看成是距离标记1，为了避免冲突,障碍用1表示,但是起点不从0开始而是从2开始,那么wireGrid[i][j]>1表示1个位置。这个位置到起点的距离是wireGrid[i][j]-2,例如起点相邻的位置路径标记为3,它到起点的距离就是1，非障碍且没有到达的位置是0,障碍位置为1,非障碍已到达位置为路径距离标记。

​		经过do-while循环后就找到了路径，这个路径需要回溯得到。回溯过程要注意：在do-while找到路径的前提下,如观察P217图9-13比当前位置距离标记小的且相同的最多有2个位置，这个情况说明有2条最短路径,但是都一样短为18步,对于距离而言没有区别。本例设计的也有2条最短路径,位置(9,9)->(9,10)->(10,10)或者(9,9)->(10,9)->(10,10)，do-while过程已经对(9,9)的相邻位置都标注为19,即(9,10)和(9,10)的距离标记都是19，可以在outputWirePath()函数中观察到。

```c++
bool findWirePath()
{
    cout << "Start looking for a path? If yes, please hit enter" << endl;
    system("pause");
    if ((wireStart.row == wireFinish.row) && (wireStart.col == wireFinish.col))
        return true;
    wirePosition offset[4];
    offset[0].row = 0; offset[0].col = 1;   // right
    offset[1].row = 1; offset[1].col = 0;   // down
    offset[2].row = 0; offset[2].col = -1;  // left
    offset[3].row = -1; offset[3].col = 0;  // up
    
    wirePosition here = wireStart; // 目前的位置在起点处
    wireGrid[wireStart.row][wireStart.col] = 2; // 标记起点距离标志为2
    int numOfNbrs = 4; // here的位置相邻有4个方格
    arrayQueue<wirePosition> wireQueue;//用于存储到达每个位置时相邻位置的路径标记
    wirePosition nbr; // 相邻的位置
    do
    {  // 每到1个位置就标记周边的4个方格
        for (int i = 0; i < numOfNbrs; i++) // 遍历每个邻居来进行路径距离标记
        {
            nbr.row = here.row + offset[i].row; // 依次使用4个偏置(→↓←↑)
            nbr.col = here.col + offset[i].col;
            if (wireGrid[nbr.row][nbr.col] == 0) // 非障碍且未到达位置才能进行路径标记
            {
                wireGrid[nbr.row][nbr.col]
                    = wireGrid[here.row][here.col] + 1; // 相邻位置的距离只需+1
                if ((nbr.row == wireFinish.row) &&
                    (nbr.col == wireFinish.col)) break; // 标记1个位置就要判断这个位置是不是终点
                wireQueue.push(nbr); // 标记过的位置都会被存储
            }
        }
        // 为什么多加1步终点判断?
        // 假设here就是wireFinsh,它能到达这里,说明它的相邻位置不是>1的就距离标记就是障碍1
        // 那么上边的for循环中,第1个if判断都不成立,所以也不会有后面的终点判断
        // 到达终点但do-while循环没有退出,再执行后面的程序会出错
        if ((nbr.row == wireFinish.row) &&
            (nbr.col == wireFinish.col)) break;  

        // wireQueue能是空的说明没有位置被距离标记过,只有障碍1,没有路径
        if (wireQueue.empty())
            return false; 
        // 因为邻居是右下左上方向遍历的,最好的情况是有4个方向都可以走,那么wireQueue最多会存4个位置
        // 优先级也是优先向右移动(如果右边可以移动的话)
        here = wireQueue.front(); // 每个可以移动的方向都尝试,here一旦更改wireQueue又会更改
        wireQueue.pop(); // 尝试1个就删除1个,最后所有可能的方向都会遍历过且会到达终点
    } while (true);

    // 如果这样的路径存在的话,here已经到达了wireFinsh
    // do-while循环中已经改变了wireGrid[10][10]的距离标记
    int wirePathLength = wireGrid[wireFinish.row][wireFinish.col] - 2; // 获取路径长度

    here = wireFinish; // 从终点开始回溯路径
    // 根据距离标记来找路径,最短路径是连续的距离标记
    for (int j = wirePathLength - 1; j >= 0; j--) // 本例预计wirePathLength=18,数组从17-0记录
    {
        wirePath.push(here);
        for (int i = 0; i < numOfNbrs; i++) // 终点周边的4个位置
        {
            nbr.row = here.row + offset[i].row;
            nbr.col = here.col + offset[i].col;
            if (wireGrid[nbr.row][nbr.col] == j + 2) break; 
            // 最多有2个等于19,但是因为遍历的方向优先级左>上,所以最短路径选择了(9,9)<-(10,9)<-(10,10)
        }
        here = nbr;  // 找到标记19后就让here移动到它这里
    }
    assert(wirePathLength == wirePath.size()); // 路径长度必然等于size()
    return true;
}
```

### 9.4.3 图元识别问题

​		图元识别问题就是根据图像像素值的分布来划分区域，对相同区域的像素都给定相同的记号，这在图像分割领域非常常见。同样借助make2dArray函数模拟1个图像。这里模拟的图像大小为10×10，其像素分布如下。

```markdown
    0    1    2    3    4    5    6    7    8    9    10   11
0   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.
1   0.   1    1    1    1    0    0    1    1    1    1    0.
2   0.   0    0    0    1    0    0    0    1    1    1    0.
3   0.   1    1    0    1    0    0    0    0    1    1    0.
4   0.   0    1    1    1    0    1    0    0    0    1    0.
5   0.   0    1    1    0    1    1    1    0    0    0    0.
6   0.   0    0    0    1    1    1    1    1    0    0    0.
7   0.   0    0    0    0    1    1    1    0    1    1    0.
8   0.   1    1    1    0    0    1    0    0    0    1    0.
9   0.   1    1    1    0    0    0    0    1    0    1    0.
10  0.   1    1    1    0    0    0    0    1    1    1    0.
11  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.
```

​		经过标记后的图像如下。

```markdown
    0    1    2    3    4    5    6    7    8    9    10   11
0   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.
1   0.   2    2    2    2    0    0    3    3    3    3    0.
2   0.   0    0    0    2    0    0    0    3    3    3    0.
3   0.   2    2    0    2    0    0    0    0    3    3    0.
4   0.   0    2    2    2    0    4    0    0    0    3    0.
5   0.   0    2    2    0    4    4    4    0    0    0    0.
6   0.   0    0    0    4    4    4    4    4    0    0    0.
7   0.   0    0    0    0    4    4    4    0    5    5    0.
8   0.   6    6    6    0    0    4    0    0    0    5    0.
9   0.   6    6    6    0    0    0    0    5    0    5    0.
10  0.   6    6    6    0    0    0    0    5    5    5    0.
11  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.
```

​		welcomeImage函数、outputImage函数和imputImage函数和电路布线的3个函数类似，不再说明。

​		对于labelImage函数如下所示，offset计算坐标偏置是类似的，然后遍历每个像素。类似的广度搜索，找到每个位置here相邻的元素，如果没标记过将其入栈或者入队列，然后再出栈出队列，直到没有像素不被标记或者遇到障碍0，就退出循环。

```c++
void labelImage()
{
    cout << "Start marking the pixel distribution of the image~" << endl;
    pixelPosition offset[4];
    offset[0].row = 0; offset[0].col = 1;   // right
    offset[1].row = 1; offset[1].col = 0;   // down
    offset[2].row = 0; offset[2].col = -1;  // left
    offset[3].row = -1; offset[3].col = 0;  // up

    int numOfNbrs = 4;
    // 用于存储与here相邻的任意位置,为空说明已经没有标记为1的像素
    arrayQueue<pixelPosition> q; 
    pixelPosition here, nbr;
    int id = 1; // 未标记的像素都是1或者0

    for (int r = 1; r <= imageSize; r++)      
        for (int c = 1; c <= imageSize; c++)   
            if (imageGrid[r][c] == 1) // 遍历每个像素,如果找到标记1的
            {
                imageGrid[r][c] = ++id; //就标记该像素为下1个id=2,3,4...取决于像素分布
                here.row = r;
                here.col = c;

                while (true)
                {
                    for (int i = 0; i < numOfNbrs; i++) // 遍历here周围的相邻像素
                    {
                        nbr.row = here.row + offset[i].row;
                        nbr.col = here.col + offset[i].col;
                        if (imageGrid[nbr.row][nbr.col] == 1) // 相邻像素有没标记的
                        {
                            imageGrid[nbr.row][nbr.col] = id; // 标记它
                            q.push(nbr); // 并记录它,q记录过的或者说标记过的像素不会再次满足if条件
                        }
                    }

                    if (q.empty()) break; // 直到q不再有标记过的像素说明所有相邻像素都已经标记过
                    here = q.front(); // 让here移动到新添加的相邻的标记过的像素
                    q.pop(); // 原来添加过的像素已经标记过,它周边相邻的也已经标记过,pop无需再次重复
                }
            } 
}
```

### 9.4.5 工厂仿真问题

​		这个问题啊，有点说不清楚，代码确实写了，但是整个过程确实比较复杂，这里不在给出分析过程。

​		详细可见P222页至P232页。

本章结束~
