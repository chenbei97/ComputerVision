/*
本cpp没有代码只说明原理和举例
#####  原理

​		基数排序是基于箱子排序实现的，箱子排序需要确定排序的对象个数和范围。
		例如20(n)个学生的学生分数只可能在0-5(range=6)内，所以每次排序如果是普通箱子排序
		需要1个chain *类型的指针bin,初始化长度为range,需要range个执行步
		如果是链表成员函数，bottom和 top的初始化也需要range步
		之后是节点分配，也就是遍历每个学生放入不同的箱子，执行的步数都是20步
		最后是收集学生，依然是遍历箱子，需要range个执行步
		所以箱子排序的时间复杂度为 *O*(range+n)

​		现在假设有10个数字分布在0-999的范围内，仿照箱子排序，n=10，range=1000
		那么初始化指针需要1000个执行步，遍历排序的数字10个执行步，收集数字1000个执行步，共计2010步。

​		上述例子对时间步的执行可能还不够直观。

​		不妨假设对0~10^6-1的1000个整数进行排序，n=1000，range=10^6，那么总计会执行2×10^6+10^3步
		这么大的内存消耗和时间步是不可估量的，故现在引入1种基数(r)排序的方法
		这里的range其实就是r的一个特例，即r=10^6作为基数，相当于把0~10^6-1的数按间隔为1进行分段来制造箱子。

​		现在考虑一个事实，每个数字都是由个位、十位、百位...构成的，位置上的数代表多大取决于进制的大小
		但是可以确定的是这个位置上的数都在0-进制的范围内。

​		举例，十进制数3725(10)，个位5，十位2，百位7，千位3，它们都是0-9的范围内的；6进制数125(6)，每位的数字只能在0-6的范围内
		16进制数ACD(16)，每位只能在0-F的范围；再如60进制数125(60)，它就等于60^2+2×60+5=3725(10)，但是1、2、5是在0-59的范围。

​		对于上述例子，如果基数r=3726，说明把0-3725分成了3726段，但是这过于细分，依次从低位比较到高位比较也可以确定数字的大小
		例如r=10，另一个十进制数只需要比较和3725的低位到高位即可，即5、2、7、3，就可以判断这个数和3725的大小关系；r=60也是一样。

#####  举例

​		现在以最开始的问题说明原理，即0-999的范围内对10个数进行排序。0-999可以转为0-10^3-1，这个范围内的任何数显然最多使用3位数就可以表示，即个位、十位、百位
		可以推广为0-10^c-1，基数r=1000时只需要1位数就可以表示这个数，例如999(1000)，把999看成整体，也就是1000进制数；r=10时，最多需要c位数就可以表示这个数。

​		如果采用基数r=1000，那么箱子排序只需要排序1次，但是需要2010个执行步；

​		如果采用基数r=10，箱子排序需要执行3次，每次箱子排序需要r+n+r=30次，总计90个执行步，关于箱子排序次数与幂数c的关系下文会推广；

​		假设输入链表(n=10)的数字为

​		216->521->425->116->91->515->124->34->96->24

​		1）对个位应用箱子排序

​		521->91->124->34->24->425->515->216->116->96

​		注意排序后124->34->24依然保持原有的顺序，这是箱子排序的具有稳定性排序性质。

​		2）对十位应用箱子排序

​		515->216->116->521->124->24->425->34->91->96

​		3）对百位应用箱子排序

​		24->34->91->96->116->124->216->425->515->521

​		注意一定要从低位到高位排序，因为高位才能最终决定大小，而低位排序是可以保证高位相同时低位进行过比较。

​		其实也可以用基数r=100来执行呢，这是因为最大的数1000用100进制数表示为9,99(100)=9×100+99=999(10)，根本用不到百分位
		所以实际上只需要对个位和十位排序2次就可以，执行次数为2×(100+100+10)=420个执行步
		但是这样相当于没有充分利用r=100的性能，在评估性能时总是使用其上限能力。

​		所以如果r=100，更倾向于在0-10^2-1或者0-10^2x-1的范围使用这种基数排序，就能充分利用该基数的排序能力。

​		例如，对于0-10^6-1的范围，可以使用r=10，r=100，r=1000和r=10^6，即总是取r^h的h为c的公约数，那么排序次数就等于c/h。

​		对于r=10^6(h=6)，需要c/h×(2r+n)=1×(2×10^6+10)个执行步；

​		对于r=10^3(h=3)，需要c/h×(2r+n)=6/3(2×10^3+10)=4020步；

​		对于r=10^2(h=2)，需要c/h×(2r+n)=6/2(2×10^2+10)=630步；

​		对于r=10^1(h=1)，需要c/h×(2r+n)=6/1(2×10^1+10)=180步；

​		这仅仅是对10个数字进行排序，自然效率上肯定是r=10最好，但有时候未必。

​		如果是对1000个数字排序，即n=1000，此时就依次变为(2×10^6+1000)、2(2×10^3+1000)=6000、3(2×10^2+1000)=3600、6(20+1000)=6120个执行步
		所以此时r=100比较划算，效率最高
		取r=10^5依然需要2次排序，为2(2×10^5+1000)，r=10^4还是至少2次排序，2(2×10^4+1000)，还不如直接使用r=10^3，也就是说浪费了r=10^4和10^5的能力，显得鸡肋。

​		一般的，对0-r^c-1范围内排序r(即n=r)个整数，每个整数都可以使用c个位数来表示，需要的执行次数为c/h(2r+r)=3cr/h
		由于n=r，也可写成3c/h * n，由于3c/h是个常量(h是r的幂数)，所以时间复杂度就是*O*(n)

​		关于基数排序，首先要实现将数字转为r进制进行表示，只是我们更习惯使用10进制，所以计算上忽略
		然而如果r=100，1000或者其它非10的进制，例如6，60或者180等，还需要了解如何快速进行进制转换。

​		假如以r=10来分解1个数x，那么从低位到高位的数字分解式为：

​		x % 10 , (x%100)/10，(x%1000)/100，...

​		若r=100，则数字分解式为：

​		x % 100，(x%10000)/100，(x%1000000)/10000，...

​		推广，对于基数r，其分解式为：

​		x%r，(x%r^2)/r，(x%r^3)/r^2，...
*/