#include <iostream>
using namespace std;
#include "quote_pointer.h"
// 赋值运算符重载 
// 例如c++编译器至少给一个类添加4个函数 拷贝、析构、构造以及赋值运算符operator对属性进行拷贝
// 这里的赋值就是重载 可以一次性都赋值
// 注 ：  类中有属性指向堆区 赋值操作时也会涉及深浅拷贝问题
class Person0
{
public :
	Person0(int age)
	{
		_age = new  int(age);
		cout << "---------有参构造函数初始化---------" << endl;
	}		
	// 正常情况如果析构函数不加下述代码正常运行 加了下述代码反而出现问题
	// 这是因为第二次进入析构函数时首先检查_age是否为空 由于p2有了p1的地址确实不为空 然后释放内存 实际上p1已经释放过了
	// 如果析构函数一定要加判断的代码 为了防止重复释放内存  需要给赋值或者拷贝后的变量地址开辟内存而不是只有一个地址
    // 换句话说 拷贝和赋值都是浅层操作  应该使用深度拷贝或者重载赋值运算 将拷贝或者赋值改变
	// 编译器执行的默认操作是浅拷贝 只是拷贝了一份地址 没有拷贝一份内存
	~Person0() 
	{
		if (_age != NULL)
		{
			delete _age;
			_age = NULL;
			cout << "------------析构函数到此一游-------------" << endl; 
		}
	}

	Person0 & operator=(Person0& p)
	{
		
	   // _age = p._age  // p2=p1  ; 程序运行结束p1释放一次内存 紧接着由于p2浅拷贝再一次释放地址对应的内存引发崩溃
		_age = new int(*p._age);
		cout << "------------重载析构函数到此一游-------------" << endl;
		return *this;
	}
	Person0(const Person0& p , int) // 或者直接定义自己的拷贝函数也可以
	{
		_age = p._age;
		cout << "------------浅拷贝函数到此一游-------------" << endl;
		// 拷贝函数不需要返回值
	}
	Person0 (const Person0& p) // 或者直接定义自己的拷贝函数也可以
	{
		_age = new int(*p._age);
		cout << "------------深拷贝函数到此一游-------------" << endl;
	  // 拷贝函数不需要返回值
	}
public : 
	int* _age;
};
void test_0006()
{
	Person0 p1(324);
	Person0 p2(30);
	p2 = p1;// 如果注释掉赋值深拷贝的函数(31-38行代码) 这里对一个地址重复释放内存就会崩溃
	cout << "p1的年龄为 :  " << *p1._age<< endl;
	cout << "p2的年龄为 :  " << *p2._age << endl;

	Person0 p3(p2);
}
void test_0007()
{
	Person0 p1(10);
	Person0 p2(p1, 2);
}
int assignment_Operator()
//int main()
{
	//copy_Construct(); // 拷贝构造函数运行
	//Deep_Shallow_Copy(); // 深拷贝与浅拷贝
	// classMember(); // 类作为类成员
	//static_member_func(); // 类的静态变量和静态函数
	//this_pointer(); // this 指针的使用
	//friend_use(); // 友元的使用
	// operatorOverload(); // 加减运算符重载
	//leftmove(); // 左移运算符重载
	//increment_Operator();  //  递增运算符重载

	test_0006();
	/*
	---------有参构造函数初始化---------
	---------有参构造函数初始化--------- //创建对象时构造初始化
	------------重载析构函数到此一游------------- // 对应赋值操作  p2=p1 赋值时就执行
	p1的年龄为 :  324
	p2的年龄为 :  324
	------------深拷贝函数到此一游------------- // 对应拷贝操作 Person p3(p1) 拷贝时就执行
	------------析构函数到此一游------------- // 然后析构p1
	------------析构函数到此一游------------- // 继续析构p2
	------------析构函数到此一游------------- // 继续析构p3

	*/
	
	//test_0007();  // 浅拷贝在就会崩溃
    return 0;
}